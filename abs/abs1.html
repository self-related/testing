<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <meta
     name="generator"
     content=
    "HTML Tidy for Linux/x86 (vers 1st July 2002), see www.w3.org">

    <title>Advanced Bash-Scripting Guide - Часть 1</title>
    <meta
     http-equiv="Content-Type"
     content="text/html; charset=koi8-r">
    <meta
     name="GENERATOR"
     content="Modular DocBook HTML Stylesheet Version 1.7">
  </head>
  <a href="/testing/index.html">Главная</a>
  <body
   class="BOOK"
   bgcolor="#FFFFFF"
   text="#000000"
   link="#0000FF"
   vlink="#840084"
   alink="#0000FF">
    <div
     class="BOOK">
      <a
       name="AEN1"></a>

      <div
       class="TITLEPAGE">
        <h1
         class="TITLE"><a
         name="AEN2"></a>Advanced Bash-Scripting Guide - Часть 1</h1>

        <h2
         class="SUBTITLE">Искусство программирования на языке сценариев
        командной оболочки</h2>

        <h3
         class="AUTHOR"><a
         name="AEN5"></a>Автор: Mendel Cooper</h3>

        <div
         class="AFFILIATION">
          <span
           class="ORGNAME"><br>
          </span>

          <div
           class="ADDRESS">
            <p
             class="ADDRESS"><tt
             class="EMAIL">&lt;<a
             href=
            "mailto:thegrendel@theriver.com">thegrendel@theriver.com</a>&gt;</tt></p>
          </div>
        </div>

        <h3
         class="AUTHOR"><a
         name="AEN14"></a>Перевод: Андрей Киселев</h3>

        <div
         class="AFFILIATION">
          <span
           class="ORGNAME"><br>
          </span>

          <div
           class="ADDRESS">
            <p
             class="ADDRESS"><tt
             class="EMAIL">&lt;<a
             href=
            "mailto:kis_an@mail.ru">kis_an@mail.ru</a>&gt;</tt></p>
          </div>
        </div>

        <div>
          <div
           class="ABSTRACT">
            <a
             name="AEN102"></a>

            <p>Данное руководство не предполагает наличие у читателя
            познаний в области программирования на языке сценариев,
            однако, быстро восполняет этот недостаток <span
             class="emphasis"><em
             class="EMPHASIS">. . . постепенно, шаг за шагом раскрывая
            мудрость и красоту UNIX</em></span>. Это руководство может
            рассматриваться как учебник, предназначенный для
            самостоятельного изучения или как справочник по
            программированию на shell. Руководство снабжено серией
            хорошо прокомментированных примеров, поскольку <tt
             class="USERINPUT"><strong>лучший путь к изучению языка
            сценариев -- это написание сценариев</strong></tt>.</p>

            <p>Последнюю версию документа, в виде <a
             href="#BZIPREF">.bz2</a> архива, содержащем исходные
            тексты в формате SGML и HTML, вы найдете на <a
             href=
            "http://personal.riverusers.com/~thegrendel/abs-guide-1.8.tar.bz2"
             target="_top">домашней страничке автора</a>. Там же вы
            найдете и <a
             href=
            "http://personal.riverusers.com/~thegrendel/Change.log"
             target="_top">change log</a>.</p>
          </div>
        </div>
        <hr>
      </div>
      <hr>

      <h1><a
       name="AEN110"></a>Посвящения</h1>

      <p>Посвящается Аните -- источнику очарования</p>

      <div
       class="TOC">
        <dl>
          <dt><strong>Содержание</strong></dt>

          <dt>Часть 1. <a
           href="#PART1">Введение</a></dt>

          <dd>
            <dl>
              <dt>1. <a
               href="#WHY-SHELL">Зачем необходимо знание языка
              Shell?</a></dt>

              <dt>2. <a
               href="#SHA-BANG">Для начала о Sha-Bang</a></dt>

              <dd>
                <dl>
                  <dt>2.1. <a
                   href="#INVOKING">Запуск сценария</a></dt>

                  <dt>2.2. <a
                   href="#PRELIMEXER">Упражнения</a></dt>
                </dl>
              </dd>
            </dl>
          </dd>

          <dt>Часть 2. <a
           href="#PART2">Основы</a></dt>

          <dd>
            <dl>
              <dt>3. <a
               href="#SPECIAL-CHARS">Служебные символы</a></dt>

              <dt>4. <a
               href="#VARIABLES">Переменные и параметры.
              Введение.</a></dt>

              <dd>
                <dl>
                  <dt>4.1. <a
                   href="#VARSUBN">Подстановка переменных</a></dt>

                  <dt>4.2. <a
                   href="#VARASSIGNMENT">Присваивание значений
                  переменным</a></dt>

                  <dt>4.3. <a
                   href="#UNTYPED">Переменные Bash не имеют
                  типа</a></dt>

                  <dt>4.4. <a
                   href="#OTHERTYPESV">Специальные типы
                  переменных</a></dt>
                </dl>
              </dd>

              <dt>5. <a
               href="#QUOTING">Кавычки</a></dt>

              <dt>6. <a
               href="#EXIT-STATUS">Завершение и код завершения</a></dt>

              <dt>7. <a
               href="#TESTS">Проверка условий</a></dt>

              <dd>
                <dl>
                  <dt>7.1. <a
                   href="#TESTCONSTRUCTS">Конструкции проверки
                  условий</a></dt>

                  <dt>7.2. <a
                   href="#FTO">Операции проверки файлов</a></dt>

              </dd>

      <div
       class="PART">
        <a
         name="PART1"></a>

        <div
         class="TITLEPAGE">
          <h1
           class="TITLE">Часть 1. Введение</h1>

          <div
           class="PARTINTRO">
            <a
             name="AEN114"></a>

            <p>Shell -- это командная оболочка. Но это не просто
            промежуточное звено между пользователем и операционой
            системой, это еще и мощный язык программирования. Программы
            на языке shell называют <span
             class="emphasis"><em
             class="EMPHASIS">сценариями</em></span>, или <span
             class="emphasis"><em
             class="EMPHASIS">скриптами</em></span>. Фактически, из
            скриптов доступен полный набор команд, утилит и программ
            UNIX. Если этого недостаточно, то к вашим услугам
            внутренние команды shell -- условные операторы, операторы
            циклов и пр., которые увеличивают мощь и гибкость
            сценариев. Shell-скрипты исключительно хороши при
            программировании задач администрирования системы и др.,
            которые не требуют для своего создания полновесных языков
            программирования.</p>
          </div>

          <div
           class="TOC">
            <dl>
              <dt><strong>Содержание</strong></dt>

              <dt>1. <a
               href="#WHY-SHELL">Зачем необходимо знание языка
              Shell?</a></dt>

              <dt>2. <a
               href="#SHA-BANG">Для начала о Sha-Bang</a></dt>

              <dd>
                <dl>
                  <dt>2.1. <a
                   href="#INVOKING">Запуск сценария</a></dt>

                  <dt>2.2. <a
                   href="#PRELIMEXER">Упражнения</a></dt>
                </dl>
              </dd>
            </dl>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="WHY-SHELL"></a>Глава 1. Зачем необходимо знание языка
          Shell?</h1>

          <p>Знание языка командной оболочки является залогом успешного
          решения задач администрирования системы. Даже если вы не
          предполагаете заниматься написанием своих сценариев. Во время
          загрузки Linux выполняется целый ряд сценариев из <tt
           class="FILENAME">/etc/rc.d</tt>, которые настраивают
          конфигурацию операционной системы и запускают различные
          сервисы, поэтому очень важно четко понимать эти скрипты и
          иметь достаточно знаний, чтобы вносить в них какие либо
          изменения.</p>

          <p>Язык сценариев легок в изучении, в нем не так много
          специфических операторов и конструкций. <a
           name="AEN123"
           href="#FTN.AEN123"><span
           class="footnote">[1]</span></a> Синтаксис языка достаточно
          прост и прямолинеен, он очень напоминает команды, которые
          приходится вводить в командной строке. Короткие скрипты
          практически не нуждаются в отладке, и даже отладка больших
          скриптов отнимает весьма незначительное время.</p>

          <p>Shell-скрипты очень хорошо подходят для быстрого создания
          прототипов сложных приложений, даже не смотря на ограниченный
          набор языковых конструкций и определенную
          &quot;медлительность&quot;. Такая метода позволяет детально
          проработать структуру будущего приложения, обнаружить
          возможные &quot;ловушки&quot; и лишь затем приступить к
          кодированию на C, C++, Java, или Perl.</p>

          <p>Скрипты возвращают нас к классической философии UNIX --
          &quot;разделяй и влавствуй&quot; т.е. разделение сложного
          проекта на ряд простых подзадач. Многие считают такой подход
          наилучшим или, по меньшей мере, наиболее эстетичным способом
          решения возникающих проблем, нежели использование нового
          поколения языков -- &quot;все-в-одном&quot;, таких как
          Perl.</p>

          <p>Для каких задач неприменимы скрипты</p>

          <ul>
            <li>
              <p>для ресурсоемких задач, особенно когда важна скорость
              исполнения (поиск, сортировка и т.п.)</p>
            </li>

            <li>
              <p>для задач, связанных с выполнением математических
              вычислений, особенно это касается вычислений с плавающей
              запятой, вычислений с повышенной точностью, комплексных
              чисел (для таких задач лучше использовать C++ или
              FORTRAN)</p>
            </li>

            <li>
              <p>для кросс-платформенного программирования (для этого
              лучше подходит язык C)</p>
            </li>

            <li>
              <p>для сложных приложений, когда структурирование
              является жизненной необходимостью (контроль за типами
              переменных, прототипами функций и т.п.)</p>
            </li>

            <li>
              <p>для целевых задач, от которых может зависеть успех
              предприятия.</p>
            </li>

            <li>
              <p>когда во главу угла поставлена безопасность системы,
              когда необходимо обеспечить целостность системы и
              защитить ее от вторжения, взлома и вандализма.</p>
            </li>

            <li>
              <p>для проектов, содержащих компоненты, очень тесно
              взаимодействующие между собой.</p>
            </li>

            <li>
              <p>для задач, выполняющих огромный объем работ с
              файлами</p>
            </li>

            <li>
              <p>для задач, работающих с многомерными массивами</p>
            </li>

            <li>
              <p>когда необходимо работать со структурами данных,
              такими как связанные списки или деревья</p>
            </li>

            <li>
              <p>когда необходимо предоставить графический интерфейс с
              пользователем (GUI)</p>
            </li>

            <li>
              <p>когда необходим прямой доступ к аппаратуре
              компьютера</p>
            </li>

            <li>
              <p>когда необходимо выполнять обмен через порты
              ввода-вывода или сокеты</p>
            </li>

            <li>
              <p>когда необходимо использовать внешние библиотеки</p>
            </li>

            <li>
              <p>для проприетарных, &quot;закрытых&quot; программ
              (скрипты представляют из себя исходные тексты программ,
              доступные для всеобщего обозрения)</p>
            </li>
          </ul>
          <br>
          <br>

          <p>Если выполняется хотя бы одно из вышеперечисленных
          условий, то вам лучше обратиться к более мощным скриптовым
          языкам программирования, например Perl, Tcl, Python, Ruby или
          к высокоуровневым компилирующим языкам -- C, C++ или Java. Но
          даже в этом случае, создание прототипа приложения на языке
          shell может существенно облегчить разработку.</p>

          <p>Название BASH -- это аббревиатура от <span
           class="QUOTE">&quot;Bourne-Again Shell&quot;</span> и игра
          слов от, ставшего уже классикой, <span
           class="QUOTE">&quot;Bourne Shell&quot;</span> Стефена Бурна
          (Stephen Bourne). В последние годы BASH достиг такой
          популярности, что стал стандартной командной оболочкой <em
           class="FOREIGNPHRASE">de facto</em> для многих
          разновидностей UNIX. Большинство принципов программирования
          на BASH одинаково хорошо применимы и в других командных
          оболочках, таких как Korn Shell (ksh), от которой Bash
          позаимствовал некоторые особенности, <a
           name="AEN165"
           href="#FTN.AEN165"><span
           class="footnote">[2]</span></a> и C Shell и его производных.
          (Примечательно, что C Shell не рекомендуется к использованию
          из-за отдельных проблем, отмеченных Томом Кристиансеном (Tom
          Christiansen) в октябре 1993 года на <a
           href=
          "http://www.etext.org/Quartz/computer/unix/csh.harmful.gz"
           target="_top">Usenet post</a></p>

          <p>Далее, в тексте документа вы найдете большое количество
          примеров скриптов, иллюстрирующих возможности shell. Все
          примеры -- работающие. Они были протестированы, причем
          некоторые из них могут пригодиться в повседневной работе.
          Уважаемый читатель можеть &quot;поиграть&quot; с рабочим
          кодом скриптов, сохраняя их в файлы, с именами <tt
           class="FILENAME">scriptname.sh</tt>. <a
           name="AEN172"
           href="#FTN.AEN172"><span
           class="footnote">[3]</span></a> Не забудьте выдать этим
          файлам право на исполнение (<tt
           class="USERINPUT"><strong>chmod u+rx
          scriptname</strong></tt>), после чего сценарии можно будет
          запустить на исполнение и проверить результат их работы. Вам
          следует помнить, что описание некоторых примеров следует
          после исходного кода этого примера, поэтому, прежде чем
          запустить сценарий у себя -- ознакомьтесь с его
          описанием.</p>

          <p>Скрипты были написаны автором книги, если не оговаривается
          иное.</p>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="SHA-BANG"></a>Глава 2. Для начала о Sha-Bang</h1>

          <p>В простейшем случае, скрипт -- это ни что иное, как
          простой список команд системы, записанный в файл. Создание
          скриптов поможет сохранить ваше время и силы, которые
          тратятся на ввод последовательности команд всякий раз, когда
          необходимо их выполнить.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX1"></a>

            <p><strong>Пример 2-1. cleanup: Сценарий очистки лог-файлов
            в /var/log</strong></p>
<pre
 class="PROGRAMLISTING">
# cleanup
# Для работы сценария требуются права root.

cd /var/log
cat /dev/null &gt; messages
cat /dev/null &gt; wtmp
echo &quot;Лог-файлы очищены.&quot;
</pre>
          </div>

          <p>Здесь нет ничего необычного, это простая
          последовательность команд, которая может быть набрана в
          командной строке с консоли или в xterm. Преимущество
          размещения последовательности команд в скрипте состоит в том,
          что вам не придется всякий раз набирать эту
          последовательность вручную. Кроме того, скрипты легко могут
          быть модифицированы или обобщены для разных применений.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX2"></a>

            <p><strong>Пример 2-2. cleanup: Расширенная версия
            предыдущего сценария.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# cleanup, version 2
# Для работы сценария требуются права root.

LOG_DIR=/var/log
ROOT_UID=0     # Только пользователь с $UID 0 имеет привилегии root.
LINES=50       # Количество сохраняемых строк по-умолчанию.
E_XCD=66       # Невозможно сменить каталог?
E_NOTROOT=67   # Признак отсутствия root-привилегий.


if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo &quot;Для работы сценария требуются права root.&quot;
  exit $E_NOTROOT
fi

if [ -n &quot;$1&quot; ]
# Проверка наличия аргумента командной строки.
then
  lines=$1
else
  lines=$LINES # Значение по-умолчанию, если число не задано в командной строке
fi


#  Stephane Chazelas предложил следующее,
#+ для проверки корректности аргумента, переданного из командной строки,
#+ правда это достаточно сложно для данного руководства.
#
#    E_WRONGARGS=65  # Не числовой аргумент
#
#    case &quot;$1&quot; in
#    &quot;&quot;      ) lines=50;;
#    *[!0-9]*) echo &quot;Usage: `basename $0` file-to-cleanup&quot;; exit $E_WRONGARGS;;
#    *       ) lines=$1;;
#    esac
#
#* Конец проверки корректности аргумента


cd $LOG_DIR

if [ `pwd` != &quot;$LOG_DIR&quot; ]  # или   if [ &quot;$PWD&quot; != &quot;$LOG_DIR&quot; ]
                            # Не в /var/log?
then
  echo &quot;Невозможно перейти в каталог $LOG_DIR.&quot;
  exit $E_XCD
fi  # Проверка каталога перед очисткой лог-файлов.

# более эффективный вариант:
#
# cd /var/log || {
#   echo &quot;Невозможно перейти в требуемый каталог.&quot; &gt;&amp;2
#   exit $E_XCD;
# }




tail -$lines messages &gt; mesg.temp # Сохранить последние строки в лог-файле.
mv mesg.temp messages


# cat /dev/null &gt; messages
#* Необходимость этой команды отпала, поскольку очистка выполняется выше.

cat /dev/null &gt; wtmp  #  команды &#39;: &gt; wtmp&#39; и &#39;&gt; wtmp&#39;  имеют тот же эффект.
echo &quot;Лог-файлы очищены.&quot;

exit 0
#  Возвращаемое значение 0
#+ указывает на успешное завершение работы сценария.
</pre>
          </div>

          <p>Если вы не желаете полностью вычищать системные логи, то
          выше представлена улучшенная версия предыдущего сценария.
          Здесь сохраняются последние несколько строк (по-умолчанию --
          50).</p>

          <p>Если файл сценария начинается с последовательности <span
           class="TOKEN">#!</span>, которая в мире UNIX называется <em
           class="FIRSTTERM">sha-bang</em>, то это указывает системе
          какой интерпретатор следует использовать для исполнения
          сценария. <a
           name="MAGNUMREF"></a>Это двухбайтовая последовательность,
          или <a
           name="AEN199"
           href="#FTN.AEN199"><span
           class="footnote">[4]</span></a> -- специальный маркер,
          определяющий тип сценария, в данном случае -- сценарий
          командной оболочки (см. <tt
           class="USERINPUT"><strong>man magic</strong></tt>). Более
          точно, <span
           class="emphasis"><em
           class="EMPHASIS">sha-bang</em></span> определяет
          интерпретатор, который вызывается для исполнения сценария,
          это может быть командная оболочка (shell), иной интерпретатор
          или утилита. <a
           name="AEN207"
           href="#FTN.AEN207"><span
           class="footnote">[5]</span></a></p>
<pre
 class="PROGRAMLISTING">
#!/bin/sh
#!/bin/bash
#!/usr/bin/perl
#!/usr/bin/tcl
#!/bin/sed -f
#!/usr/awk -f
</pre>
          <br>
          <br>

          <p>Каждая, из приведенных выше сигнатур, приводит к вызову
          различных интерпретаторов, будь то <tt
           class="FILENAME">/bin/sh</tt> -- командный интерпретатор
          по-умолчанию (<strong
           class="COMMAND">bash</strong> для Linux-систем), либо иной.
          <a
           name="AEN220"
           href="#FTN.AEN220"><span
           class="footnote">[6]</span></a> При <a
           href="#PORTABILITYISSUES">переносе</a> сценариев с
          сигнатурой <tt
           class="USERINPUT"><strong>#!/bin/sh</strong></tt> на другие
          UNIX системы, где в качестве командного интерпретатора задан
          другой shell, вы можете лишиться некоторых особенностей,
          присущих bash. Поэтому такие сценарии должны быть <span
           class="ACRONYM">POSIX</span> совместимыми. <a
           name="AEN230"
           href="#FTN.AEN230"><span
           class="footnote">[7]</span></a>.</p>

          <p>Обратите внимание на то, что сигнатура должна указывать
          правильный путь к интерпретатору, в противном случае вы
          получите сообщение об ошибке -- как правило это <span
           class="QUOTE">&quot;Command not found&quot;</span>.</p>

          <p>Сигнатура <span
           class="TOKEN">#!</span> может быть опущена, если вы не
          используете специфичных команд. Во втором примере (см. выше)
          использование сигнатуры <span
           class="TOKEN">#!</span> обязательно, поскольку сценарий
          использует специфичную конструкцию присваивания значения
          переменной <tt
           class="USERINPUT"><strong>lines=50</strong></tt>. Еще раз
          замечу, что сигнатура <tt
           class="USERINPUT"><strong>#!/bin/sh</strong></tt> вызывает
          командный интерпретатор по-умолчанию -- <tt
           class="FILENAME">/bin/bash</tt> в Linux-системах.</p>

          <div
           class="IMPORTANT">
            <table
             class="IMPORTANT"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/important.gif"
                 hspace="5"
                 alt="Important"></td>

                <td
                 align="left"
                 valign="top">
                  <p>В данном руководстве приветствуется модульный
                  подход к построению сценариев. Записывайте, собирайте
                  свою коллекцию участков кода, который может вам
                  встретиться. В конечном итоге вы соберете свою
                  &quot;библиотеку&quot; подпрограмм, которые затем
                  сможете использовать при написании своих сценариев.
                  Например, следующий отрывок сценария проверяет
                  количество аргументов в командной строке:</p>
<pre
 class="PROGRAMLISTING">
if [ $# -ne Number_of_expected_args ]
then
  echo &quot;Usage: `basename $0` whatever&quot;
  exit $WRONG_ARGS
fi
</pre>
                  <br>
                  <br>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="INVOKING"></a>2.1. Запуск сценария</h2>

            <p>Запустить сценарий можно командой <tt
             class="USERINPUT"><strong>sh scriptname</strong></tt> <a
             name="AEN253"
             href="#FTN.AEN253"><span
             class="footnote">[8]</span></a> или <tt
             class="USERINPUT"><strong>bash scriptname</strong></tt>.
            (Не рекомендуется запуск сценария командой <tt
             class="USERINPUT"><strong>sh
            &lt;scriptname&gt;</strong></tt>, поскольку это запрещает
            использование устройства стандартного ввода <tt
             class="FILENAME">stdin</tt> в скрипте). Более удобный
            вариант -- сделать файл скрипта исполняемым, командой <a
             href="#CHMODREF">chmod</a>.</p>

            <div
             class="VARIABLELIST">
              <dl>
                <dt>Это:</dt>

                <dd>
                  <p><tt
                   class="USERINPUT"><strong>chmod 555
                  scriptname</strong></tt> (выдача прав на
                  чтение/исполнение любому пользователю в системе) <a
                   name="AEN266"
                   href="#FTN.AEN266"><span
                   class="footnote">[9]</span></a></p>
                </dd>

                <dt>или</dt>

                <dd>
                  <p><tt
                   class="USERINPUT"><strong>chmod +rx
                  scriptname</strong></tt> (выдача прав на
                  чтение/исполнение любому пользователю в системе)</p>

                  <p><tt
                   class="USERINPUT"><strong>chmod u+rx
                  scriptname</strong></tt> (выдача прав на
                  чтение/исполнение только &quot;владельцу&quot;
                  скрипта)</p>
                </dd>
              </dl>
            </div>
            <br>
            <br>

            <p>После того, как вы сделаете файл сценария исполняемым,
            вы можете запустить его примерно такой командой <tt
             class="USERINPUT"><strong>./scriptname</strong></tt>. <a
             name="AEN278"
             href="#FTN.AEN278"><span
             class="footnote">[10]</span></a> Если, при этом, текст
            сценария начинается с корректной сигнатуры (<span
             class="QUOTE">&quot;sha-bang&quot;</span>), то для его
            исполнения будет вызван соответствующий интерпретатор.</p>

            <p>И наконец, завершив отладку сценария, вы можете
            поместить его в каталог <tt
             class="FILENAME">/usr/local/bin</tt> (естественно, что для
            этого вы должны обладать правами root), чтобы сделать его
            доступным для себя и других пользователей системы. После
            этого сценарий можно вызвать, просто напечатав название
            файла в командной строке и нажав клавишу <strong
             class="KEYCAP">[ENTER]</strong>.</p>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="PRELIMEXER"></a>2.2. Упражнения</h2>

            <ol
             type="1">
              <li>
                <p>Системные администраторы часто создают скрипты для
                автоматизации своего труда. Подумайте, для выполнения
                каких задач могут быть написаны сценарии.</p>
              </li>

              <li>
                <p>Напишите сценарий, который выводит <a
                 href="#DATEREF">дату, время</a>, <a
                 href="#WHOREF">список зарегистрировавшихся
                пользователей</a>, и <a
                 href="#UPTIMEREF">uptime</a> системы и <a
                 href="#IOREDIRREF">сохраняет эту информацию</a> в
                системном журнале.</p>
              </li>
            </ol>
          </div>
        </div>
      </div>

      <div
       class="PART">
        <a
         name="PART2"></a>

        <div
         class="TITLEPAGE">
          <h1
           class="TITLE">Часть 2. Основы</h1>

          <div
           class="TOC">
            <dl>
              <dt><strong>Содержание</strong></dt>

              <dt>3. <a
               href="#SPECIAL-CHARS">Служебные символы</a></dt>

              <dt>4. <a
               href="#VARIABLES">Переменные и параметры.
              Введение.</a></dt>

              <dd>
                <dl>
                  <dt>4.1. <a
                   href="#VARSUBN">Подстановка переменных</a></dt>

                  <dt>4.2. <a
                   href="#VARASSIGNMENT">Присваивание значений
                  переменным</a></dt>

                  <dt>4.3. <a
                   href="#UNTYPED">Переменные Bash не имеют
                  типа</a></dt>

                  <dt>4.4. <a
                   href="#OTHERTYPESV">Специальные типы
                  переменных</a></dt>
                </dl>
              </dd>

              <dt>5. <a
               href="#QUOTING">Кавычки</a></dt>

              <dt>6. <a
               href="#EXIT-STATUS">Завершение и код завершения</a></dt>

              <dt>7. <a
               href="#TESTS">Проверка условий</a></dt>

              <dd>
                <dl>
                  <dt>7.1. <a
                   href="#TESTCONSTRUCTS">Конструкции проверки
                  условий</a></dt>

                  <dt>7.2. <a
                   href="#FTO">Операции проверки файлов</a></dt>

                  <dt>7.3. <a
                   href="#COMPARISON-OPS">Операции сравнения</a></dt>

                  <dt>7.4. <a
                   href="#NESTEDIFTHEN">Вложенные условные операторы
                  if/then</a></dt>

                  <dt>7.5. <a
                   href="#TESTTEST">Проверка степени усвоения
                  материала</a></dt>
                </dl>
              </dd>

              <dt>8. <a
               href="#OPERATIONS">Операции и смежные темы</a></dt>

              <dd>
                <dl>
                  <dt>8.1. <a
                   href="#OPS">Операторы</a></dt>

                  <dt>8.2. <a
                   href="#NUMERICAL-CONSTANTS">Числовые
                  константы</a></dt>
                </dl>
              </dd>
            </dl>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="SPECIAL-CHARS"></a>Глава 3. Служебные символы</h1>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="SCHARLIST1"></a>Служебные символы, используемые в
            текстах сценариев.</strong></p>

            <dl>
              <dt><span
               class="TOKEN">#</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Комментарии.</strong> Строки, начинающиеся
                  с символа <span
                   class="TOKEN">#</span> (<a
                   href="#MAGNUMREF">за исключением комбинации <span
                   class="TOKEN">#!</span></a>) -- являются
                  комментариями.</p>
                </div>
<pre
 class="PROGRAMLISTING">
# Эта строка -- комментарий.
</pre>
                <br>
                <br>

                <p>Комментарии могут располагаться и в конце строки с
                исполняемым кодом.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;Далее следует комментарий.&quot; # Это комментарий.
</pre>
                <br>
                <br>

                <p>Комментариям могут предшествовать <a
                 href="#WHITESPACEREF">пробелы</a> (пробел,
                табуляция).</p>
<pre
 class="PROGRAMLISTING">
       # Перед комментарием стоит символ табуляции.
</pre>
                <br>
                <br>

                <div
                 class="CAUTION">
                  <table
                   class="CAUTION"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/caution.gif"
                       hspace="5"
                       alt="Caution"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Исполняемые команды не могут следовать за
                        комментарием в той же самой строке. Пока что
                        еще не существует способа отделения комментария
                        от <span
                         class="QUOTE">&quot;исполняемого
                        кода&quot;</span>, следующего за комментарием в
                        той же строке.</p>
                      </td>
                    </tr>
                  </table>
                </div>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Само собой разумеется, экранированный символ
                        <span
                         class="TOKEN">#</span> в операторе <strong
                         class="COMMAND">echo</strong> не
                        воспринимается как начало комментария. Более
                        того, он может использоваться в <a
                         href="#PSUB2">операциях подстановки
                        параметров</a> и в <a
                         href="#NUMCONSTANTS">константных числовых
                        выражениях</a>.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;Символ # не означает начало комментария.&quot;
echo &#39;Символ # не означает начало комментария.&#39;
echo Символ \# не означает начало комментария.
echo А здесь символ # означает начало комментария.

echo ${PATH#*:}       # Подстановка -- не комментарий.
echo $(( 2#101011 ))  # База системы счисления -- не комментарий.

# Спасибо, S.C.
</pre>
                        <a
                         href="#QUOTINGREF">Кавычки &quot; &#39; и
                        \</a> экранируют действие символа #. <br>
                        <br>
                      </td>
                    </tr>
                  </table>
                </div>

                <p>В операциях <a
                 href="#PSOREX1">поиска по шаблону</a> символ <span
                 class="TOKEN">#</span> так же не воспринимается как
                начало комментария.</p>
              </dd>

              <dt><span
               class="TOKEN">;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Разделитель команд.</strong>
                  [Точка-с-запятой] Позволяет записывать две и более
                  команд в одной строке.</p>
                </div>
<pre
 class="PROGRAMLISTING">
echo hello; echo there
</pre>
                <br>
                <br>

                <p>Следует отметить, что символ <span
                 class="QUOTE">&quot;<span
                 class="TOKEN">;</span>&quot;</span> иногда так же как
                и # необходимо <a
                 href="#ESCP">экранировать</a>.</p>
              </dd>

              <dt><span
               class="TOKEN">;;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Ограничитель в операторе выбора <a
                   href="#CASEESAC1">case</a> .</strong>
                  [Двойная-точка-с-запятой]</p>
                </div>
<pre
 class="PROGRAMLISTING">
case &quot;$variable&quot; in
abc)  echo &quot;$variable = abc&quot; ;;
xyz)  echo &quot;$variable = xyz&quot; ;;
esac
</pre>
                <br>
                <br>
              </dd>

              <dt><span
               class="TOKEN">.</span></dt>

              <dd>
                <p><a
                 name="DOTREF"></a></p>

                <div
                 class="FORMALPARA">
                  <p><strong>команда <span
                   class="QUOTE">&quot;точка&quot;</span>.</strong>
                  Эквивалент команды <a
                   href="#SOURCEREF">source</a> (см. <a
                   href="#EX38">Пример 11-18</a>). Это <a
                   href="#BUILTINREF">встроенная</a> команда bash.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">.</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><span
                   class="QUOTE">&quot;точка&quot;</span> может
                  являться частью имени файла .</strong> Если имя файла
                  начинается с точки, то это <span
                   class="QUOTE">&quot;скрытый&quot;</span> файл, т.е.
                  команда <a
                   href="#LSREF">ls</a> при обычных условиях его не
                  отображает.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>touch .hidden-file</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 10
 -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -al</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 14
 drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
 drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
 -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file</tt>
               
</pre>
                  <br>
                  <br>
                </div>

                <p>Если подразумевается имя каталога, то <span
                 class="emphasis"><em
                 class="EMPHASIS">одна точка</em></span> означает
                текущий каталог и <span
                 class="emphasis"><em
                 class="EMPHASIS">две точки</em></span> -- каталог
                уровнем выше, или родительский каталог.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>pwd</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo/projects</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cd .</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>pwd</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo/projects</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cd ..</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>pwd</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo/</tt>
               
</pre>
                <br>
                <br>

                <p>Символ <span
                 class="emphasis"><em
                 class="EMPHASIS">точка</em></span> довольно часто
                используется для обозначения каталога назначения в
                операциях копирования/перемещения файлов.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>cp /home/bozo/current_work/junk/* .</strong></tt>
               
</pre>
                <br>
                <br>
              </dd>

              <dt><span
               class="TOKEN">.</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Символ <span
                   class="QUOTE">&quot;точка&quot;</span> в операциях
                  поиска.</strong> При выполнении <a
                   href="#REGEXDOT">поиска по шаблону</a> , в <a
                   href="#REGEXREF">регулярных выражениях</a>, символ
                  <span
                   class="QUOTE">&quot;точка&quot;</span> обозначает
                  одиночный символ.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">&quot;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#DBLQUO">Двойные кавычки</a> .</strong> В
                  строке <span
                   class="emphasis"><em
                   class="EMPHASIS">&quot;STRING&quot;</em></span>,
                  ограниченной двойными кавычками не выполняется
                  интерпретация большинства служебных символов, которые
                  могут находиться в строке. см. <a
                   href="#QUOTING">Глава 5</a>.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">&#39;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#SNGLQUO">Одинарные кавычки</a> .</strong>
                  [Одинарные кавычки] <span
                   class="emphasis"><em
                   class="EMPHASIS">&#39;STRING&#39;</em></span>
                  экранирует все служебные символы в строке <span
                   class="emphasis"><em
                   class="EMPHASIS">STRING</em></span>. Это более
                  строгая форма экранирования. Смотрите так же <a
                   href="#QUOTING">Глава 5</a>.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">,</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#COMMAOP">Запятая</a> .</strong> Оператор
                  <strong
                   class="COMMAND">запятая</strong> используется для
                  вычисления серии арифметических выражений.
                  Вычисляются все выражения, но возвращается результат
                  последнего выражения.</p>
<pre
 class="PROGRAMLISTING">
let &quot;t2 = ((a = 9, 15 / 3))&quot;  # Присваивает значение переменной &quot;a&quot; и вычисляет &quot;t2&quot;.
</pre>
                  <br>
                  <br>
                </div>
              </dd>

              <dt><span
               class="TOKEN">\</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#ESCP">escape</a>.</strong> [обратный слэш]
                  Комбинация <tt
                   class="USERINPUT"><strong>\X</strong></tt> <span
                   class="QUOTE">&quot;экранирует&quot;</span> символ
                  <span
                   class="emphasis"><em
                   class="EMPHASIS">X</em></span>. Аналогичный эффект
                  имеет комбинация с <span
                   class="QUOTE">&quot;одинарными
                  кавычками&quot;</span>, т.е. <span
                   class="emphasis"><em
                   class="EMPHASIS">&#39;X&#39;</em></span>. Символ
                  <span
                   class="TOKEN">\</span> может использоваться для
                  экранирования кавычек <span
                   class="TOKEN">&quot;</span> и <span
                   class="TOKEN">&#39;</span>.</p>
                </div>

                <p>Более детальному рассмотрению темы экранирования
                посвящена <a
                 href="#QUOTING">Глава 5</a>.</p>
              </dd>

              <dt><span
               class="TOKEN">/</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Разделитель, используемый в указании пути
                  к каталогам и файлам.</strong> [слэш] Отделяет
                  элементы пути к каталогам и файлам (например <tt
                   class=
                  "FILENAME">/home/bozo/projects/Makefile</tt>).</p>
                </div>

                <p>В <a
                 href="#AROPS1">арифметических операциях</a> -- это
                оператор деления.</p>
              </dd>

              <dt><span
               class="TOKEN">`</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#COMMANDSUBREF">Подстановка
                  команд</a>.</strong> [обратные кавычки] <a
                   href="#BACKQUOTESREF">Обратные кавычки</a> могут
                  использоваться для записи в переменную команды <span
                   class="emphasis"><em
                   class="EMPHASIS">`command`</em></span>.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">:</span></dt>

              <dd>
                <p><a
                 name="NULLREF"></a></p>

                <div
                 class="FORMALPARA">
                  <p><strong>пустая команда.</strong> [двоеточие] Это
                  эквивалент операции <span
                   class="QUOTE">&quot;NOP&quot;</span> (<tt
                   class="REPLACEABLE"><em>no op</em></tt>, нет
                  операции). Может рассматриваться как синоним
                  встроенной команды <a
                   href="#TRUEREF">true</a>. Команда <span
                   class="QUOTE">&quot;<span
                   class="TOKEN">:</span>&quot;</span> так же является
                  встроенной командой Bash, которая всегда <a
                   href="#EXITSTATUSREF">возвращает</a> <span
                   class="QUOTE">&quot;true&quot;</span> (<span
                   class="RETURNVALUE">0</span>).</p>
                </div>
<pre
 class="PROGRAMLISTING">
:
echo $?   # 0
</pre>
                <br>
                <br>

                <p>Бесконечный цикл:</p>
<pre
 class="PROGRAMLISTING">
while :
do
   operation-1
   operation-2
   ...
   operation-n
done

# То же самое:
#    while true
#    do
#      ...
#    done
</pre>
                <br>
                <br>

                <p>Символ-заполнитель в условном операторе if/then:</p>
<pre
 class="PROGRAMLISTING">
if condition
then :   # Никаких действий не производится и управление передается дальше
else
   take-some-action
fi
</pre>
                <br>
                <br>

                <p>Как символ-заполнитель в операциях, которые
                предполагают наличие двух операндов, см. <a
                 href="#ARITHOPS">Пример 8-2</a> и <a
                 href="#DEFPARAM">параметры по-умолчанию</a>.</p>
<pre
 class="PROGRAMLISTING">
: ${username=`whoami`}
# ${username=`whoami`}   без символа : выдает сообщение об ошибке,
#                        если &quot;username&quot; не является командой...
</pre>
                <br>
                <br>

                <p>Как символ-заполнитель для оператора <a
                 href="#HEREDOCREF">вложенного документа</a>. См. <a
                 href="#ANONHEREDOC">Пример 17-9</a>.</p>

                <p>В операциях с <a
                 href="#PARAMSUBREF">подстановкой параметров</a> (см.
                <a
                 href="#EX6">Пример 9-13</a>).</p>
<pre
 class="PROGRAMLISTING">
: ${HOSTNAME?} ${USER?} ${MAIL?}
#Вывод сообщения об ошибке, если одна или более переменных не определены.
</pre>
                <br>
                <br>

                <p>В операциях <strong
                 class="COMMAND"><a
                 href="#EXPREPL1">замены подстроки с подстановкой
                значений переменных</a></strong>.</p>

                <p>В комбинации с оператором <span
                 class="TOKEN">&gt;</span> (<a
                 href="#IOREDIRREF">оператор перенаправления
                вывода</a>), усекает длину файла до нуля. Если указан
                несуществующий файл -- то он создается.</p>
<pre
 class="PROGRAMLISTING">
: &gt; data.xxx   # Файл &quot;data.xxx&quot; -- пуст

# Тот же эффект имеет команда cat /dev/null &gt;data.xxx
# Однако в данном случае не производится создание нового процесса, поскольку &quot;:&quot; является встроенной командой.
</pre>
                См. так же <a
                 href="#EX12">Пример 12-11</a>.<br>
                <br>

                <p>В комбинации с оператором <span
                 class="TOKEN">&gt;&gt;</span> -- оператор
                перенаправления с добавлением в конец файла и
                обновлением времени последнего доступа (<tt
                 class="USERINPUT"><strong>: &gt;&gt;
                new_file</strong></tt>). Если задано имя
                несуществующего файла, то он создается. Эквивалентно
                команде <a
                 href="#TOUCHREF">touch</a>.</p>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Вышеизложенное применимо только к обычным
                        файлам и неприменимо к конвейерам,
                        символическим ссылкам и другим специальным
                        файлам.</p>
                      </td>
                    </tr>
                  </table>
                </div>

                <p>Символ <span
                 class="TOKEN">:</span> может использоваться для
                создания комментариев, хотя и не рекомендуется. Если
                строка комментария начинается с символа <span
                 class="TOKEN">#</span>, то такая строка не проверяется
                интерпретатором на наличие ошибок. Однако в случае
                оператора <span
                 class="TOKEN">:</span> это не так.</p>
<pre
 class="PROGRAMLISTING">
: Это комментарий, который генерирует сообщение об ошибке, ( if [ $x -eq 3] ).
</pre>
                <br>
                <br>

                <p>Символ <span
                 class="QUOTE">&quot;<span
                 class="TOKEN">:</span>&quot;</span> может
                использоваться как разделитель полей в <tt
                 class="FILENAME">/etc/passwd</tt> и переменной <a
                 href="#PATHREF">$PATH</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $PATH</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</tt>
</pre>
                <br>
                <br>
              </dd>

              <dt><span
               class="TOKEN">!</span></dt>

              <dd>
                <p><a
                 name="NOTREF"></a></p>

                <div
                 class="FORMALPARA">
                  <p><strong>инверсия (или логическое отрицание)
                  используемое в условных операторах.</strong> Оператор
                  <span
                   class="TOKEN">!</span> инвертирует <a
                   href="#EXITSTATUSREF">код завершения</a> команды, к
                  которой он применен. (см. <a
                   href="#NEGCOND">Пример 6-2</a>). Так же используется
                  для логического отрицания в операциях сравнения,
                  например, операция сравнения <span
                   class="QUOTE">&quot;равно&quot;</span> ( <a
                   href="#EQUALSIGNREF">=</a> ), при использовании
                  оператора отрицания, преобразуется в операцию
                  сравнения -- <span
                   class="QUOTE">&quot;не равно&quot;</span> ( != ).
                  Символ <span
                   class="TOKEN">!</span> является зарезервированным
                  ключевым словом BASH.</p>
                </div>

                <p>В некоторых случаях символ <span
                 class="TOKEN">!</span> используется для <a
                 href="#IVR2">косвенного обращения к
                переменным</a>.</p>

                <p>Кроме того, из <span
                 class="emphasis"><em
                 class="EMPHASIS">командной строки</em></span> оператор
                <span
                 class="TOKEN">!</span> запускает <span
                 class="emphasis"><em
                 class="EMPHASIS">механизм историй</em></span> Bash
                (см. <a
                 href="#HISTCOMMANDS">Приложение F</a>). Примечательно,
                что этот механизм недоступен из сценариев (т.е.
                исключительно из командной строки).</p>
              </dd>

              <dt><span
               class="TOKEN">*</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>символ-шаблон.</strong> [звездочка] Символ
                  <span
                   class="TOKEN">*</span> служит <span
                   class="QUOTE">&quot;шаблоном&quot;</span> для <a
                   href="#GLOBBINGREF">подстановки</a> в имена файлов.
                  Одиночный символ <span
                   class="TOKEN">*</span> означает любое имя файла в
                  заданном каталоге.</p>
                </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo *</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">abs-book.sgml add-drive.sh agram.sh alias.sh</tt>
             
</pre>
                <br>
                <br>

                <p>В <a
                 href="#REGEXREF">регулярных выражениях</a> токен <span
                 class="TOKEN">*</span> представляет любое количество
                (в том числе и 0) символов.</p>
              </dd>

              <dt><span
               class="TOKEN">*</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#AROPS1">арифметический оператор</a>.</strong>
                  В арифметических выражениях символ <span
                   class="TOKEN">*</span> обозначает операцию
                  умножения.</p>
                </div>

                <p>Двойная звездочка (два символа звездочки, следующих
                подряд друг за другом -- <span
                 class="TOKEN">**</span>), обозначает операцию <a
                 href="#EXPONENTIATIONREF">возведения в
                степень</a>.</p>
              </dd>

              <dt><span
               class="TOKEN">?</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Оператор проверки условия.</strong> В
                  некоторых выражениях символ <span
                   class="TOKEN">?</span> служит для проверки
                  выполнения условия.</p>
                </div>

                <p>В <a
                 href="#DBLPARENS">конструкциях с двойными
                скобками</a>, символ <span
                 class="TOKEN">?</span> подобен трехместному оператору
                языка C. См. <a
                 href="#CVARS">Пример 9-28</a>.</p>

                <p>В выражениях с <a
                 href="#PARAMSUBREF">подстановкой параметра</a>, символ
                <span
                 class="TOKEN">?</span> <a
                 href="#QERRMSG">проверяет -- установлена ли
                переменная</a>.</p>
              </dd>

              <dt><span
               class="TOKEN">?</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>сивол-шаблон.</strong> Символ <span
                   class="TOKEN">?</span> обозначает одиночный символ
                  при <a
                   href="#GLOBBINGREF">подстановке</a> в имена файлов.
                  В <a
                   href="#EXTREGEX">регулярных выражениях</a> служит
                  для обозначения <a
                   href="#QUEXREGEX">одиночного символа</a>.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">$</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#VARSUBN">Подстановка
                  переменной</a>.</strong></p>
<pre
 class="PROGRAMLISTING">
var1=5
var2=23skidoo

echo $var1     # 5
echo $var2     # 23skidoo
</pre>
                  <br>
                  <br>
                </div>

                <p>Символ <span
                 class="TOKEN">$</span>, предшествующий имени
                переменной, указывает на то, что будет получено <span
                 class="emphasis"><em
                 class="EMPHASIS">значение</em></span> переменной.</p>
              </dd>

              <dt><span
               class="TOKEN">$</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>end-of-line (конец строки).</strong> В <a
                   href="#REGEXREF">регулярных выражениях</a>, символ
                  <span
                   class="QUOTE">&quot;$&quot;</span> обозначает конец
                  строки.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">${}</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#PARAMSUBREF">Подстановка
                  параметра</a>.</strong></p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">$*</span>, <span
               class="TOKEN">$@</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#APPREF">параметры командной
                  строки</a>.</strong></p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">$?</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>код завершения.</strong> <a
                   href="#EXSREF">Переменная $?</a> хранит <a
                   href="#EXITSTATUSREF">код завершения</a> последней
                  выполненной команды, <a
                   href="#FUNCTIONREF">функции</a> или сценария.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">$$</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>id процесса.</strong> <a
                   href="#PROCCID">Переменная $$</a> хранит <span
                   class="emphasis"><em
                   class="EMPHASIS">id процесса</em></span>
                  сценария.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">()</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>группа команд.</strong></p>
<pre
 class="PROGRAMLISTING">
(a=hello; echo $a)
</pre>
                  <br>
                  <br>
                </div>

                <div
                 class="IMPORTANT">
                  <table
                   class="IMPORTANT"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/important.gif"
                       hspace="5"
                       alt="Important"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Команды, заключенные в <tt
                         class="REPLACEABLE"><em>круглые
                        скобки</em></tt> исполняются в дочернем
                        процессе -- <a
                         href="#SUBSHELLSREF">subshell-е</a>.</p>

                        <p>Переменные, создаваемые в дочернем процессе
                        не видны в &quot;родительском&quot; сценарии.
                        Родительский процесс-сценарий, <a
                         href="#PARVIS">не может обращаться к
                        переменным, создаваемым в дочернем
                        процессе</a>.</p>
<pre
 class="PROGRAMLISTING">
a=123
( a=321; )

echo &quot;a = $a&quot;   # a = 123
# переменная &quot;a&quot; в скобках подобна локальной переменной.
</pre>
                        <br>
                        <br>
                      </td>
                    </tr>
                  </table>
                </div>

                <div
                 class="FORMALPARA">
                  <p><strong>инициализация массивов.</strong></p>
<pre
 class="PROGRAMLISTING">
Array=(element1 element2 element3)
</pre>
                  <br>
                  <br>
                </div>
              </dd>

              <dt><span
               class="TOKEN">{xxx,yyy,zzz,...}</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Фигурные скобки.</strong></p>
<pre
 class="PROGRAMLISTING">
grep Linux file*.{txt,htm*}
# Поиск всех вхождений слова &quot;Linux&quot;
# в файлах &quot;fileA.txt&quot;, &quot;file2.txt&quot;, &quot;fileR.html&quot;, &quot;file-87.htm&quot;, и пр.
</pre>
                  <br>
                  <br>
                </div>

                <p>Команда интерпретируется как список команд,
                разделенных точкой с запятой, с вариациями,
                представленными в <tt
                 class="REPLACEABLE"><em>фигурных скобках</em></tt>. <a
                 name="AEN901"
                 href="#FTN.AEN901"><span
                 class="footnote">[11]</span></a> При интерпретации
                имен файлов (<a
                 href="#GLOBBINGREF">подстановка</a>) используются
                параметры, заключенные в фигурные скобки.</p>

                <div
                 class="CAUTION">
                  <table
                   class="CAUTION"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/caution.gif"
                       hspace="5"
                       alt="Caution"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Использование <span
                         class="emphasis"><em
                         class="EMPHASIS">неэкранированных или
                        неокавыченных</em></span> пробелов внутри
                        фигурных скобок недопустимо.</p>

                        <p><tt
                         class="USERINPUT"><strong>echo {file1,file2}\
                        :{\ A,&quot; B&quot;,&#39;
                        C&#39;}</strong></tt></p>

                        <p><tt
                         class="COMPUTEROUTPUT">file1 : A file1 : B
                        file1 : C file2 : A file2 : B file2 :
                        C</tt></p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><span
               class="TOKEN">{}</span></dt>

              <dd>
                <p><a
                 name="CODEBLOCKREF"></a></p>

                <div
                 class="FORMALPARA">
                  <p><strong>Блок кода.</strong> [фигурные скобки]
                  Известен так же как <span
                   class="QUOTE">&quot;вложенный блок&quot;</span>, эта
                  конструкция, фактически, создает анонимную функцию.
                  Однако, в отличии от обычных <a
                   href="#FUNCTIONREF">функций</a>, переменные,
                  создаваемые во вложенных блоках кода, доступны
                  объемлющему сценарию.</p>
                </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>{ local a; a=123; }</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">bash: local: can only be used in a function</tt>
             
</pre>
                <br>
                <br>
<pre
 class="PROGRAMLISTING">
a=123
{ a=321; }
echo &quot;a = $a&quot;   # a = 321   (значение, присвоенное во вложенном блоке кода)

# Спасибо, S.C.
</pre>
                <br>
                <br>

                <p>Код, заключенный в фигурные скобки, может выполнять
                <a
                 href="#IOREDIRREF">перенаправление
                ввода-вывода</a>.</p>

                <div
                 class="EXAMPLE">
                  <a
                   name="EX8"></a>

                  <p><strong>Пример 3-1. Вложенные блоки и
                  перенаправление ввода-вывода</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Чтение строк из файла /etc/fstab.

File=/etc/fstab

{
read line1
read line2
} &lt; $File

echo &quot;Первая строка в $File :&quot;
echo &quot;$line1&quot;
echo
echo &quot;Вторая строка в $File :&quot;
echo &quot;$line2&quot;

exit 0
</pre>
                </div>

                <div
                 class="EXAMPLE">
                  <a
                   name="RPMCHECK"></a>

                  <p><strong>Пример 3-2. Сохранение результата
                  исполнения вложенного блока в файл</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# rpm-check.sh

# Запрашивает описание rpm-архива, список файлов, и проверяется возможность установки.
# Результат сохраняется в файле.
#
# Этот сценарий иллюстрирует порядок работы со вложенными блоками кода.

SUCCESS=0
E_NOARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` rpm-file&quot;
  exit $E_NOARGS
fi

{
  echo
  echo &quot;Описание архива:&quot;
  rpm -qpi $1       # Запрос описания.
  echo
  echo &quot;Список файлов:&quot;
  rpm -qpl $1       # Запрос списка.
  echo
  rpm -i --test $1  # Проверка возможности установки.
  if [ &quot;$?&quot; -eq $SUCCESS ]
  then
    echo &quot;$1 может быть установлен.&quot;
  else
    echo &quot;$1 -- установка невозможна!&quot;
  fi
  echo
} &gt; &quot;$1.test&quot;       # Перенаправление вывода в файл.

echo &quot;Результаты проверки rpm-архива находятся в файле $1.test&quot;

# За дополнительной информацией по ключам команды rpm см. man rpm.

exit 0
</pre>
                </div>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>В отличие от групп команд в (круглых
                        скобках), описаных выше, вложенные блоки кода,
                        заключенные в {фигурные скобки} исполняются в
                        пределах того же процесса, что и сам скрипт
                        (т.е. не вызывают запуск дочернего процесса --
                        <a
                         href="#SUBSHELLSREF">subshell</a>). <a
                         name="AEN947"
                         href="#FTN.AEN947"><span
                         class="footnote">[12]</span></a></p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><span
               class="TOKEN">{} \;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>pathname -- полное имя файла (т.е. путь к
                  файлу и его имя).</strong> Чаще всего используется
                  совместно с командой <a
                   href="#FINDREF">find</a>.</p>
                </div>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Обратите внимание на то, что символ <span
                         class="QUOTE">&quot;<span
                         class="TOKEN">;</span>&quot;</span>, которым
                        завершается ключ <tt
                         class="OPTION">-exec</tt> команды <strong
                         class="COMMAND">find</strong>, экранируется
                        обратным слэшем. Это необходимо, чтобы
                        предотвратить его интерпретацию.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><span
               class="TOKEN">[ ]</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>test.</strong></p>
                </div>

                <p><a
                 name="LEFTBRACKET"></a><a
                 href="#IFTHEN">Проверка истинности</a> выражения,
                заключенного в квадратные скобки <strong
                 class="COMMAND">[ ]</strong>. Примечательно, что
                <strong
                 class="COMMAND">[</strong> является частью встроенной
                команды <strong
                 class="COMMAND">test</strong> (и ее синонимом), И
                <span
                 class="emphasis"><em
                 class="EMPHASIS">не</em></span> имеет никакого
                отношения к &quot;внешней&quot; утилите <tt
                 class="FILENAME">/usr/bin/test</tt>.</p>
              </dd>

              <dt><span
               class="TOKEN">[[ ]]</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>test.</strong></p>
                </div>

                <p>Проверка истинности выражения, заключенного между
                <span
                 class="TOKEN">[[ ]]</span> (<a
                 href="#KEYWORDREF">зарезервированное слово</a>
                интерпретатора).</p>

                <p>См. описание конструкции <a
                 href="#DBLBRACKETS">[[ ... ]]</a> ниже.</p>
              </dd>

              <dt><span
               class="TOKEN">[ ]</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>элемент массива.</strong></p>
                </div>

                <p>При работе с <a
                 href="#ARRAYREF">массивами</a> в квадратных скобках
                указывается порядковый номер того элемента массива, к
                которому производится обращение.</p>
<pre
 class="PROGRAMLISTING">
Array[1]=slot_1
echo ${Array[1]}
</pre>
                <br>
                <br>
              </dd>

              <dt><span
               class="TOKEN">[ ]</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>диапазон символов.</strong></p>
                </div>

                <p>В <a
                 href="#REGEXREF">регулярных выражениях</a>, в
                квадратных скобках задается <a
                 href="#BRACKETSREF">диапазон искомых символов</a>.</p>
              </dd>

              <dt><span
               class="TOKEN">(( ))</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>двойные круглые скобки.</strong></p>
                </div>

                <p>Вычисляется целочисленное выражение, заключенное
                между двойными круглыми скобками <span
                 class="TOKEN">(( ))</span>.</p>

                <p>См. обсуждение, посвященное <a
                 href="#DBLPARENS">конструкции (( ... ))</a> .</p>
              </dd>

              <dt><span
               class="TOKEN">&gt;</span> <span
               class="TOKEN">&amp;&gt;</span> <span
               class="TOKEN">&gt;&amp;</span> <span
               class="TOKEN">&gt;&gt;</span> <span
               class="TOKEN">&lt;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#IOREDIRREF">перенаправление</a>.</strong></p>
                </div>

                <p>Конструкция <tt
                 class="USERINPUT"><strong>scriptname
                &gt;filename</strong></tt> перенаправляет вывод <tt
                 class="FILENAME">scriptname</tt> в файл <tt
                 class="FILENAME">filename</tt>. Если файл <tt
                 class="FILENAME">filename</tt> уже существовал, то его
                прежнее содержимое будет утеряно.</p>

                <p>Конструкция <tt
                 class="USERINPUT"><strong>command
                &amp;&gt;filename</strong></tt> перенаправляет вывод
                команды <tt
                 class="FILENAME">command</tt>, как со <tt
                 class="FILENAME">stdout</tt>, так и с <tt
                 class="FILENAME">stderr</tt>, в файл <tt
                 class="FILENAME">filename</tt>.</p>

                <p>Конструкция <tt
                 class="USERINPUT"><strong>command
                &gt;&amp;2</strong></tt> перенаправляет вывод со <tt
                 class="FILENAME">stdout</tt> на <tt
                 class="FILENAME">stderr</tt>.</p>

                <p>Конструкция <tt
                 class="USERINPUT"><strong>scriptname
                &gt;&gt;filename</strong></tt> добавляет вывод <tt
                 class="FILENAME">scriptname</tt> к файлу <tt
                 class="FILENAME">filename</tt>. Если задано имя
                несуществующего файла, то он создается.</p>

                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#PROCESSSUBREF">подстановка
                  процесса</a>.</strong></p>
                </div>

                <p><tt
                 class=
                "USERINPUT"><strong>(command)&gt;</strong></tt></p>

                <p><tt
                 class=
                "USERINPUT"><strong>&lt;(command)</strong></tt></p>

                <p>В <a
                 href="#LTREF">операциях сравнения</a>, символы <span
                 class="QUOTE">&quot;<span
                 class="TOKEN">&lt;</span>&quot;</span> и <span
                 class="QUOTE">&quot;<span
                 class="TOKEN">&gt;</span>&quot;</span> обозначают
                операции <a
                 href="#SCOMPARISON1">сравнения строк</a> .</p>

                <p><a
                 href="#INTLT">А так же</a> -- операции <a
                 href="#ICOMPARISON1">сравнения целых чисел</a>. См.
                так же <a
                 href="#EX45">Пример 12-6</a>.</p>
              </dd>

              <dt><span
               class="TOKEN">&lt;&lt;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>перенаправление ввода на <a
                   href="#HEREDOCREF">встроенный
                  документ</a>.</strong></p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">&lt;</span>, <span
               class="TOKEN">&gt;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#LTREF">Посимвольное
                  ASCII-сравнение</a>.</strong></p>
<pre
 class="PROGRAMLISTING">
veg1=carrots
veg2=tomatoes

if [[ &quot;$veg1&quot; &lt; &quot;$veg2&quot; ]]
then
  echo &quot;Не смотря на то, что в словаре слово $veg1 предшествует слову $veg2,&quot;
  echo &quot;это никак не отражает мои кулинарные предпочтения.&quot;
else
  echo &quot;Интересно. Каким словарем вы пользуетесь?&quot;
fi
</pre>
                  <br>
                  <br>
                </div>
              </dd>

              <dt><span
               class="TOKEN">\&lt;</span>, <span
               class="TOKEN">\&gt;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#ANGLEBRAC">границы отдельных слов</a> в <a
                   href="#REGEXREF">регулярных
                  выражениях</a>.</strong></p>
                </div>

                <p><tt
                 class="PROMPT">bash$</tt> <tt
                 class="USERINPUT"><strong>grep &#39;\&lt;the\&gt;&#39;
                textfile</strong></tt></p>
              </dd>

              <dt><span
               class="TOKEN">|</span></dt>

              <dd>
                <p><a
                 name="PIPEREF"></a></p>

                <div
                 class="FORMALPARA">
                  <p><strong>конвейер.</strong> Передает вывод
                  предыдущей команды на ввод следующей или на вход
                  командного интерпретатора shell. Этот метод часто
                  используется для связывания последовательности команд
                  в единую цепочку.</p>
                </div>
<pre
 class="PROGRAMLISTING">
echo ls -l | sh
#  Передает вывод &quot;echo ls -l&quot; команлному интерпретатору shell,
#+ тот же результат дает простая команда &quot;ls -l&quot;.


cat *.lst | sort | uniq
# Объединяет все файлы &quot;.lst&quot;, сортирует содержимое и удаляет повторяющиеся строки.
</pre>
                <br>
                <br>

                <table
                 class="SIDEBAR"
                 border="1"
                 cellpadding="5">
                  <tr>
                    <td>
                      <div
                       class="SIDEBAR">
                        <a
                         name="AEN1202"></a>

                        <p>Конвейеры (еще их называют каналами) -- это
                        классический способ взаимодействия процессов, с
                        помощью которого <tt
                         class="FILENAME">stdout</tt> одного процесса
                        перенаправляется на <tt
                         class="FILENAME">stdin</tt> другого. Обычно
                        используется совместно с командами вывода,
                        такими как <a
                         href="#CATREF">cat</a> или <a
                         href="#ECHOREF">echo</a>, от которых поток
                        данных поступает в <span
                         class="QUOTE">&quot;фильтр&quot;</span>
                        (команда, которая на входе получает данные,
                        преобразует их и обрабатывает).</p>

                        <p><tt
                         class="USERINPUT"><strong>cat $filename | grep
                        $search_word</strong></tt></p>
                      </div>
                    </td>
                  </tr>
                </table>

                <p><a
                 name="UCREF"></a>В конвейер могут объединяться и
                сценарии на языке командной оболочки.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# uppercase.sh : Преобразование вводимых символов в верхний регистр.

tr &#39;a-z&#39; &#39;A-Z&#39;
#  Диапазоны символов должны быть заключены в кавычки
#+ чтобы предотвратить порождение имен файлов от однобуквенных имен файлов.

exit 0
</pre>
                А теперь попробуем объединить в конвейер команду
                <strong
                 class="COMMAND">ls -l</strong> с этим сценарием. 
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l | ./uppercase.sh</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
 -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
 -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE</tt>
             
</pre>
                <br>
                <br>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Выход <tt
                         class="FILENAME">stdout</tt> каждого процесса
                        в конвейере должен читаться на входе <tt
                         class="FILENAME">stdin</tt> последующим, в
                        конвейере, процессом. Если этого не делается,
                        то поток данных <span
                         class="emphasis"><em
                         class="EMPHASIS">блокируется</em></span>, в
                        результате конвейер будет работать не так как
                        ожидается.</p>
<pre
 class="PROGRAMLISTING">
cat file1 file2 | ls -l | sort
# Вывод команды &quot;cat file1 file2&quot; будет утерян.
</pre>
                        <br>
                        <br>

                        <p>Конвейер исполняется в <a
                         href="#CHILDREF">дочернем процессе</a>, а
                        посему -- не имеет доступа к переменным
                        сценария.</p>
<pre
 class="PROGRAMLISTING">
variable=&quot;initial_value&quot;
echo &quot;new_value&quot; | read variable
echo &quot;variable = $variable&quot;     # variable = initial_value
</pre>
                        <br>
                        <br>

                        <p>Если одна из команд в конвейере завершается
                        аварийно, то это приводит к аварийному
                        завершению работы всего конвейера.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><span
               class="TOKEN">&gt;|</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>принудительное перенаправление, даже если
                  установлен ключ <a
                   href="#NOCLOBBERREF">noclobber
                  option</a>.</strong></p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">||</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#ORREF">логическая операция OR (логическое
                  ИЛИ)</a>.</strong> В <a
                   href="#TESTCONSTRUCTS1">опрециях проверки
                  условий</a>, оператор <span
                   class="TOKEN">||</span> возвращает <span
                   class="RETURNVALUE">0</span> (success), если один из
                  операндов имеет значение true (ИСТИНА).</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">&amp;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Выполнение задачи в фоне.</strong>
                  Команда, за которой стоит <span
                   class="TOKEN">&amp;</span>, будет исполняться в
                  фоновом режиме.</p>
                </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>sleep 10 &amp;</strong></tt>
<tt
 class="COMPUTEROUTPUT">[1] 850</tt>
<tt
 class="COMPUTEROUTPUT">[1]+  Done                    sleep 10</tt>
             
</pre>
                <br>
                <br>

                <p>В сценариях команды, и даже <a
                 href="#FORLOOPREF1">циклы</a> могут запускаться в
                фоновом режиме.</p>

                <div
                 class="EXAMPLE">
                  <a
                   name="BGLOOP"></a>

                  <p><strong>Пример 3-3. Запуск цикла в фоновом
                  режиме</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# background-loop.sh

for i in 1 2 3 4 5 6 7 8 9 10            # Первый цикл.
do
  echo -n &quot;$i &quot;
done &amp; # Запуск цикла в фоне.
       # Иногда возможны случаи выполнения этого цикла после второго цикла.

echo   # Этот &#39;echo&#39; иногда не отображается на экране.

for i in 11 12 13 14 15 16 17 18 19 20   # Второй цикл.
do
  echo -n &quot;$i &quot;
done

echo   # Этот &#39;echo&#39; иногда не отображается на экране.

# ======================================================

# Ожидается, что данный сценарий выведет следующую последовательность:
# 1 2 3 4 5 6 7 8 9 10
# 11 12 13 14 15 16 17 18 19 20

# Иногда возможен такой вариант:
# 11 12 13 14 15 16 17 18 19 20
# 1 2 3 4 5 6 7 8 9 10 bozo $
# (Второй &#39;echo&#39; не был выполнен. Почему?)

# Изредка возможен такой вариант:
# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
# (Первый &#39;echo&#39; не был выполнен. Почему?)

# Крайне редко встречается и такое:
# 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20
# Второй цикл начал исполняться раньше первого.

exit 0
</pre>
                </div>

                <div
                 class="CAUTION">
                  <table
                   class="CAUTION"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/caution.gif"
                       hspace="5"
                       alt="Caution"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Команда, исполняемая в пределах сценария в
                        фоне, может подвесить сценарий, ожидая нажатия
                        клавиши. К счастью, это легко <a
                         href="#WAITHANG">&quot;лечится&quot;</a>.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><span
               class="TOKEN">&amp;&amp;</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#LOGOPS1">Логическая операция AND (логическое
                  И)</a>.</strong> В <a
                   href="#TESTCONSTRUCTS1">операциях проверки
                  условий</a>, оператор <span
                   class="TOKEN">&amp;&amp;</span> возвращает <span
                   class="RETURNVALUE">0</span> (success) тогда, и
                  только тогда, когда <span
                   class="emphasis"><em
                   class="EMPHASIS">оба</em></span> операнда имеют
                  значение true (ИСТИНА).</p>
                </div>
              </dd>

              <dt><a
               name="DASHREF"></a><span
               class="TOKEN">-</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>префикс ключа.</strong> С этого символа
                  начинаются опциональные ключи команд.</p>
                </div>

                <p><tt
                 class="USERINPUT"><strong>COMMAND
                -[Option1][Option2][...]</strong></tt></p>

                <p><tt
                 class="USERINPUT"><strong>ls -al</strong></tt></p>

                <p><tt
                 class="USERINPUT"><strong>sort -dfu
                $filename</strong></tt></p>

                <p><tt
                 class="USERINPUT"><strong>set --
                $variable</strong></tt></p>
<pre
 class="PROGRAMLISTING">
if [ $file1 -ot $file2 ]
then
  echo &quot;Файл $file1 был создан раньше чем $file2.&quot;
fi

if [ &quot;$a&quot; -eq &quot;$b&quot; ]
then
  echo &quot;$a равно $b.&quot;
fi

if [ &quot;$c&quot; -eq 24 -a &quot;$d&quot; -eq 47 ]
then
  echo &quot;$c равно 24, а $d равно 47.&quot;
fi
</pre>
                <br>
                <br>
              </dd>

              <dt><span
               class="TOKEN">-</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>перенаправление из/в <tt
                   class="FILENAME">stdin</tt> или <tt
                   class="FILENAME">stdout</tt>.</strong> <a
                   name="COXEX"></a>[дефис]</p>
                </div>
<pre
 class="PROGRAMLISTING">
(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)
# Перемещение полного дерева файлов и подкаталогов из одной директории в другую
# [спасибо Алану Коксу (Alan Cox) &lt;a.cox@swansea.ac.uk&gt;, за небольшие поправки]

# 1) cd /source/directory    Переход в исходный каталог, содержимое которого будет перемещено
# 2) &amp;&amp;                     &quot;И-список&quot;: благодаря этому все последующие команды будут выполнены
#                            только тогда, когда &#39;cd&#39; завершится успешно
# 3) tar cf - .              ключом &#39;c&#39; архиватор &#39;tar&#39; создает новый архив,
#                            ключом &#39;f&#39; (file) и последующим &#39;-&#39; задается файл архива -- stdout,
#                            в архив помещается текущий каталог (&#39;.&#39;) с вложенными подкаталогами.
# 4) |                       конвейер с ...
# 5) ( ... )                 subshell-ом (дочерним экземпляром командной оболочки)
# 6) cd /dest/directory      Переход в каталог назначения.
# 7) &amp;&amp;                     &quot;И-список&quot;, см. выше
# 8) tar xpvf -              Разархивирование (&#39;x&#39;), с сохранением атрибутов &quot;владельца&quot; и прав доступа (&#39;p&#39;) к файлам,
#                            с выдачей более подробных сообщений на stdout (&#39;v&#39;),
#                            файл архива -- stdin (&#39;f&#39; с последующим &#39;-&#39;).
#
#                            Примечательно, что &#39;x&#39; -- это команда, а &#39;p&#39;, &#39;v&#39; и &#39;f&#39; -- ключи
# Во как!



# Более элегантный вариант:
#   cd source-directory
#   tar cf - . | (cd ../target-directory; tar xzf -)
#
# cp -a /source/directory /dest     имеет тот же эффект.
</pre>
                <br>
                <br>
<pre
 class="PROGRAMLISTING">
bunzip2 linux-2.4.3.tar.bz2 | tar xvf -
# --разархивирование tar-файла--    | --затем файл передается утилите &quot;tar&quot;--
# Если у вас утилита &quot;tar&quot; не поддерживает работу с &quot;bunzip2&quot;,
# тогда придется выполнять работу в два этапа, с использованием конвейера.
# Целью данного примера является разархивирование тарбола (tar.bz2) с исходными текстами ядра.
</pre>
                <br>
                <br>

                <p>Обратите внимание, что в этом контексте <span
                 class="QUOTE">&quot;-&quot;</span> - не
                самостоятельный оператор Bash, а скорее опция,
                распознаваемая некоторыми утилитами UNIX (такими как
                <strong
                 class="COMMAND">tar</strong>, <strong
                 class="COMMAND">cat</strong> и т.п.), которые выводят
                результаты своей работы в <tt
                 class="FILENAME">stdout</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;whatever&quot; | cat -</strong></tt>
<tt
 class="COMPUTEROUTPUT">whatever</tt>
</pre>
                <br>
                <br>

                <p>В случае, когда ожидается имя файла, тогда <span
                 class="QUOTE">&quot;-&quot;</span> перенаправляет
                вывод на <tt
                 class="FILENAME">stdout</tt> (вспомните пример с <tt
                 class="USERINPUT"><strong>tar cf</strong></tt>) или
                принимает ввод с <tt
                 class="FILENAME">stdin</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>file</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...</tt>
             
</pre>
                Сама по себе команда <a
                 href="#FILEREF">file</a> без параметров завершается с
                сообщением об ошибке. <br>
                <br>

                <p>Добавим символ <span
                 class="QUOTE">&quot;-&quot;</span> и получим более
                полезный результат. Это заставит командный
                интерпретатор ожидать ввода от пользователя.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>file -</strong></tt>
<tt
 class="USERINPUT"><strong>abc</strong></tt>
<tt
 class="COMPUTEROUTPUT">standard input:              ASCII text</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>file -</strong></tt>
<tt
 class="USERINPUT"><strong>#!/bin/bash</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">standard input:              Bourne-Again shell script text executable</tt>
             
</pre>
                Теперь команда принимает ввод пользователя со <tt
                 class="FILENAME">stdin</tt> и анализирует его. <br>
                <br>

                <p>Используя передачу <tt
                 class="FILENAME">stdout</tt> по конвейеру другим
                командам, можно выполнять довольно эффектные трюки,
                например <a
                 href="#PREPENDREF">вставка строк в начало
                файла</a>.</p>

                <p>С помощью команды <a
                 href="#DIFFREF">diff</a> -- находить различия между
                одним файлом и <span
                 class="emphasis"><em
                 class="EMPHASIS">частью</em></span> другого:</p>

                <p><tt
                 class="USERINPUT"><strong>grep Linux file1 | diff
                file2 -</strong></tt></p>

                <p>И наконец пример использования служебного символа
                <tt
                 class="REPLACEABLE"><em>&quot;-&quot;</em></tt> с
                командой <a
                 href="#TARREF">tar</a>.</p>

                <div
                 class="EXAMPLE">
                  <a
                   name="EX58"></a>

                  <p><strong>Пример 3-4. Резервное архивирование всех
                  файлов, которые были изменены в течение последних
                  суток</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Резервное архивирование (backup) всех файлов в текущем каталоге,
# которые были изменены в течение последних 24 часов
#+ в тарболл (tarball) (.tar.gz - файл).

BACKUPFILE=backup
archive=${1:-$BACKUPFILE}
#  На случай, если имя архива в командной строке не задано,
#+ т.е. по-умолчанию имя архива -- &quot;backup.tar.gz&quot;

tar cvf - `find . -mtime -1 -type f -print` &gt; $archive.tar
gzip $archive.tar
echo &quot;Каталог $PWD заархивирован в файл \&quot;$archive.tar.gz\&quot;.&quot;


#  Stephane Chazelas заметил, что вышеприведенный код будет &quot;падать&quot;
#+ если будет найдено слишком много файлов
#+ или если имена файлов будут содержать символы пробела.

# Им предложен альтернативный код:
# -------------------------------------------------------------------
#   find . -mtime -1 -type f -print0 | xargs -0 tar rvf &quot;$archive.tar&quot;
#      используется версия GNU утилиты &quot;find&quot;.


#   find . -mtime -1 -type f -exec tar rvf &quot;$archive.tar&quot; &#39;{}&#39; \;
#         более универсальный вариант, хотя и более медленный,
#         зато может использоваться в других версиях UNIX.
# -------------------------------------------------------------------


exit 0
</pre>
                </div>

                <div
                 class="CAUTION">
                  <table
                   class="CAUTION"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/caution.gif"
                       hspace="5"
                       alt="Caution"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Могут возникнуть конфликтные ситуации между
                        опреатором перенаправления <span
                         class="QUOTE">&quot;-&quot;</span> и именами
                        файлов, начинающимися с символа <span
                         class="QUOTE">&quot;-&quot;</span>. Поэтому
                        сценарий должен проверять имена файлов и
                        предаварять их префиксом пути, например, <tt
                         class="FILENAME">./-FILENAME</tt>, <tt
                         class="FILENAME">$PWD/-FILENAME</tt> или <tt
                         class="FILENAME">$PATHNAME/-FILENAME</tt>.</p>

                        <p>Если значение переменной начинается с
                        символа <span
                         class="QUOTE">&quot;-&quot;</span>, то это
                        тоже может быть причиной появления ошибок.</p>
<pre
 class="PROGRAMLISTING">
var=&quot;-n&quot;
echo $var
# В данном случае команда приобретет вид &quot;echo -n&quot; и ничего не выведет.
</pre>
                        <br>
                        <br>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><span
               class="TOKEN">-</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>предыдущий рабочий каталог.</strong>
                  [дефис] Команда <strong
                   class="COMMAND">cd -</strong> выполнит переход в
                  предыдущий рабочий каталог, путь к которому хранится
                  в <a
                   href="#ENVREF">переменной окружения</a> <a
                   href="#OLDPWD">$OLDPWD</a> .</p>
                </div>

                <div
                 class="CAUTION">
                  <table
                   class="CAUTION"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/caution.gif"
                       hspace="5"
                       alt="Caution"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Не путайте оператор <span
                         class="QUOTE">&quot;-&quot;</span>
                        (предыдущего рабочего каталога) с оператором
                        <span
                         class="QUOTE">&quot;-&quot;</span>
                        (переназначения). Еще раз напомню, что
                        интерпретация символа <span
                         class="QUOTE">&quot;-&quot;</span> зависит от
                        контекста, в котором он употребляется.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><span
               class="TOKEN">-</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Минус.</strong> Знак минус в <a
                   href="#AROPS1">арифметических операциях</a>.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">=</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Символ &quot;равно&quot;.</strong> <a
                   href="#EQREF">Оператор присваивания</a></p>
<pre
 class="PROGRAMLISTING">
a=28
echo $a   # 28
</pre>
                  <br>
                  <br>
                </div>

                <p>В зависимости от <a
                 href="#EQUALSIGNREF">контекста применения</a>, символ
                <span
                 class="QUOTE">&quot;<span
                 class="TOKEN">=</span>&quot;</span> может выступать в
                качестве оператора <a
                 href="#SCOMPARISON1">сравнения</a>.</p>
              </dd>

              <dt><span
               class="TOKEN">+</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Плюс.</strong> Оператор сложения в <a
                   href="#AROPS1">арифметических операциях</a>.</p>
                </div>

                <p>В зависимости от <a
                 href="#PLUSREF">контекста применения</a>, символ <span
                 class="TOKEN">+</span> может выступать как оператор <a
                 href="#REGEXP">регулярного выражения</a>.</p>
              </dd>

              <dt><span
               class="TOKEN">+</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>Ключ (опция).</strong> Дополнительный флаг
                  для ключей (опций) команд.</p>
                </div>

                <p>Отдельные внешние и <a
                 href="#BUILTINREF">встроенные</a> команды используют
                символ <span
                 class="QUOTE">&quot;<span
                 class="TOKEN">+</span>&quot;</span> для разрешения
                некоторой опции, а символ <span
                 class="QUOTE">&quot;<span
                 class="TOKEN">-</span>&quot;</span> -- для
                запрещения.</p>
              </dd>

              <dt><span
               class="TOKEN">%</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   href="#MODULOREF">модуль</a>.</strong> Модуль
                  (остаток от деления) -- <a
                   href="#AROPS1">арифметическая операция</a>.</p>
                </div>

                <p>В зависимости от <a
                 href="#PCTPATREF">контекста применения</a>, символ
                <span
                 class="TOKEN">%</span> может выступать в качестве <a
                 href="#PSUB2">шаблона</a>.</p>
              </dd>

              <dt><span
               class="TOKEN">~</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>домашний каталог.</strong> [тильда]
                  Соответствует содержимому внутренней переменной <a
                   href="#HOMEDIRREF">$HOME</a>. <span
                   class="emphasis"><em
                   class="EMPHASIS">~bozo</em></span> -- домашний
                  каталог пользователя bozo, а команда <strong
                   class="COMMAND">ls ~bozo</strong> выведет содержимое
                  его домашнего каталога. <span
                   class="TOKEN">~/</span> -- это домашний каталог
                  текущего пользователя, а команда <strong
                   class="COMMAND">ls ~/</strong> выведет содержимое
                  домашнего каталога текущего пользователя.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ~bozo</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ~</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ~/</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo/</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ~:</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo:</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ~nonexistent-user</strong></tt>
<tt
 class="COMPUTEROUTPUT">~nonexistent-user</tt>
             
</pre>
                  <br>
                  <br>
                </div>
              </dd>

              <dt><span
               class="TOKEN">~+</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>текущий рабочий каталог.</strong>
                  Соответствует содержимому внутренней переменной <a
                   href="#PWDREF">$PWD</a>.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">~-</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>предыдущий рабочий каталог.</strong>
                  Соответствует содержимому внутренней переменной <a
                   href="#OLDPWD">$OLDPWD</a>.</p>
                </div>
              </dd>

              <dt><span
               class="TOKEN">^</span></dt>

              <dd>
                <div
                 class="FORMALPARA">
                  <p><strong>начало-строки.</strong> В <a
                   href="#REGEXREF">регулярных выражениях</a> символ
                  <span
                   class="QUOTE">&quot;^&quot;</span> задает начало
                  строки текста.</p>
                </div>
              </dd>

              <dt>Управляющий символ</dt>

              <dd>
                <p><a
                 name="CONTROLCHARREF"></a></p>

                <div
                 class="FORMALPARA">
                  <p><strong>изменяет поведение терминала или управляет
                  выводом текста.</strong> Управляющий символ
                  набирается с клавиатуры как комбинация <strong
                   class="KEYCAP">CONTROL</strong> + <strong
                   class="KEYCAP">&lt;клавиша&gt;</strong>.</p>
                </div>

                <ul>
                  <li>
                    <p><tt
                     class="USERINPUT"><strong>Ctl-C</strong></tt></p>

                    <p>Завершение выполнения процесса.</p>
                  </li>

                  <li>
                    <p><a
                     name="CTLDREF"></a></p>

                    <p><tt
                     class="USERINPUT"><strong>Ctl-D</strong></tt></p>

                    <p>Выход из командного интерпретатора (log out)
                    (аналог команды <a
                     href="#EXITCOMMANDREF">exit</a>).</p>

                    <p><span
                     class="QUOTE">&quot;EOF&quot;</span> (признак
                    конца файла). Этот символ может выступать в
                    качестве завершающего при вводе с <tt
                     class="FILENAME">stdin</tt>.</p>
                  </li>

                  <li>
                    <p><tt
                     class="USERINPUT"><strong>Ctl-G</strong></tt></p>

                    <p><span
                     class="QUOTE">&quot;BEL&quot;</span> (звуковой
                    сигнал -- &quot;звонок&quot;).</p>
                  </li>

                  <li>
                    <p><tt
                     class="USERINPUT"><strong>Ctl-H</strong></tt></p>

                    <p>Backspace -- удаление предыдущего символа.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вставка символа Ctl-H в строку.

a=&quot;^H^H&quot;                  # Два символа Ctl-H (backspace).
echo &quot;abcdef&quot;             # abcdef
echo -n &quot;abcdef$a &quot;       # abcd f
# Пробел в конце ^              ^ двойной шаг назад.
echo -n &quot;abcdef$a&quot;        # abcdef
# Пробела в конце нет             backspace не работает (почему?).
# Результаты могут получиться совсем не те, что вы ожидаете.
echo; echo
</pre>
                    <br>
                    <br>
                  </li>

                  <li>
                    <p><tt
                     class="USERINPUT"><strong>Ctl-J</strong></tt></p>

                    <p>Возврат каретки.</p>
                  </li>

                  <li>
                    <p><tt
                     class="USERINPUT"><strong>Ctl-L</strong></tt></p>

                    <p>Перевод формата (очистка экрана (окна)
                    терминала). Аналогична команде <a
                     href="#CLEARREF">clear</a>.</p>
                  </li>

                  <li>
                    <p><tt
                     class="USERINPUT"><strong>Ctl-M</strong></tt></p>

                    <p>Перевод строки.</p>
                  </li>

                  <li>
                    <p><tt
                     class="USERINPUT"><strong>Ctl-U</strong></tt></p>

                    <p>Стирание строки ввода.</p>
                  </li>

                  <li>
                    <p><tt
                     class="USERINPUT"><strong>Ctl-Z</strong></tt></p>

                    <p>Приостановка процесса.</p>
                  </li>
                </ul>
              </dd>

              <dt>Пробельный символ</dt>

              <dd>
                <p><a
                 name="WHITESPACEREF"></a></p>

                <div
                 class="FORMALPARA">
                  <p><strong>используется как разделитель команд или
                  переменных.</strong> В качестве пробельного символа
                  могут выступать -- собственно пробел (space), символ
                  табуляции, символ перевода строки, символ возврата
                  каретки или комбинация из вышеперечисленных символов.
                  В некоторых случаях, таких как <a
                   href="#WSBAD">присваивание значений переменным</a>,
                  использование пробельных символов недопустимо.</p>
                </div>

                <p>Пустые строки никак не обрабатываются командным
                интерпретатором и могут свободно использоваться для
                визуального выделения отдельных блоков сценария.</p>

                <p><a
                 href="#IFSREF">$IFS</a> -- переменная специального
                назначения. Содержит символы-разделители полей,
                используемые некоторыми командами. По-умолчанию --
                пробельные символы.</p>
              </dd>
            </dl>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="VARIABLES"></a>Глава 4. Переменные и параметры.
          Введение.</h1>

          <p>Переменные -- это одна из основ любого языка
          программирования. Они учавствуют в арифметических операциях,
          в синтаксическом анализе строк и совершенно необходимы для
          абстрагирования каких либо величин с помощью символических
          имен. Физически переменные представляют собой ни что иное как
          участки памяти, в которые записана некоторая информация.</p>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="VARSUBN"></a>4.1. Подстановка переменных</h2>

            <p>Когда интерпретатор встречает в тексте сценария <span
             class="emphasis"><em
             class="EMPHASIS">имя</em></span> переменной, то он вместо
            него подставляет <span
             class="emphasis"><em
             class="EMPHASIS">значение</em></span> этой переменной.
            Поэтому ссылки на переменные называются <span
             class="emphasis"><em
             class="EMPHASIS">подстановкой переменных</em></span>.</p>

            <div
             class="VARIABLELIST">
              <dl>
                <dt><span
                 class="TOKEN">$</span></dt>

                <dd>
                  <p>Необходимо всегда помнить о различиях между <span
                   class="emphasis"><em
                   class="EMPHASIS">именем</em></span> переменной и ее
                  <span
                   class="emphasis"><em
                   class="EMPHASIS">значением</em></span>. Если <tt
                   class="USERINPUT"><strong>variable1</strong></tt> --
                  это имя переменной, то <tt
                   class="USERINPUT"><strong>$variable1</strong></tt>
                  -- это ссылка на ее <span
                   class="emphasis"><em
                   class="EMPHASIS">значение</em></span>. <span
                   class="QUOTE">&quot;Чистые&quot;</span> имена
                  переменных, без префикса <span
                   class="TOKEN">$</span>, могут использоваться только
                  при объявлении переменный, при присваивании
                  переменной некоторого значения, при <span
                   class="emphasis"><em
                   class="EMPHASIS">удалении (сбросе)</em></span>, при
                  <a
                   href="#EXPORTREF">экспорте</a> и в особых случаях --
                  когда переменная представляет собой название <a
                   href="#SIGNALD">сигнала</a> (см. <a
                   href="#EX76">Пример 29-5</a>). Присваивание может
                  производится с помощью символа <span
                   class="TOKEN">=</span> (например: <span
                   class="emphasis"><em
                   class="EMPHASIS">var1=27</em></span>), инструкцией
                  <a
                   href="#READREF">read</a> и в заголовке цикла (<span
                   class="emphasis"><em
                   class="EMPHASIS">for var2 in 1 2 3</em></span>).</p>

                  <p><a
                   name="DBLQUO"></a>Заключение ссылки на переменную в
                  двойные кавычки (<span
                   class="TOKEN">&quot; &quot;</span>) никак не
                  сказывается на работе механизма подстановки. Этот
                  случай называется &quot;частичные кавычки&quot;,
                  иногда можно встретить название <span
                   class="QUOTE">&quot;нестрогие кавычки&quot;</span>.
                  <a
                   name="SNGLQUO"></a>Одиночные кавычки (<span
                   class="TOKEN">&#39; &#39;</span>) заставляют
                  интерпретатор воспринимать ссылку на переменную как
                  простой набор символов, потому в одинарных кавычках
                  операции подстановки не производятся. Этот случай
                  называется &quot;полные&quot;, или <span
                   class="QUOTE">&quot;строгие&quot;</span> кавычки.
                  Дополнительную информацию вы найдете в <a
                   href="#QUOTING">Глава 5</a>.</p>

                  <p>Примечательно, что написание <tt
                   class="USERINPUT"><strong>$variable</strong></tt>
                  фактически является упрощенной формой написания <tt
                   class="USERINPUT"><strong>${variable}</strong></tt>.
                  Более строгая форма записи <tt
                   class="USERINPUT"><strong>${variable}</strong></tt>
                  может с успехом использоваться в тех случаях, когда
                  применение упрощенной формы записи порождает
                  сообщения о синтаксических ошибках (см. <a
                   href="#PARAMETER-SUBSTITUTION">Section 9.3</a>,
                  ниже).</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX9"></a>

                    <p><strong>Пример 4-1. Присваивание значений
                    переменным и подстановка значений
                    переменных</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Присваивание значений переменным и подстановка значений переменных

a=375
hello=$a

#-------------------------------------------------------------------------
# Использование пробельных символов
# с обеих сторон символа &quot;=&quot; присваивания недопустимо.

#  Если записать &quot;VARIABLE =value&quot;,
#+ то интерпретатор попытается выполнить команду &quot;VARIABLE&quot; с параметром &quot;=value&quot;.

#  Если записать &quot;VARIABLE= value&quot;,
#+ то интерпретатор попытается установить переменную окружения &quot;VARIABLE&quot; в &quot;&quot;
#+ и выполнить команду &quot;value&quot;.
#-------------------------------------------------------------------------


echo hello    # Это не ссылка на переменную, выведет строку &quot;hello&quot;.

echo $hello
echo ${hello} # Идентично предыдущей строке.

echo &quot;$hello&quot;
echo &quot;${hello}&quot;

echo

hello=&quot;A B  C   D&quot;
echo $hello   # A B C D
echo &quot;$hello&quot; # A B  C   D
# Здесь вы сможете наблюдать различия в выводе echo $hello и echo &quot;$hello&quot;.
# Заключение ссылки на переменную в кавычки сохраняет пробельные символы.

echo

echo &#39;$hello&#39;  # $hello
# Внутри одинарных кавычек не производится подстановка значений переменных,
#+ т.е. &quot;$&quot; интерпретируется как простой символ.

# Обратите внимание на различия, существующие между этими типами кавычек.


hello=    # Запись пустого значения в переменную.
echo &quot;\$hello (пустое значение) = $hello&quot;
#  Обратите внимание: запись пустого значения -- это не то же самое,
#+ что сброс переменной, хотя конечный результат -- тот же (см. ниже).

# --------------------------------------------------------------

#  Допускается присваивание нескольких переменных в одной строке,
#+ если они отделены пробельными символами.
#  Внимание! Это может снизить читабельность сценария и оказаться непереносимым.

var1=variable1  var2=variable2  var3=variable3
echo
echo &quot;var1=$var1   var2=$var2  var3=$var3&quot;

# Могут возникнуть проблемы с устаревшими версиями &quot;sh&quot;.

# --------------------------------------------------------------

echo; echo

numbers=&quot;один два три&quot;
other_numbers=&quot;1 2 3&quot;
# Если в значениях переменных встречаются пробелы,
# то использование кавычек обязательно.
echo &quot;numbers = $numbers&quot;
echo &quot;other_numbers = $other_numbers&quot;   # other_numbers = 1 2 3
echo

echo &quot;uninitialized_variable = $uninitialized_variable&quot;
# Неинициализированная переменная содержит &quot;пустое&quot; значение.
uninitialized_variable=   #  Объявление неинициализированной переменной
                          #+ (то же, что и присваивание пустого значения, см. выше).
echo &quot;uninitialized_variable = $uninitialized_variable&quot;
                          # Переменная содержит &quot;пустое&quot; значение.

uninitialized_variable=23       # Присваивание.
unset uninitialized_variable    # Сброс.
echo &quot;uninitialized_variable = $uninitialized_variable&quot;
                                # Переменная содержит &quot;пустое&quot; значение.

echo

exit 0
</pre>
                  </div>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Неинициализированная переменная хранит
                          <span
                           class="QUOTE">&quot;пустое&quot;</span>
                          значение - не ноль!. Использование
                          неинициализированных переменных может
                          приводить к ошибкам разного рода в процессе
                          исполнения.</p>

                          <p>Не смотря на это в арифметических
                          операциях допускается использовать
                          неинициализированные переменные.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;$uninitialized&quot;                                # (пустая строка)
let &quot;uninitialized += 5&quot;                             # Прибавить 5.
echo &quot;$uninitialized&quot;                                # 5

#  Заключение:
#  Неинициализированные переменные не имеют значения, однако
#+ в арифметических операциях за значение таких переменных принимается число 0.
#  Это недокументированная (и возможно непереносимая) возможность.
</pre>
                          См. так же <a
                           href="#SELFSOURCE">Пример 11-19</a>.<br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="VARASSIGNMENT"></a>4.2. Присваивание значений
            переменным</h2>

            <div
             class="VARIABLELIST">
              <dl>
                <dt><a
                 name="EQREF"></a><span
                 class="TOKEN">=</span></dt>

                <dd>
                  <p>оператор присваивания (<span
                   class="emphasis"><em
                   class="EMPHASIS">пробельные символы до и после
                  оператора -- недопустимы</em></span>)</p>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Не путайте с операторами сравнения <a
                           href="#EQUALSIGNREF">=</a> и <a
                           href="#EQUALREF">-eq</a>!</p>

                          <p>Обратите внимание: символ <span
                           class="TOKEN">=</span> может использоваться
                          как в качестве оператора присваивания, так и
                          в качестве оператора сравнения, конкретная
                          интерпретация зависит от контекста
                          применения.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX15"></a>

                    <p><strong>Пример 4-2. Простое
                    присваивание</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Явные переменные

echo

# Когда перед именем переменной не употребляется символ &#39;$&#39;?
# В операциях присваивания.

# Присваивание
a=879
echo &quot;Значение переменной \&quot;a\&quot; -- $a.&quot;

# Присваивание с помощью ключевого слова &#39;let&#39;
let a=16+5
echo &quot;Значение переменной \&quot;a\&quot; теперь стало равным: $a.&quot;

echo

# В заголовке цикла &#39;for&#39; (своего рода неявное присваивание)
echo -n &quot;Значения переменной \&quot;a\&quot; в цикле: &quot;
for a in 7 8 9 11
do
  echo -n &quot;$a &quot;
done

echo
echo

# При использовании инструкции &#39;read&#39; (тоже одна из разновидностей присваивания)
echo -n &quot;Введите значение переменной \&quot;a\&quot; &quot;
read a
echo &quot;Значение переменной \&quot;a\&quot; теперь стало равным: $a.&quot;

echo

exit 0
</pre>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX16"></a>

                    <p><strong>Пример 4-3. Присваивание значений
                    переменным простое и замаскированное</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

a=23              # Простейший случай
echo $a
b=$a
echo $b

# Теперь немного более сложный вариант (подстановка команд).

a=`echo Hello!`   # В переменную &#39;a&#39; попадает результат работы команды &#39;echo&#39;
echo $a
#  Обратите внимание на восклицательный знак (!) в подстанавливаемой команде
#+ этот вариант не будет работать при наборе в командной строке,
#+ поскольку здесь используется механизм &quot;истории команд&quot; BASH
#  Однако, в сценариях, механизм истории команд запрещен.

a=`ls -l`         # В переменную &#39;a&#39; записывается результат работы команды &#39;ls -l&#39;
echo $a           # Кавычки отсутствуют, удаляются лишние пробелы и пустые строки.
echo
echo &quot;$a&quot;         # Переменная в кавычках, все пробелы и пустые строки сохраняются.
                  # (См. главу &quot;Кавычки.&quot;)

exit 0
</pre>
                  </div>

                  <p>Присваивание переменных с использованием <span
                   class="TOKEN">$(...)</span> (более современный
                  метод, по сравнению с <a
                   href="#BACKQUOTESREF">обратными кавычками</a>)</p>
<pre
 class="PROGRAMLISTING">
# Взято из /etc/rc.d/rc.local
R=$(cat /etc/redhat-release)
arch=$(uname -m)
</pre>
                  <br>
                  <br>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="UNTYPED"></a>4.3. Переменные Bash не имеют типа</h2>

            <p><a
             name="BVUNTYPED"></a></p>

            <p>В отличие от большинства других языков программирования,
            Bash не производит разделения переменных по <span
             class="QUOTE">&quot;типам&quot;</span>. По сути,
            переменные Bash являются строковыми переменными, но, в
            зависимости от контекста, Bash допускает целочисленную
            арифметику с переменными. Определяющим фактором здесь
            служит содержимое переменных.</p>

            <div
             class="EXAMPLE">
              <a
               name="INTORSTRING"></a>

              <p><strong>Пример 4-4. Целое число или
              строка?</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# int-or-string.sh: Целое число или строка?

a=2334                   # Целое число.
let &quot;a += 1&quot;
echo &quot;a = $a &quot;           # a = 2335
echo                     # Все еще целое число.


b=${a/23/BB}             # замена &quot;23&quot; на &quot;BB&quot;.
                         # Происходит трансформация числа в строку.
echo &quot;b = $b&quot;            # b = BB35
declare -i b             # Явное указание типа здесь не поможет.
echo &quot;b = $b&quot;            # b = BB35

let &quot;b += 1&quot;             # BB35 + 1 =
echo &quot;b = $b&quot;            # b = 1
echo

c=BB34
echo &quot;c = $c&quot;            # c = BB34
d=${c/BB/23}             # замена &quot;BB&quot; на &quot;23&quot;.
                         # Переменная $d становится целочисленной.
echo &quot;d = $d&quot;            # d = 2334
let &quot;d += 1&quot;             # 2334 + 1 =
echo &quot;d = $d&quot;            # d = 2335
echo

# А что происходит с &quot;пустыми&quot; переменными?
e=&quot;&quot;
echo &quot;e = $e&quot;            # e =
let &quot;e += 1&quot;             # Арифметические операции допускают использование &quot;пустых&quot; переменных?
echo &quot;e = $e&quot;            # e = 1
echo                     # &quot;Пустая&quot; переменная становится целочисленной.

# А что происходит с необъявленными переменными?
echo &quot;f = $f&quot;            # f =
let &quot;f += 1&quot;             # Арифметические операции допустимы?
echo &quot;f = $f&quot;            # f = 1
echo                     # Необъявленная переменная трансформируется в целочисленную.



# Переменные Bash не имеют типов.

exit 0
</pre>
            </div>

            <p>Отсутствие типов -- это и благословение и проклятие. С
            одной стороны -- отсутствие типов делает сценарии более
            гибкими (чтобы повеситься -- достаточно иметь веревку!) и
            облегчает чтение кода. С другой -- является источником
            потенциальных ошибок и поощряет привычку к
            &quot;неряшливому&quot; программированию.</p>

            <p>Бремя отслеживания типа той или иной переменной
            полностью лежит на плечах программиста. Bash не будет
            делать это за вас!</p>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="OTHERTYPESV"></a>4.4. Специальные типы
            переменных</h2>

            <div
             class="VARIABLELIST">
              <dl>
                <dt><tt
                 class="REPLACEABLE"><em>локальные
                переменные</em></tt></dt>

                <dd>
                  <p>переменные, область видимости которых ограничена
                  <a
                   href="#CODEBLOCKREF">блоком кода</a> или телом
                  функции (см так же <a
                   href="#LOCALVAR">локальные переменные</a> в <a
                   href="#FUNCTIONREF">функциях</a>)</p>
                </dd>

                <dt><a
                 name="ENVREF"></a><tt
                 class="REPLACEABLE"><em>переменные
                окружения</em></tt></dt>

                <dd>
                  <p>переменные, которые затрагивают командную оболочку
                  и порядок взаимодействия с пользователем</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>В более общем контексте, каждый процесс
                          имеет некоторое <span
                           class="QUOTE">&quot;окружение&quot;</span>
                          (среду исполнения), т.е. набор переменных, к
                          которым процесс может обращаться за
                          получением определенной информации. В этом
                          смысле командная оболочка подобна любому
                          другому процессу.</p>

                          <p>Каждый раз, когда запускается командный
                          интерпретатор, для него создаются переменные,
                          соответствующие переменным окружения.
                          Изменение переменных или добавление новых
                          переменных окружения заставляет оболочку
                          обновить свои переменные, и все дочерние
                          процессы (и команды, исполняемые ею)
                          наследуют это окружение.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Пространство, выделяемое под переменные
                          окружения, ограничено. Создание слишком
                          большого количества переменных окружения или
                          одной переменной, которая занимает слишком
                          большое пространство, может привести к
                          возникновению определенных проблем.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>eval &quot;`seq 10000 | sed -e &#39;s/.*/export var&amp;=ZZZZZZZZZZZZZZ/&#39;`&quot;</strong></tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>du</strong></tt>
<tt
 class="COMPUTEROUTPUT">bash: /usr/bin/du: Argument list too long</tt>
                 
</pre>
                          <br>
                          <br>

                          <p>(Спасибо S. C. за вышеприведенный пример и
                          пояснения.)</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <p>Если сценарий изменяет переменные окружения, то
                  они должны <span
                   class="QUOTE">&quot;экспортироваться&quot;</span>,
                  т.е передаваться окружению, локальному по отношению к
                  сценарию. Эта функция возложена на команду <a
                   href="#EXPORTREF">export</a>.</p>
                  <a
                   name="CHILDREF"></a>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Сценарий может <strong
                           class="COMMAND">экспортировать</strong>
                          переменные только дочернему процессу, т.е.
                          командам и процессам запускаемым из данного
                          сценария. Сценарий, запускаемый из командной
                          строки <tt
                           class="REPLACEABLE"><em>не может</em></tt>
                          экспортировать переменные &quot;на верх&quot;
                          командной оболочке. <a
                           href="#FORKREF">Дочерний процесс</a> не
                          может экспортировать переменные родительскому
                          процессу.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <p>---</p>
                </dd>

                <dt><a
                 name="POSPARAMREF1"></a><tt
                 class="REPLACEABLE"><em>позиционные
                параметры</em></tt></dt>

                <dd>
                  <p>аргументы, передаваемые скрипту из командной
                  строки -- $0, $1, $2, $3..., где $0 -- это название
                  файла сценария, $1 -- это первый аргумент, $2 --
                  второй, $3 -- третий и так далее. <a
                   name="AEN1772"
                   href="#FTN.AEN1772"><span
                   class="footnote">[13]</span></a> <a
                   name="BRACKETNOTATION"></a>Аргументы, следующие за
                  $9, должны заключаться в фигурные скобки, например:
                  ${10}, ${11}, ${12}.</p>

                  <p>Специальные переменные <a
                   href="#APPREF">$* и $@</a> содержат <span
                   class="emphasis"><em
                   class="EMPHASIS">все</em></span> позиционные
                  параметры (аргументы командной строки).</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX17"></a>

                    <p><strong>Пример 4-5. Позиционные
                    параметры</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Команда вызова сценария должна содержать по меньшей мере 10 параметров, например
# ./scriptname 1 2 3 4 5 6 7 8 9 10
MINPARAMS=10

echo

echo &quot;Имя файла сценария: \&quot;$0\&quot;.&quot;
# Для текущего каталога добавит ./
echo &quot;Имя файла сценария: \&quot;`basename $0`\&quot;.&quot;
# Добавит путь к имени файла (см. &#39;basename&#39;)

echo

if [ -n &quot;$1&quot; ]              # Проверяемая переменная заключена в кавычки.
then
 echo &quot;Параметр #1: $1&quot;     # необходимы кавычки для экранирования символа #
fi

if [ -n &quot;$2&quot; ]
then
 echo &quot;Параметр #2: $2&quot;
fi

if [ -n &quot;$3&quot; ]
then
 echo &quot;Параметр #3: $3&quot;
fi

# ...


if [ -n &quot;${10}&quot; ]  # Параметры, следующие за $9 должны заключаться в фигурные скобки
then
 echo &quot;Параметр #10: ${10}&quot;
fi

echo &quot;-----------------------------------&quot;
echo &quot;Все аргументы командной строки: &quot;$*&quot;&quot;

if [ $# -lt &quot;$MINPARAMS&quot; ]
then
  echo
  echo &quot;Количество аргументов командной строки должно быть не менее $MINPARAMS !&quot;
fi

echo

exit 0
</pre>
                  </div>

                  <p><span
                   class="emphasis"><em
                   class="EMPHASIS">Скобочная нотация</em></span>
                  позиционных параметров дает довольно простой способ
                  обращения к <span
                   class="emphasis"><em
                   class="EMPHASIS">последнему</em></span> аргументу,
                  переданному в сценарий из командной строки. Такой
                  способ подразумевает использование <a
                   href="#VARREFNEW">косвенной адресации</a>.</p>
<pre
 class="PROGRAMLISTING">
args=$#           # Количество переданных аргументов.
lastarg=${!args}  # Обратите внимание: lastarg=${!$#} неприменимо.
</pre>
                  <br>
                  <br>

                  <p>В сценарии можно предусмотреть различные варианты
                  развития событий, в зависимости от имени сценария.
                  Для этого сценарий должен проанализировать аргумент
                  <tt
                   class="VARNAME">$0</tt> -- имя файла сценария. Это
                  могут быть и имена символических ссылок на файл
                  сценария.</p>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Если сценарий ожидает передачи аргументов
                          в командной строке, то при их отсутствии он
                          получит &quot;пустые&quot; переменные, что
                          может вызвать нежелательный побочный эффект.
                          Один из способов борьбы с подобными ошибками
                          -- добавить дополнительный символ в обеих
                          частях операции присваивания, где
                          используются аргументы командной строки.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
<pre
 class="PROGRAMLISTING">
variable1_=$1_
# Это предотвратит появление ошибок, даже при отсутствии входного аргумента.

critical_argument01=$variable1_

# Дополнительные символы всегда можно &quot;убрать&quot; позднее.
# Это может быть сделано примерно так:
variable1=${variable1_/_/}   # Побочный эффект возникает только если имя переменной
                             # $variable1_ будет начинаться с символа &quot;_&quot;.
# Здесь используется один из вариантов подстановки параметров, обсуждаемых в Главе 9.
# Отсутствие шаблона замены приводит к удалению.

# Более простой способ заключается
#+ в обычной проверке наличия позиционного параметра.
if [ -z $1 ]
then
  exit $POS_PARAMS_MISSING
fi
</pre>

                  <p>---</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX18"></a>

                    <p><strong>Пример 4-6. wh, <a
                     href="#WHOISREF">whois</a> выяснение имени
                    домена</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Команда &#39;whois domain-name&#39; выясняет имя домена на одном из 3 серверов:
#                    ripe.net, cw.net, radb.net

# Разместите этот скрипт под именем &#39;wh&#39; в каталоге /usr/local/bin

# Требуемые символические ссылки:
# ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe
# ln -s /usr/local/bin/wh /usr/local/bin/wh-cw
# ln -s /usr/local/bin/wh /usr/local/bin/wh-radb


if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` [domain-name]&quot;
  exit 65
fi

case `basename $0` in
# Проверка имени скрипта и, соответственно, имени сервера
    &quot;wh&quot;     ) whois $1@whois.ripe.net;;
    &quot;wh-ripe&quot;) whois $1@whois.ripe.net;;
    &quot;wh-radb&quot;) whois $1@whois.radb.net;;
    &quot;wh-cw&quot;  ) whois $1@whois.cw.net;;
    *        ) echo &quot;Порядок использования: `basename $0` [domain-name]&quot;;;
esac

exit 0
</pre>
                  </div>

                  <p>---</p>

                  <p><a
                   name="SHIFTREF"></a></p>

                  <p>Команда <strong
                   class="COMMAND">shift</strong> &quot;сдвигает&quot;
                  позиционные параметры, в результате чего парметры
                  &quot;сдвигаются&quot; на одну позицию влево.</p>

                  <p><tt
                   class="VARNAME">$1</tt> &lt;--- <tt
                   class="VARNAME">$2</tt>, <tt
                   class="VARNAME">$2</tt> &lt;--- <tt
                   class="VARNAME">$3</tt>, <tt
                   class="VARNAME">$3</tt> &lt;--- <tt
                   class="VARNAME">$4</tt>, и т.д.</p>

                  <p>Прежний аргумент <tt
                   class="VARNAME">$1</tt> теряется, но аргумент <span
                   class="emphasis"><em
                   class="EMPHASIS"><tt
                   class="VARNAME">$0</tt> (имя файла сценария)
                  остается без изменений</em></span>. Если вашему
                  сценарию передается большое количество входных
                  аргументов, то команда <strong
                   class="COMMAND">shift</strong> позволит вам получить
                  доступ к аргументам, с порядковым номером больше <tt
                   class="LITERAL">9</tt>, без использования <a
                   href="#BRACKETNOTATION">{фигурных скобок}</a>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX19"></a>

                    <p><strong>Пример 4-7. Использование команды
                    shift</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Использование команды &#39;shift&#39; с целью перебора всех аргументов командной строки.

#  Назовите файл с этим сценарием, например &quot;shft&quot;,
#+ и вызовите его с набором аргументов, например:
#          ./shft a b c def 23 skidoo

until [ -z &quot;$1&quot; ]  # До тех пор пока не будут разобраны все входные аргументы...
do
  echo -n &quot;$1 &quot;
  shift
done

echo               # Дополнительная пустая строка.

exit 0
</pre>
                  </div>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Команда <strong
                           class="COMMAND">shift</strong> может
                          применяться и к входным аргументам <a
                           href="#FUNCTIONREF">функций</a>. См. <a
                           href="#MULTIPLICATION">Пример 33-10</a>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>
              </dl>
            </div>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="QUOTING"></a>Глава 5. Кавычки</h1>

          <p><a
           name="QUOTINGREF"></a></p>

          <p>Кавычки, ограничивающие строки с обеих сторон, служат для
          предотвращения интерпретации специальных символов, которые
          могут находиться в строке. (Символ называется
          &quot;специальным&quot;, если он несет дополнительную
          смысловую нагрузку, например символ <span
           class="TOKEN">шаблона</span> -- <span
           class="TOKEN">*</span>.)</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l [Vv]*</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
 -rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
 -rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l &#39;[Vv]*&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">ls: [Vv]*: No such file or directory</tt>
</pre>
          <br>
          <br>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Некоторые программы и утилиты могут вызываться с
                  дополнительными параметрами, содержащими специальными
                  символы, поэтому очень важно предотвратить
                  интерпретацию передаваемых параметров командной
                  оболочкой, позволяя сделать это вызываемой
                  программой.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep &#39;[Пп]ервая&#39; *.txt</strong></tt>
<tt
 class="COMPUTEROUTPUT">file1.txt:Это первая строка в file1.txt.
 file2.txt:Это Первая строка в file2.txt.</tt>
</pre>
                  <br>
                  <br>

                  <p>Примечательно, что &quot;не окавыченный&quot;
                  вариант команды <tt
                   class="USERINPUT"><strong>grep [Пп]ервая
                  *.txt</strong></tt> будет правильно исполняться в
                  Bash, но не в <strong
                   class="COMMAND">tcsh</strong>.</p>
                </td>
              </tr>
            </table>
          </div>

          <p>Вообще, желательно использовать двойные кавычки (<span
           class="TOKEN">&quot; &quot;</span>) при обращении к
          переменным. Это предотвратит интерпретацию специальных
          символов, которые могут содержаться в именах переменных, за
          исключением <span
           class="TOKEN">$</span>, <span
           class="TOKEN">`</span> (обратная кавычка) и <span
           class="TOKEN">\</span> (escape -- обратный слэш). <a
           name="AEN1882"
           href="#FTN.AEN1882"><span
           class="footnote">[14]</span></a> То, что символ <span
           class="TOKEN">$</span> попал в разряд исключений, позволяет
          выполнять обращение к переменным внутри строк, ограниченных
          двойными кавычками (<tt
           class="REPLACEABLE"><em>&quot;$variable&quot;</em></tt>),
          т.е. выполнять подстановку значений переменных (см. <a
           href="#EX9">Пример 4-1</a>, выше).</p>

          <p>Двойные кавычки могут быть использованы для предотвращения
          разбиения строки на слова. <a
           name="AEN1906"
           href="#FTN.AEN1906"><span
           class="footnote">[15]</span></a> Заключение строки в кавычки
          приводит к тому, что она передается как один аргумент, даже
          если она содержит <a
           href="#WHITESPACEREF">пробельные символы</a> -
          разделители.</p>
<pre
 class="PROGRAMLISTING">
variable1=&quot;a variable containing five words&quot;
COMMAND This is $variable1    # Исполнение COMMAND с 7 входными аргументами:
# &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;variable&quot; &quot;containing&quot; &quot;five&quot; &quot;words&quot;

COMMAND &quot;This is $variable1&quot;  # Исполнение COMMAND с одним входным аргументом:
# &quot;This is a variable containing five words&quot;


variable2=&quot;&quot;    # Пустая переменная.

COMMAND $variable2 $variable2 $variable2        # Исполнение COMMAND без аргументов.
COMMAND &quot;$variable2&quot; &quot;$variable2&quot; &quot;$variable2&quot;  # Исполнение COMMAND с 3 &quot;пустыми&quot; аргументами.
COMMAND &quot;$variable2 $variable2 $variable2&quot;      # Исполнение COMMAND с 1 аргументом (и 2 пробелами).

# Спасибо S.C.
</pre>
          <br>
          <br>

          <div
           class="TIP">
            <table
             class="TIP"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/tip.gif"
                 hspace="5"
                 alt="Tip"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Заключение в кавычки аргументов команды <strong
                   class="COMMAND">echo</strong> необходимо только в
                  том случае, когда разбиение на отдельные слова
                  сопряжено с определенными трудностями.</p>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="EXAMPLE">
            <a
             name="WEIRDVARS"></a>

            <p><strong>Пример 5-1. Вывод &quot;причудливых&quot;
            переменных</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# weirdvars.sh: Вывод &quot;причудливых&quot; переменных

var=&quot;&#39;(]\\{}\$\&quot;&quot;
echo $var        # &#39;(]\{}$&quot;
echo &quot;$var&quot;      # &#39;(]\{}$&quot;     Никаких различий.

echo

IFS=&#39;\&#39;
echo $var        # &#39;(] {}$&quot;     \ символ-разделитель преобразован в пробел.
echo &quot;$var&quot;      # &#39;(]\{}$&quot;

# Примеры выше предоставлены S.C.

exit 0
</pre>
          </div>

          <p>Одиночные кавычки (<span
           class="TOKEN">&#39; &#39;</span>) схожи по своему действию с
          двойными кавычками, только не допускают обращение к
          переменным, поскольку специальный символ &quot;$&quot; внутри
          одинарных кавычек воспринимается как обычный символ. Внутри
          одиночных кавычек, <span
           class="emphasis"><em
           class="EMPHASIS">любой</em></span> специальный символ, за
          исключением <span
           class="TOKEN">&#39;</span>, интерпретируется как простой
          символ. Одиночные кавычки (<span
           class="QUOTE">&quot;строгие, или полные
          кавычки&quot;</span>) следует рассматривать как более строгий
          вариант чем двойные кавычки (<span
           class="QUOTE">&quot;нестрогие, или неполные
          кавычки&quot;</span>).</p>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Поскольку внутри одиночных кавычек даже
                  экранирующий (<span
                   class="TOKEN">\</span>) символ воспринимается как
                  обычный символ, попытка вывести одиночную кавычку
                  внутри строки, ограниченной одинарными кавычками, не
                  даст желаемого результата.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;Why can&#39;t I write &#39;s between single quotes&quot;

echo

# Обходной метод.
echo &#39;Why can&#39;\&#39;&#39;t I write &#39;&quot;&#39;&quot;&#39;s between single quotes&#39;
#    |-------|  |----------|   |-----------------------|
# Три строки, ограниченных одинарными кавычками,
# и экранированные одиночные кавычки между ними.

# Пример любезно предоставлен Stephane Chazelas.
</pre>
                  <br>
                  <br>
                </td>
              </tr>
            </table>
          </div>

          <p><a
           name="ESCP"></a><em
           class="FIRSTTERM">Экранирование</em> -- это способ
          заключения в кавычки одиночного символа. Экранирующий (<span
           class="TOKEN">escape</span>) символ (<span
           class="TOKEN">\</span>) сообщает интерпретатору, что
          следующий за ним символ должен восприниматься как обычный
          символ.</p>

          <div
           class="CAUTION">
            <table
             class="CAUTION"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/caution.gif"
                 hspace="5"
                 alt="Caution"></td>

                <td
                 align="left"
                 valign="top">
                  <p>С отдельными командами и утилитами, такими как <a
                   href="#ECHOREF">echo</a> и <a
                   href="#SEDREF">sed</a>, экранирующий символ может
                  применяться для получения обратного эффекта - когда
                  обычные символы при экранировании приобретают
                  специальное значение.</p>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="SPM"></a>Специальное назначение некоторых
            экранированных символов</strong></p>

            <dl>
              <dt>используемых совместно с <strong
               class="COMMAND">echo</strong> и <strong
               class="COMMAND">sed</strong></dt>

              <dt><span
               class="TOKEN">\n</span></dt>

              <dd>
                <p>перевод строки (новая строка)</p>
              </dd>

              <dt><span
               class="TOKEN">\r</span></dt>

              <dd>
                <p>перевод каретки</p>
              </dd>

              <dt><span
               class="TOKEN">\t</span></dt>

              <dd>
                <p>табуляция</p>
              </dd>

              <dt><span
               class="TOKEN">\v</span></dt>

              <dd>
                <p>вертикальная табуляция</p>
              </dd>

              <dt><span
               class="TOKEN">\b</span></dt>

              <dd>
                <p>забой (backspace)</p>
              </dd>

              <dt><span
               class="TOKEN">\a</span></dt>

              <dd>
                <p><span
                 class="QUOTE">&quot;звонок&quot;</span> (сигнал)</p>
              </dd>

              <dt><span
               class="TOKEN">\0xx</span></dt>

              <dd>
                <p>ASCII-символ с кодом <tt
                 class="REPLACEABLE"><em>0xx</em></tt> в восьмеричном
                виде)</p>

                <div
                 class="EXAMPLE">
                  <a
                   name="ESCAPED"></a>

                  <p><strong>Пример 5-2. Экранированные
                  символы</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# escaped.sh: экранированные символы

echo; echo

echo &quot;\v\v\v\v&quot;      # Вывод последовательности символов \v\v\v\v.
# Для вывода экранированных символов следует использовать ключ -e.
echo &quot;=============&quot;
echo &quot;ВЕРТИКАЛЬНАЯ ТАБУЛЯЦИЯ&quot;
echo -e &quot;\v\v\v\v&quot;   # Вывод 4-х вертикальных табуляций.
echo &quot;==============&quot;

echo &quot;КАВЫЧКИ&quot;
echo -e &quot;\042&quot;       # Выводит символ &quot; (кавычки с восьмеричным кодом ASCII 42).
echo &quot;==============&quot;

# Конструкция $&#39;\X&#39; делает использование ключа -e необязательным.
echo; echo &quot;НОВАЯ СТРОКА И ЗВОНОК&quot;
echo $&#39;\n&#39;           # Перевод строки.
echo $&#39;\a&#39;           # Звонок (сигнал).

echo &quot;===============&quot;
echo &quot;КАВЫЧКИ&quot;
# Bash версии 2 и выше допускает использование конструкции $&#39;\nnn&#39;.
# Обратите внимание: здесь под &#39;\nnn&#39; подразумевается восьмеричное значение.
echo $&#39;\t \042 \t&#39;   # Кавычки (&quot;) окруженные табуляцией.

# В конструкции $&#39;\xhhh&#39; допускается использовать и шестнадцатеричные значения.
echo $&#39;\t \x22 \t&#39;  # Кавычки (&quot;) окруженные табуляцией.
# Спасибо Greg Keraunen, за это примечание.
# Ранние версии Bash допускали употребление конструкции в виде &#39;\x022&#39;.
echo &quot;===============&quot;
echo


# Запись ASCII-символов в переменную.
# ----------------------------------------
quote=$&#39;\042&#39;        # запись символа &quot; в переменную.
echo &quot;$quote Эта часть строки ограничена кавычками, $quote а эта -- нет.&quot;

echo

# Конкатенация ASCII-символов в переменную.
triple_underline=$&#39;\137\137\137&#39;  # 137 -- это восьмеричный код символа &#39;_&#39;.
echo &quot;$triple_underline ПОДЧЕРКИВАНИЕ $triple_underline&quot;

echo

ABC=$&#39;\101\102\103\010&#39;           # 101, 102, 103 это  A, B и C соответственно.
echo $ABC

echo; echo

escape=$&#39;\033&#39;                    # 033 -- восьмеричный код экранирующего символа.
echo &quot;\&quot;escape\&quot; выводится как $escape&quot;
#                                   вывод отсутствует.

echo; echo

exit 0
</pre>
                </div>

                <p>Еще один пример использования конструкции <tt
                 class="USERINPUT"><strong>$&#39; &#39;</strong></tt>
                вы найдете в <a
                 href="#EX77">Пример 34-1</a>.</p>
              </dd>

              <dt><span
               class="TOKEN">\&quot;</span></dt>

              <dd>
                <p>кавычки</p>
<pre
 class="PROGRAMLISTING">
echo &quot;Привет&quot;                    # Привет
echo &quot;Он сказал: \&quot;Привет\&quot;.&quot;    # Он сказал: &quot;Привет&quot;.
</pre>
                <br>
                <br>
              </dd>

              <dt><span
               class="TOKEN">\$</span></dt>

              <dd>
                <p>символ доллара (если за комбинацией символов \$
                следует имя переменной, то она не будет
                разыменована)</p>
<pre
 class="PROGRAMLISTING">
echo &quot;\$variable01&quot;  # выведет $variable01
</pre>
                <br>
                <br>
              </dd>

              <dt><span
               class="TOKEN">\\</span></dt>

              <dd>
                <p>обратный слэш</p>
<pre
 class="PROGRAMLISTING">
echo &quot;\\&quot;  # выведет \
</pre>
                <br>
                <br>
              </dd>
            </dl>
          </div>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Поведение символа <span
                   class="TOKEN">\</span> сильно зависит от того
                  экранирован ли он, ограничен ли кавычками или
                  находится внутри конструкции <a
                   href="#COMMANDSUBREF">подстановки команды</a> или во
                  <a
                   href="#HEREDOCREF">вложенном документе</a>.</p>
<pre
 class="PROGRAMLISTING">
                      #  Простое экранирование и кавычки
echo \z               #  z
echo \\z              # \z
echo &#39;\z&#39;             # \z
echo &#39;\\z&#39;            # \\z
echo &quot;\z&quot;             # \z
echo &quot;\\z&quot;            # \z

                      #  Подстановка команды
echo `echo \z`        #  z
echo `echo \\z`       #  z
echo `echo \\\z`      # \z
echo `echo \\\\z`     # \z
echo `echo \\\\\\z`   # \z
echo `echo \\\\\\\z`  # \\z
echo `echo &quot;\z&quot;`      # \z
echo `echo &quot;\\z&quot;`     # \z

                      # Встроенный документ
cat &lt;&lt;EOF
\z
EOF                   # \z

cat &lt;&lt;EOF
\\z
EOF                   # \z

# Эти примеры предоставил Stephane Chazelas.
</pre>
                  <br>
                  <br>

                  <p>Отдельные символы в строке, которая записывается в
                  переменную, могут быть экранированы, исключение
                  составляет сам экранирующий символ.</p>
<pre
 class="PROGRAMLISTING">
variable=\
echo &quot;$variable&quot;
# Не работает - дает сообщение об ошибке:
# test.sh: : command not found
# В &quot;чистом&quot; виде экранирующий (escape) символ не может быть записан в переменную.
#
#  Фактически, в данном примере, происходит экранирование символа перевода строки
#+ в результате получается такая команда:   variable=echo &quot;$variable&quot;
#+                                          ошибочное присваивание

variable=\
23skidoo
echo &quot;$variable&quot;    #  23skidoo
                    #  Здесь все в порядке, поскольку вторая строка
                    #+ является нормальным, с точки зрения присваивания, выражением.

variable=\
#        \^    За escape-символом следует пробел
echo &quot;$variable&quot;        # пробел

variable=\\
echo &quot;$variable&quot;        # \

variable=\\\
echo &quot;$variable&quot;
# Не работает - сообщение об ошибке:
# test.sh: \: command not found
#
#  Первый escape-символ экранирует второй, а третий оказывается неэкранированным,
#+ результат тот же, что и в первом примере.

variable=\\\\
echo &quot;$variable&quot;        # \\
                        # Второй и четвертый escape-символы экранированы.
                        # Это нормально.
</pre>
                  <br>
                  <br>
                </td>
              </tr>
            </table>
          </div>

          <p>Экранирование пробелов предотвращает разбиение списка
          аргументов командной строки на отдельные аргументы.</p>
<pre
 class="PROGRAMLISTING">
file_list=&quot;/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7&quot;
# Список файлов как аргумент(ы) командной строки.

# Добавить два файла в список и вывести список.
ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list

echo &quot;-------------------------------------------------------------------------&quot;

# Что произойдет, если экранировать пробелы в списке?
ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
# Ошибка: первые три файла будут &quot;слиты&quot; воедино
# и переданы команде &#39;ls -l&#39; как один аргумент
# потому что два пробела, разделяющие аргументы (слова) -- экранированы.
</pre>
          <br>
          <br>

          <p>Кроме того, <span
           class="TOKEN">escape</span>-символ позволяет писать
          многострочные команды. Обычно, каждая команда занимает одну
          строку, но <span
           class="TOKEN">escape</span>-символ позволяет <span
           class="emphasis"><em
           class="EMPHASIS">экранировать символ перевода
          строки</em></span>, в результате чего одна команда может
          занимать несколько строк.</p>
<pre
 class="PROGRAMLISTING">
(cd /source/directory &amp;&amp; tar cf - . ) | \
(cd /dest/directory &amp;&amp; tar xpvf -)
# Команда копирования дерева каталогов.
# Разбита на две строки для большей удобочитаемости.

# Альтернативный вариант:
tar cf - -C /source/directory . |
tar xpvf - -C /dest/directory
# См. примечание ниже.
# (Спасибо Stephane Chazelas.)
</pre>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Если строка сценария заканчивается символом
                  создания конвейера <span
                   class="TOKEN">|</span>, то необходимость в
                  применении символа <span
                   class="TOKEN">\</span>, для экранирования перевода
                  строки, отпадает. Тем не менее, считается хорошим
                  тоном, всегда использовать символ &quot;\&quot; в
                  конце промежуточных строк многострочных команд.</p>
                </td>
              </tr>
            </table>
          </div>
          <br>
          <br>
<pre
 class="PROGRAMLISTING">
echo &quot;foo
bar&quot;
#foo
#bar

echo

echo &#39;foo
bar&#39;    # Никаких различий.
#foo
#bar

echo

echo foo\
bar     # Перевод строки экранирован.
#foobar

echo

echo &quot;foo\
bar&quot;     # Внутри &quot;нестрогих&quot; кавычек символ &quot;\&quot; интерпретируется как экранирующий.
#foobar

echo

echo &#39;foo\
bar&#39;     # В &quot;строгих&quot; кавычках обратный слэш воспринимается как обычный символ.
#foo\
#bar

# Примеры предложены Stephane Chazelas.
</pre>
          <br>
          <br>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="EXIT-STATUS"></a>Глава 6. Завершение и код
          завершения</h1>

          <table
           border="0"
           width="100%"
           cellspacing="0"
           cellpadding="0"
           class="EPIGRAPH">
            <tr>
              <td
               width="45%"> </td>

              <td
               width="45%"
               align="left"
               valign="top">
                <p><em>...эта часть Bourne shell покрыта мраком, тем не
                менее все пользуются ею.</em></p>
              </td>
            </tr>

            <tr>
              <td
               width="45%"> </td>

              <td
               width="45%"
               align="right"
               valign="top"><em><span
               class="ATTRIBUTION">Chet Ramey</span></em></td>
            </tr>
          </table>

          <p><a
           name="EXITCOMMANDREF"></a>Команда <strong
           class="COMMAND">exit</strong> может использоваться для
          завершения работы сценария, точно так же как и в программах
          на языке C. Кроме того, она может возвращать некоторое
          значение, которое может быть проанализировано вызывающим
          процессом.</p>

          <p><a
           name="EXITSTATUSREF"></a>Каждая команда возвращает <em
           class="FIRSTTERM">код завершения</em> (иногда код завершения
          называют <em
           class="FIRSTTERM">возвращаемым значением</em> ). В случае
          успеха команда должна возвращать <span
           class="RETURNVALUE">0</span>, а в случае ошибки -- <span
           class="RETURNVALUE">ненулевое</span> значение, которое, как
          правило, интерпретируется как код ошибки. Практически все
          команды и утилиты UNIX возвращают <span
           class="RETURNVALUE">0</span> в случае успешного завершения,
          но имеются и исключения из правил.</p>

          <p>Аналогичным образом ведут себя функции, расположенные
          внутри сценария, и сам сценарий, возвращая код завершения.
          Код, возвращаемый функцией или сценарием, определяется кодом
          возврата последней команды. Команде <tt
           class="USERINPUT"><strong>exit</strong></tt> можно явно
          указать код возврата, в виде: <tt
           class="USERINPUT"><strong>exit</strong></tt> <span
           class="RETURNVALUE"><tt
           class="REPLACEABLE"><em>nnn</em></tt></span>, где <span
           class="RETURNVALUE"><tt
           class="REPLACEABLE"><em>nnn</em></tt></span> -- это код
          возврата (число в диапазоне <span
           class="RETURNVALUE">0</span> - <span
           class="RETURNVALUE">255</span>).</p>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Когда работа сценария завершается командой <strong
                   class="COMMAND">exit</strong> без параметров, то код
                  возврата сценария определяется кодом возврата
                  последней исполненной командой.</p>
                </td>
              </tr>
            </table>
          </div>

          <p><a
           name="EXSREF"></a></p>

          <p>Код возврата последней команды хранится в специальной
          переменной <tt
           class="VARNAME">$?</tt>. После исполнения кода функции,
          переменная <tt
           class="VARNAME">$?</tt> хранит код завершения последней
          команды, исполненной в функции. Таким способом в Bash
          передается <span
           class="QUOTE">&quot;значение, возвращаемое&quot;</span>
          функцией. После завершения работы сценария, код возврата
          можно получить, обратившись из командной строки к переменной
          <tt
           class="VARNAME">$?</tt>, т.е. это будет код возврата
          последней команды, исполненной в сценарии.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX5"></a>

            <p><strong>Пример 6-1. завершение / код
            завершения</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo hello
echo $?    # код возврата = 0, поскольку команда выполнилась успешно.

lskdf      # Несуществующая команда.
echo $?    # Ненулевой код возврата, поскольку команду выполнить не удалось.

echo

exit 113   # Явное указание кода возврата 113.
           # Проверить можно, если набрать в командной строке &quot;echo $?&quot;
           # после выполнения этого примера.

#  В соответствии с соглашениями, &#39;exit 0&#39; указывает на успешное завершение,
#+ в то время как ненулевое значение означает ошибку.
</pre>
          </div>

          <p>Переменная <a
           href="#XSTATVARREF">$?</a> особенно полезна, когда
          необходимо проверить результат исполнения команды (см. <a
           href="#FILECOMP">Пример 12-27</a> и <a
           href="#LOOKUP">Пример 12-13</a>).</p>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Символ <a
                   href="#NOTREF">!</a>, может выступать как логическое
                  &quot;НЕ&quot; для инверсии <a
                   href="#EXITSTATUSREF">кода возврата</a>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="NEGCOND"></a>

                    <p><strong>Пример 6-2. Использование символа <span
                     class="TOKEN">!</span> для логической инверсии
                    кода возврата</strong></p>
<pre
 class="PROGRAMLISTING">
true  # встроенная команда &quot;true&quot;.
echo &quot;код возврата команды \&quot;true\&quot; = $?&quot;     # 0

! true
echo &quot;код возврата команды \&quot;! true\&quot; = $?&quot;   # 1
# Обратите внимание: символ &quot;!&quot; от команды необходимо отделять пробелом.
#    !true   вызовет сообщение об ошибке &quot;command not found&quot;

# Спасибо S.C.
</pre>
                  </div>
                  <br>
                  <br>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="CAUTION">
            <table
             class="CAUTION"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/caution.gif"
                 hspace="5"
                 alt="Caution"></td>

                <td
                 align="left"
                 valign="top">
                  <p>В отдельных случаях коды возврата должны иметь <a
                   href="#EXITCODESREF">предопределенные значения</a> и
                  не должны задаваться пользователем.</p>
                </td>
              </tr>
            </table>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="TESTS"></a>Глава 7. Проверка условий</h1>

          <p><a
           name="IFTHEN"></a></p>

          <p>практически любой язык программирования включает в себя
          условные операторы, предназначенные для проверки условий,
          чтобы выбрать тот или иной путь развития событий в
          зависимости от этих условий. В Bash, для проверки условий,
          имеется команда <strong
           class="COMMAND">test</strong>, различного вида скобочные
          операторы и условный оператор <strong
           class="COMMAND">if/then</strong>.</p>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="TESTCONSTRUCTS"></a>7.1. Конструкции проверки
            условий</h2>

            <p><a
             name="TESTCONSTRUCTS1"></a></p>

            <ul>
              <li>
                <p>Оператор <strong
                 class="COMMAND">if/then</strong> проверяет -- является
                ли <a
                 href="#EXITSTATUSREF">код завершения</a> списка команд
                <span
                 class="RETURNVALUE">0</span> (поскольку 0 означает
                <span
                 class="QUOTE">&quot;успех&quot;</span>), и если это
                так, то выполняет одну, или более, команд, следующие за
                словом then.</p>
              </li>

              <li>
                <p>Существует специальная команда -- <strong
                 class="COMMAND">[</strong> (<a
                 href="#LEFTBRACKET">левая квадратная скобка</a>). Она
                является синонимом команды <strong
                 class="COMMAND">test</strong>, и является <a
                 href="#BUILTINREF">встроенной</a> командой (т.е. более
                эффективной, в смысле производительности). Эта команда
                воспринимает свои аргументы как выражение сравнения или
                как файловую проверку и возвращает код завершения в
                соответствии с результатами проверки (0 -- истина, 1 --
                ложь).</p>
              </li>

              <li>
                <p>Начиная с версии 2.02, Bash предоставляет в
                распоряжение программиста конструкцию <a
                 href="#DBLBRACKETS">[[ ... ]]</a> <span
                 class="emphasis"><em
                 class="EMPHASIS">расширенный вариант команды
                test</em></span>, которая выполняет сравнение способом
                более знакомым программистам, пишущим на других языках
                программирования. Обратите внимание: <strong
                 class="COMMAND">[[</strong> -- это <a
                 href="#KEYWORDREF">зарезервированное слово</a>, а не
                команда.</p>

                <p>Bash исполняет <tt
                 class="USERINPUT"><strong>[[ $a -lt $b
                ]]</strong></tt> как один элемент, который имеет код
                возврата.</p>

                <p>Круглые скобки <a
                 href="#DBLPARENS">(( ... ))</a> и предложение <a
                 href="#LETREF">let ...</a> так же возвращают код <span
                 class="RETURNVALUE">0</span>, если результатом
                арифметического выражения является ненулевое значение.
                Таким образом, <a
                 href="#ARITHEXPREF">арифметические выражения</a> могут
                учавствовать в операциях сравнения.</p>
<pre
 class="PROGRAMLISTING">
Предложение let &quot;1&lt;2&quot; возвращает 0 (так как результат сравнения &quot;1&lt;2&quot; -- &quot;1&quot;, или &quot;истина&quot;)
(( 0 &amp;&amp; 1 )) возвращает 1 (так как результат операции &quot;0 &amp;&amp; 1&quot; -- &quot;0&quot;, или &quot;ложь&quot;)
</pre>
                <br>
                <br>
              </li>

              <li>
                <p>Условный оператор <strong
                 class="COMMAND">if</strong> проверяет код завершения
                любой команды, а не только результат выражения,
                заключенного в квадратные скобки.</p>
<pre
 class="PROGRAMLISTING">
if cmp a b &amp;&gt; /dev/null  # Подавление вывода.
then echo &quot;Файлы a и b идентичны.&quot;
else echo &quot;Файлы a и b имеют различия.&quot;
fi

if grep -q Bash file
then echo &quot;Файл содержит, как минимум, одно слово Bash.&quot;
fi

if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
then echo &quot;Команда выполнена успешно.&quot;
else echo &quot;Обнаружена ошибка при выполнении команды.&quot;
fi
</pre>
                <br>
                <br>
              </li>

              <li>
                <p>Оператор <strong
                 class="COMMAND">if/then</strong> допускает наличие
                вложенных проверок.</p>
<pre
 class="PROGRAMLISTING">
if echo &quot;Следующий *if* находится внутри первого *if*.&quot;

  if [[ $comparison = &quot;integer&quot; ]]
    then (( a &lt; b ))
  else
    [[ $a &lt; $b ]]
  fi

then
  echo &#39;$a меньше $b&#39;
fi
</pre>
                <br>
                <br>

                <p><span
                 class="emphasis"><em
                 class="EMPHASIS">Это детальное описание конструкции
                <span
                 class="QUOTE">&quot;if-test&quot;</span> любезно
                предоставлено Stephane Chazelas.</em></span></p>
              </li>
            </ul>

            <div
             class="EXAMPLE">
              <a
               name="EX10"></a>

              <p><strong>Пример 7-1. Что есть
              &quot;истина&quot;?</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo

echo &quot;Проверяется \&quot;0\&quot;&quot;
if [ 0 ]      # ноль
then
  echo &quot;0 -- это истина.&quot;
else
  echo &quot;0 -- это ложь.&quot;
fi            # 0 -- это истина.

echo

echo &quot;Проверяется \&quot;1\&quot;&quot;
if [ 1 ]      # единица
then
  echo &quot;1 -- это истина.&quot;
else
  echo &quot;1 -- это ложь.&quot;
fi            # 1 -- это ложь.

echo

echo &quot;Testing \&quot;-1\&quot;&quot;
if [ -1 ]     # минус один
then
  echo &quot;-1 -- это истина.&quot;
else
  echo &quot;-1 -- это ложь.&quot;
fi            # -1 -- это истина.

echo

echo &quot;Проверяется \&quot;NULL\&quot;&quot;
if [ ]        # NULL (пустое условие)
then
  echo &quot;NULL -- это истина.&quot;
else
  echo &quot;NULL -- это ложь.&quot;
fi            # NULL -- это ложь.

echo

echo &quot;Проверяется \&quot;xyz\&quot;&quot;
if [ xyz ]    # строка
then
  echo &quot;Случайная строка -- это истина.&quot;
else
  echo &quot;Случайная строка -- это ложь.&quot;
fi            # Случайная строка -- это истина.

echo

echo &quot;Проверяется \&quot;\$xyz\&quot;&quot;
if [ $xyz ]   # Проверка, если $xyz это null, но...
              # только для неинициализированных переменных.
then
  echo &quot;Неинициализированная переменная -- это истина.&quot;
else
  echo &quot;Неинициализированная переменная -- это ложь.&quot;
fi            # Неинициализированная переменная -- это ложь.

echo

echo &quot;Проверяется \&quot;-n \$xyz\&quot;&quot;
if [ -n &quot;$xyz&quot; ]            # Более корректный вариант.
then
  echo &quot;Неинициализированная переменная -- это истина.&quot;
else
  echo &quot;Неинициализированная переменная -- это ложь.&quot;
fi            # Неинициализированная переменная -- это ложь.

echo


xyz=          # Инициализирована пустым значением.

echo &quot;Проверяется \&quot;-n \$xyz\&quot;&quot;
if [ -n &quot;$xyz&quot; ]
then
  echo &quot;Пустая переменная -- это истина.&quot;
else
  echo &quot;Пустая переменная -- это ложь.&quot;
fi            # Пустая переменная -- это ложь.


echo


# Кргда &quot;ложь&quot; истинна?

echo &quot;Проверяется \&quot;false\&quot;&quot;
if [ &quot;false&quot; ]              #  это обычная строка &quot;false&quot;.
then
  echo &quot;\&quot;false\&quot; -- это истина.&quot; #+ и она истинна.
else
  echo &quot;\&quot;false\&quot; -- это ложь.&quot;
fi            # &quot;false&quot; -- это истина.

echo

echo &quot;Проверяется \&quot;\$false\&quot;&quot;  # Опять неинициализированная переменная.
if [ &quot;$false&quot; ]
then
  echo &quot;\&quot;\$false\&quot; -- это истина.&quot;
else
  echo &quot;\&quot;\$false\&quot; -- это ложь.&quot;
fi            # &quot;$false&quot; -- это ложь.
              # Теперь мв получили ожидаемый результат.


echo

exit 0
</pre>
            </div>

            <div
             class="FORMALPARA">
              <p><strong>Упражнение.</strong> Объясните результаты,
              полученные в <a
               href="#EX10">Пример 7-1</a>.</p>
            </div>
<pre
 class="PROGRAMLISTING">
if [ condition-true ]
then
   command 1
   command 2
   ...
else
   # Необязательная ветка (можно опустить, если в ней нет необходимости).
   # Дополнительный блок кода,
   # исполняемый в случае, когда результат проверки -- &quot;ложь&quot;.
   command 3
   command 4
   ...
fi
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Когда <span
                     class="emphasis"><em
                     class="EMPHASIS">if</em></span> и <span
                     class="emphasis"><em
                     class="EMPHASIS">then</em></span> располагаются в
                    одной строке, то конструкция <span
                     class="emphasis"><em
                     class="EMPHASIS">if</em></span> должна завершаться
                    точкой с запятой. И <span
                     class="emphasis"><em
                     class="EMPHASIS">if</em></span>, и <span
                     class="emphasis"><em
                     class="EMPHASIS">then</em></span> -- это <a
                     href="#KEYWORDREF">зарезервированные слова</a>.
                    Зарезервированные слова начинают инструкцию,
                    которая должна быть завершена прежде, чем в той же
                    строке появится новая инструкция.</p>
<pre
 class="PROGRAMLISTING">
if [ -x &quot;$filename&quot; ]; then
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="ELIFREF1"></a>Else if и elif</strong></p>

              <dl>
                <dt><span
                 class="TOKEN">elif</span></dt>

                <dd>
                  <p><tt
                   class="USERINPUT"><strong>elif</strong></tt> -- это
                  краткая форма записи конструкции <span
                   class="TOKEN">else if</span>. Применяется для
                  построения многоярусных инструкций <span
                   class="TOKEN">if/then</span>.</p>
<pre
 class="PROGRAMLISTING">
if [ condition1 ]
then
   command1
   command2
   command3
elif [ condition2 ]
# То же самое, что и else if
then
   command4
   command5
else
   default-command
fi
</pre>
                  <br>
                  <br>
                </dd>
              </dl>
            </div>

            <p>Конструкция <tt
             class="USERINPUT"><strong>if test
            condition-true</strong></tt> является точным эквивалентом
            конструкции <tt
             class="USERINPUT"><strong>if [ condition-true
            ]</strong></tt>, где левая квадратная скобка <strong
             class="COMMAND">[</strong> выполняет те же действия, что и
            команда <strong
             class="COMMAND">test</strong>. Закрывающая правая
            квадратная скобка <strong
             class="COMMAND">]</strong> не является абсолютно
            необходимой, однако, более новые версии Bash требуют ее
            наличие.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <strong
                     class="COMMAND">test</strong> -- это <a
                     href="#BUILTINREF">встроенная</a> команда Bash,
                    которая выполняет проверки файлов и производит
                    сравнение строк. Таким образом, в Bash-скриптах,
                    команда <strong
                     class="COMMAND">test</strong> <span
                     class="emphasis"><em
                     class="EMPHASIS">не</em></span> вызывает внешнюю
                    (<tt
                     class="FILENAME">/usr/bin/test</tt>) утилиту,
                    которая является частью пакета <span
                     class="emphasis"><em
                     class="EMPHASIS">sh-utils</em></span>. Аналогично,
                    <span
                     class="TOKEN">[</span> не производит вызов утилиты
                    <tt
                     class="FILENAME">/usr/bin/[</tt>, которая является
                    символической ссылкой на <tt
                     class="FILENAME">/usr/bin/test</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type test</strong></tt>
<tt
 class="COMPUTEROUTPUT">test is a shell builtin</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type &#39;[&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">[ is a shell builtin</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type &#39;[[&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">[[ is a shell keyword</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type &#39;]]&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">]] is a shell keyword</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type &#39;]&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">bash: type: ]: not found</tt>
             
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="EX11"></a>

              <p><strong>Пример 7-2. Эквиваленты команды <span
               class="TOKEN">test</span> -- <tt
               class="FILENAME">/usr/bin/test</tt>, <span
               class="TOKEN">[ ]</span>, и <tt
               class="FILENAME">/usr/bin/[</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo

if test -z &quot;$1&quot;
then
  echo &quot;Аргументы командной строки отсутствуют.&quot;
else
  echo &quot;Первый аргумент командной строки: $1.&quot;
fi

echo

if /usr/bin/test -z &quot;$1&quot;      # Дает тот же рузультат, что и встроенная команда &quot;test&quot;.
then
  echo &quot;Аргументы командной строки отсутствуют.&quot;
else
  echo &quot;Первый аргумент командной строки: $1.&quot;
fi

echo

if [ -z &quot;$1&quot; ]                # Функционально идентично вышеприведенному блоку кода.
#   if [ -z &quot;$1&quot;                эта конструкция должна работать, но...
#+  Bash выдает сообщение об отсутствующей закрывающей скобке.
then
  echo &quot;Аргументы командной строки отсутствуют.&quot;
else
  echo &quot;Первый аргумент командной строки: $1.&quot;
fi

echo

if /usr/bin/[ -z &quot;$1&quot;         # Функционально идентично вышеприведенному блоку кода.
# if /usr/bin/[ -z &quot;$1&quot; ]     # Работает, но выдает сообщение об ошибке.
then
  echo &quot;Аргументы командной строки отсутствуют.&quot;
else
  echo &quot;Первый аргумент командной строки: $1.&quot;
fi

echo

exit 0
</pre>
            </div>

            <p><a
             name="DBLBRACKETS"></a>Конструкция <span
             class="TOKEN">[[ ]]</span> более универсальна, по
            сравнению с <span
             class="TOKEN">[ ]</span>. Этот <span
             class="emphasis"><em
             class="EMPHASIS">расширенный вариант команды
            test</em></span> перекочевал в Bash из <span
             class="emphasis"><em
             class="EMPHASIS">ksh88</em></span>.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Внутри этой конструкции не производится никакой
                    дополнительной интерпретации имен файлов и не
                    производится разбиение аргументов на отдельные
                    слова, но допускается подстановка параметров и
                    команд.</p>
                  </td>
                </tr>
              </table>
            </div>
<pre
 class="PROGRAMLISTING">
file=/etc/passwd

if [[ -e $file ]]
then
  echo &quot;Файл паролей найден.&quot;
fi
</pre>
            <br>
            <br>

            <div
             class="TIP">
              <table
               class="TIP"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Конструкция <strong
                     class="COMMAND">[[ ... ]]</strong> более
                    предпочтительна, нежели <strong
                     class="COMMAND">[ ... ]</strong>, поскольку
                    поможет избежать некоторых логических ошибок.
                    Например, операторы <span
                     class="TOKEN">&amp;&amp;</span>, <span
                     class="TOKEN">||</span>, <span
                     class="TOKEN">&lt;</span> и <span
                     class="TOKEN">&gt;</span> внутри <span
                     class="TOKEN">[[ ]]</span> вполне допустимы, в то
                    время как внутри <span
                     class="TOKEN">[ ]</span> порождают сообщения об
                    ошибках.</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Строго говоря, после оператора <strong
                     class="COMMAND">if</strong>, ни команда <strong
                     class="COMMAND">test</strong>, ни квадратные
                    скобки ( [ ] или [[ ]] ) не являются
                    обязательными.</p>
<pre
 class="PROGRAMLISTING">
dir=/home/bozo

if cd &quot;$dir&quot; 2&gt;/dev/null; then   # &quot;2&gt;/dev/null&quot; подавление вывода сообщений об ошибках.
  echo &quot;Переход в каталог $dir выполнен.&quot;
else
  echo &quot;Невозможно перейти в каталог $dir.&quot;
fi
</pre>
                    Инструкция &quot;if COMMAND&quot; возвращает код
                    возврата команды COMMAND.<br>
                    <br>

                    <p>Точно так же, условие, находящееся внутри
                    квадратных скобок может быть проверено без
                    использования оператора <strong
                     class="COMMAND">if</strong>.</p>
<pre
 class="PROGRAMLISTING">
var1=20
var2=22
[ &quot;$var1&quot; -ne &quot;$var2&quot; ] &amp;&amp; echo &quot;$var1 не равно $var2&quot;

home=/home/bozo
[ -d &quot;$home&quot; ] || echo &quot;каталог $home не найден.&quot;
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <p>Внутри <a
             href="#DBLPARENS">(( ))</a> производится вычисление
            арифметического выражения. Если результатом вычислений
            является ноль, то возвращается <span
             class="RETURNVALUE">1</span>, или <span
             class="QUOTE">&quot;ложь&quot;</span>. Ненулевой результат
            дает код возврата <span
             class="RETURNVALUE">0</span>, или <span
             class="QUOTE">&quot;истина&quot;</span>. То есть полная
            противоположность инструкциям <strong
             class="COMMAND">test</strong> и <span
             class="TOKEN">[ ]</span>, обсуждавшимся выше.</p>

            <div
             class="EXAMPLE">
              <a
               name="ARITHTESTS"></a>

              <p><strong>Пример 7-3. Арифметические выражения внутри
              <span
               class="TOKEN">(( ))</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Проверка арифметических выражений.

# Инструкция (( ... )) вычисляет арифметические выражения.
# Код возврата противоположен коду возврата инструкции [ ... ] !

(( 0 ))
echo &quot;Код возврата \&quot;(( 0 ))\&quot;:  $?.&quot;         # 1

(( 1 ))
echo &quot;Код возврата \&quot;(( 1 ))\&quot;:  $?.&quot;         # 0

(( 5 &gt; 4 ))                                   # true
echo &quot;Код возврата \&quot;(( 5 &gt; 4 ))\&quot;:  $?.&quot;     # 0

(( 5 &gt; 9 ))                                   # false
echo &quot;Код возврата \&quot;(( 5 &gt; 9 ))\&quot;:  $?.&quot;     # 1

(( 5 - 5 ))                                   # 0
echo &quot;Код возврата \&quot;(( 5 - 5 ))\&quot;:  $?.&quot;     # 1

(( 5 / 4 ))                                   # Деление, все в порядке
echo &quot;Код возврата \&quot;(( 5 / 4 ))\&quot;:  $?.&quot;     # 0

(( 1 / 2 ))                                   # Результат деления &lt; 1.
echo &quot;Код возврата \&quot;(( 1 / 2 ))\&quot;:  $?.&quot;     # Округляется до 0.
                                              # 1

(( 1 / 0 )) 2&gt;/dev/null                       # Деление на 0.
echo &quot;Код возврата \&quot;(( 1 / 0 ))\&quot;:  $?.&quot;     # 1

# Для чего нужна инструкция &quot;2&gt;/dev/null&quot; ?
# Что произойдет, если ее убрать?
# Попробуйте убрать ее и выполнить сценарий.

exit 0
</pre>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="FTO"></a>7.2. Операции проверки файлов</h2>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="RTIF"></a>Возвращает true если...</strong></p>

              <dl>
                <dt><span
                 class="TOKEN">-e</span></dt>

                <dd>
                  <p>файл существует</p>
                </dd>

                <dt><span
                 class="TOKEN">-f</span></dt>

                <dd>
                  <p><tt
                   class="REPLACEABLE"><em>обычный</em></tt> файл (не
                  каталог и не файл устройства)</p>
                </dd>

                <dt><span
                 class="TOKEN">-s</span></dt>

                <dd>
                  <p>ненулевой размер файла</p>
                </dd>

                <dt><span
                 class="TOKEN">-d</span></dt>

                <dd>
                  <p>файл является каталогом</p>
                </dd>

                <dt><span
                 class="TOKEN">-b</span></dt>

                <dd>
                  <p>файл является блочным устройством (floppy, cdrom и
                  т.п.)</p>
                </dd>

                <dt><span
                 class="TOKEN">-c</span></dt>

                <dd>
                  <p>файл является символьным устройством (клавиатура,
                  модем, звуковая карта и т.п.)</p>
                </dd>

                <dt><span
                 class="TOKEN">-p</span></dt>

                <dd>
                  <p>файл является каналом</p>
                </dd>

                <dt><span
                 class="TOKEN">-h</span></dt>

                <dd>
                  <p>файл является символической ссылкой</p>
                </dd>

                <dt><span
                 class="TOKEN">-L</span></dt>

                <dd>
                  <p>файл является символической ссылкой</p>
                </dd>

                <dt><span
                 class="TOKEN">-S</span></dt>

                <dd>
                  <p>файл является сокетом</p>
                </dd>

                <dt><span
                 class="TOKEN">-t</span></dt>

                <dd>
                  <p>файл (<a
                   href="#FDREF">дескриптор</a>) связан с терминальным
                  устройством</p>

                  <p>Этот ключ может использоваться для проверки --
                  является ли файл стандартным устройством ввода <tt
                   class="FILENAME">stdin</tt> (<tt
                   class="USERINPUT"><strong>[ -t 0 ]</strong></tt>)
                  или стандартным устройством вывода <tt
                   class="FILENAME">stdout</tt> (<tt
                   class="USERINPUT"><strong>[ -t 1
                  ]</strong></tt>).</p>
                </dd>

                <dt><span
                 class="TOKEN">-r</span></dt>

                <dd>
                  <p>файл доступен для чтения (<span
                   class="emphasis"><em
                   class="EMPHASIS">пользователю, запустившему
                  сценарий</em></span>)</p>
                </dd>

                <dt><span
                 class="TOKEN">-w</span></dt>

                <dd>
                  <p>файл доступен для записи (пользователю,
                  запустившему сценарий)</p>
                </dd>

                <dt><span
                 class="TOKEN">-x</span></dt>

                <dd>
                  <p>файл доступен для исполнения (пользователю,
                  запустившему сценарий)</p>
                </dd>

                <dt><span
                 class="TOKEN">-g</span></dt>

                <dd>
                  <p>set-group-id (sgid) флаг для файла или каталога
                  установлен</p>

                  <p>Если для каталога установлен флаг <tt
                   class="REPLACEABLE"><em>sgid</em></tt>, то файлы,
                  создаваемые в таком каталоге, наследуют идентификатор
                  группы каталога, который может не совпадать с
                  идентификатором группы, к которой принадлежит
                  пользователь, создавший файл. Это может быть полезно
                  для каталогов, в которых хранятся файлы,
                  общедоступные для группы пользователей.</p>
                </dd>

                <dt><span
                 class="TOKEN">-u</span></dt>

                <dd>
                  <p>set-user-id (suid) флаг для файла установлен</p>

                  <p>Установленный флаг suid приводит к изменению
                  привилегий запущенного процесса на привилегии
                  владельца исполняемого файла. Исполняемые файлы,
                  владельцем которых является <span
                   class="emphasis"><em
                   class="EMPHASIS">root</em></span>, с установленным
                  флагом <tt
                   class="REPLACEABLE"><em>set-user-id</em></tt>
                  запускаются с привилегиями <span
                   class="emphasis"><em
                   class="EMPHASIS">root</em></span>, даже если их
                  запускает обычный пользователь. <a
                   name="AEN2488"
                   href="#FTN.AEN2488"><span
                   class="footnote">[16]</span></a> Это может оказаться
                  полезным для некоторых программ (таких как <strong
                   class="COMMAND">pppd</strong> и <strong
                   class="COMMAND">cdrecord</strong>), которые
                  осуществляют доступ к аппаратной части компьютера. В
                  случае отсутствия флага <span
                   class="emphasis"><em
                   class="EMPHASIS">suid</em></span>, программы не
                  смогут быть запущены рядовым пользователем, не
                  обладающим привилегиями root.</p>
				  
				  <a href="abs2.html">Advanced Bash-Scripting Guide - Часть 2</a>
  </body>
</html>

