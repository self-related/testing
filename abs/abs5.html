<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <meta
     name="generator"
     content=
    "HTML Tidy for Linux/x86 (vers 1st July 2002), see www.w3.org">

    <title>Advanced Bash-Scripting Guide - Часть 5</title>
    <meta
     http-equiv="Content-Type"
     content="text/html; charset=koi8-r">
    <meta
     name="GENERATOR"
     content="Modular DocBook HTML Stylesheet Version 1.7">
  </head>
        <a href="/testing/index.html">Главная</a>
	<h1
         class="TITLE"><a
         name="AEN2"></a>Advanced Bash-Scripting Guide - Часть 5</h1>
  <body
   class="BOOK"
   bgcolor="#FFFFFF"
   text="#000000"
   link="#0000FF"
   vlink="#840084"
   alink="#0000FF">
      <div
       class="TOC">
        
                  <dt>12.9. <a
                   href="#EXTMISC">Прочие команды</a></dt>
                </dl>
              </dd>

              <dt>13. <a
               href="#SYSTEM">Команды системного
              администрирования</a></dt>

              <dt>14. <a
               href="#COMMANDSUB">Подстановка команд</a></dt>

              <dt>15. <a
               href="#ARITHEXP">Арифметические подстановки</a></dt>

              <dt>16. <a
               href="#IO-REDIRECTION">Перенаправление
              ввода/вывода</a></dt>

              <dd>
                <dl>
                  <dt>16.1. <a
                   href="#AEN11702">С помощью команды <strong
                   class="COMMAND">exec</strong></a></dt>

                </dl>
              </dd>
			
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# monthlypmt.sh: Расчет ежемесячных выплат по займу.


#  Это измененный вариант пакета &quot;mcalc&quot; (mortgage calculator),
#+ написанного Jeff Schmidt и Mendel Cooper (ваш покорный слуга).
#   http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz  [15k]

echo
echo &quot;Введите сумму займа, процентную ставку и срок займа,&quot;
echo &quot;для расчета суммы ежемесячных выплат.&quot;

bottom=1.0

echo
echo -n &quot;Сумма займа (без запятых -- с точностью до доллара) &quot;
read principal
echo -n &quot;Процентная ставка (процент) &quot;  # Если 12%, то нужно вводить &quot;12&quot;, а не &quot;.12&quot;.
read interest_r
echo -n &quot;Срок займа (месяцев) &quot;
read term


 interest_r=$(echo &quot;scale=9; $interest_r/100.0&quot; | bc) # Здесь &quot;scale&quot; -- точность вычислений.


 interest_rate=$(echo &quot;scale=9; $interest_r/12 + 1.0&quot; | bc)


 top=$(echo &quot;scale=9; $principal*$interest_rate^$term&quot; | bc)

 echo; echo &quot;Прошу подождать. Вычисления потребуют некоторого времени.&quot;

 let &quot;months = $term - 1&quot;
# ====================================================================
 for ((x=$months; x &gt; 0; x--))
 do
   bot=$(echo &quot;scale=9; $interest_rate^$x&quot; | bc)
   bottom=$(echo &quot;scale=9; $bottom+$bot&quot; | bc)
#  bottom = $(($bottom + $bot&quot;))
 done
# --------------------------------------------------------------------
#  Rick Boivie предложил более эффективную реализацию
#+ цикла вычислений, который дает выигрыш по времени на 2/3.

# for ((x=1; x &lt;= $months; x++))
# do
#   bottom=$(echo &quot;scale=9; $bottom * $interest_rate + 1&quot; | bc)
# done


#  А затем нашел еще более эффективную альтернативу,
#+ которая выполняется в 20 раз быстрее !!!

# bottom=`{
#     echo &quot;scale=9; bottom=$bottom; interest_rate=$interest_rate&quot;
#     for ((x=1; x &lt;= $months; x++))
#     do
#          echo &#39;bottom = bottom * interest_rate + 1&#39;
#     done
#     echo &#39;bottom&#39;
#     } | bc`       # Внедрить цикл &#39;for&#39; в конструкцию подстановки команд.

# ====================================================================

 # let &quot;payment = $top/$bottom&quot;
 payment=$(echo &quot;scale=2; $top/$bottom&quot; | bc)
 # Два знака после запятой, чтобы показать доллары и центы.

 echo
 echo &quot;ежемесячные выплаты = \$$payment&quot;  # Вывести знак &quot;доллара&quot; перед числом.
 echo


 exit 0

 # Упражнения:
 #   1) Добавьте возможность ввода суммы с точностью до цента.
 #   2) Добавьте возможность ввода процентной ставки как в виде процентов, так и в виде десятичного числа -- доли целого.
 #   3) Если вы действительно честолюбивы,
 #      добавьте в сценарий вывод полной таблицы помесячных выплат.
</pre>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="BASE"></a>

                    <p><strong>Пример 12-33. Перевод чисел из одной
                    системы счисления в другую</strong></p>
<pre
 class="PROGRAMLISTING">
:
##########################################################################
# Shellscript:  base.sh - вывод чисел в разных системах счисления (Bourne Shell)
# Author     :  Heiner Steven (heiner.steven@odn.de)
# Date       :  07-03-95
# Category   :  Desktop
# $Id: base.sh,v 1.2 2000/02/06 19:55:35 heiner Exp $
##########################################################################
# Description
#
# Changes
# 21-03-95 stv  исправлена ошибка, возникающая при вводе числа 0xb (0.2)
##########################################################################

# ==&gt; Используется в данном документе с разрешения автора.
# ==&gt; Комментарии добавлены автором документа.

NOARGS=65
PN=`basename &quot;$0&quot;`                             # Имя программы
VER=`echo &#39;$Revision: 1.2 $&#39; | cut -d&#39; &#39; -f2`  # ==&gt; VER=1.2

Usage () {
    echo &quot;$PN - вывод чисел в различных системах счисления, $VER (stv &#39;95)
Порядок использования: $PN [number ...]

Если число не задано, то производится ввод со stdin.
Число может быть:
    двоичное            должно начинаться с комбинации символов 0b (например 0b1100)
    восьмеричное        должно начинаться с 0  (например 014)
    шестнадцатиричное   должно начинаться с комбинации символов 0x (например 0xc)
    десятичное          в любом другом случае (например 12)&quot; &gt;&amp;2
    exit $NOARGS
}   # ==&gt; Функция вывода сообщения о порядке использования.

Msg () {
    for i   # ==&gt; [список] параметров опущен.
    do echo &quot;$PN: $i&quot; &gt;&amp;2
    done
}

Fatal () { Msg &quot;$@&quot;; exit 66; }

PrintBases () {
    # Определение системы счисления
    for i      # ==&gt; [список] параметров опущен...
    do         # ==&gt; поэтому работает с аргументами командной строки.
        case &quot;$i&quot; in
            0b*)                ibase=2;;       # двоичная
            0x*|[a-f]*|[A-F]*)  ibase=16;;      # шестнадцатиричная
            0*)                 ibase=8;;       # восьмеричная
            [1-9]*)             ibase=10;;      # десятичная
            *)
                Msg &quot;Ошибка в числе $i - число проигнорировано&quot;
                continue;;
        esac

        # Удалить префикс и преобразовать шестнадцатиричные цифры в верхний регистр (этого требует bc)
        number=`echo &quot;$i&quot; | sed -e &#39;s:^0[bBxX]::&#39; | tr &#39;[a-f]&#39; &#39;[A-F]&#39;`
        # ==&gt; вместо &quot;/&quot;, здесь используется символ &quot;:&quot; как разделитель для sed.

        # Преобразование в десятичную систему счисления
        dec=`echo &quot;ibase=$ibase; $number&quot; | bc`  # ==&gt; &#39;bc&#39; используется как калькулятор.
        case &quot;$dec&quot; in
            [0-9]*)     ;;       # все в порядке
            *)          continue;; # ошибка: игнорировать
        esac

        # Напечатать все преобразования в одну строку.
        # ==&gt; &#39;вложенный документ&#39; -- список команд для &#39;bc&#39;.
        echo `bc &lt;&lt;!
            obase=16; &quot;hex=&quot;; $dec
            obase=10; &quot;dec=&quot;; $dec
            obase=8;  &quot;oct=&quot;; $dec
            obase=2;  &quot;bin=&quot;; $dec
!
    ` | sed -e &#39;s: :    :g&#39;

    done
}

while [ $# -gt 0 ]
do
    case &quot;$1&quot; in
        --)     shift; break;;
        -h)     Usage;;          # ==&gt; Вывод справочного сообщения.
        -*)     Usage;;
        *)      break;;          # первое число
    esac   # ==&gt; Хорошо бы расширить анализ вводимых символов.
    shift
done

if [ $# -gt 0 ]
then
    PrintBases &quot;$@&quot;
else                                    # чтение со stdin
    while read line
    do
        PrintBases $line
    done
fi
</pre>
                  </div>

                  <p>Один из вариантов вызова <strong
                   class="COMMAND">bc</strong> -- использование <a
                   href="#HEREDOCREF">вложенного документа</a>,
                  внедряемого в блок с <a
                   href="#COMMANDSUBREF">подстановкой команд</a>. Это
                  особенно актуально, когда сценарий должен передать
                  <strong
                   class="COMMAND">bc</strong> значительный по объему
                  список команд и аргументов.</p>
<pre
 class="PROGRAMLISTING">
variable=`bc &lt;&lt; LIMIT_STRING
options
statements
operations
LIMIT_STRING
`
</pre>
                  ...или... 
<pre
 class="PROGRAMLISTING">
variable=$(bc &lt;&lt; LIMIT_STRING
options
statements
operations
LIMIT_STRING
)
</pre>
                  <br>
                  <br>

                  <div
                   class="EXAMPLE">
                    <a
                     name="ALTBC"></a>

                    <p><strong>Пример 12-34. Пример взаимодействия bc
                    со <span
                     class="QUOTE">&quot;встроенным
                    документом&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Комбинирование &#39;bc&#39; с
# &#39;вложенным документом&#39;.


var1=`bc &lt;&lt; EOF
18.33 * 19.78
EOF
`
echo $var1       # 362.56


#  запись $( ... ) тоже работает.
v1=23.53
v2=17.881
v3=83.501
v4=171.63

var2=$(bc &lt;&lt; EOF
scale = 4
a = ( $v1 + $v2 )
b = ( $v3 * $v4 )
a * b + 15.35
EOF
)
echo $var2       # 593487.8452


var3=$(bc -l &lt;&lt; EOF
scale = 9
s ( 1.7 )
EOF
)
# Возвращается значение синуса от 1.7 радиана.
# Ключом &quot;-l&quot; вызывается математическая библиотека &#39;bc&#39;.
echo $var3       # .991664810


# Попробуем функции...
hyp=             # Объявление глобальной переменной.
hypotenuse ()    # Расчет гипотенузы прямоугольного треугольника.
{
hyp=$(bc -l &lt;&lt; EOF
scale = 9
sqrt ( $1 * $1 + $2 * $2 )
EOF
)
# К сожалению, функции Bash не могут возвращать числа с плавающей запятой.
}

hypotenuse 3.68 7.31
echo &quot;гипотенуза = $hyp&quot;    # 8.184039344


exit 0
</pre>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="CANNON"></a>

                    <p><strong>Пример 12-35. Вычисление числа
                    &quot;пи&quot;</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# cannon.sh: Аппроксимация числа &quot;пи&quot;.

# Это очень простой вариант реализации метода &quot;Monte Carlo&quot;,
#+ математическое моделирование событий реальной жизни,
#+ для эмуляции случайного события используются псевдослучайные числа.

#  Допустим, что мы располагаем картой квадратного участка поверхности со стороной квадрата 10000 единиц.
#  На этом участке, в центре, находится совершенно круглое озеро,
#+ с диаметром в 10000 единиц.
#  Т.е. озеро покрывает почти всю карту, кроме ее углов.
#  (Фактически -- это квадрат со вписанным кругом.)
#
#  Пусть по этому участку ведется стрельба железными ядрами из древней пушки
#  Все ядра падают где-то в пределах данного участка,
#+ т.е. либо в озеро, либо на сушу, по углам участка.
#  Поскольку озеро покрывает большую часть участка,
#+ то большинство ядер будет падать в воду.
#  Незначительная часть ядер будет падать на твердую почву.
#
#  Если произвести достаточно большое число неприцельных выстрелов по данному участку,
#+ то отношение попаданий в воду к общему числу выстрелов будет примерно равно
#+ значению PI/4.
#
#  По той простой причине, что стрельба фактически ведется только
#+ по правому верхнему квадранту карты.
#  (Предыдущее описание было несколько упрощено.)
#
#  Теоретически, чем больше будет произведено выстрелов, тем точнее будет результат.
#  Однако, сценарий на языке командной оболочки, в отличие от других языков программирования,
#+ в которых доступны операции с плавающей запятой, имеет некоторые ограничения.
#  К сожалению, это делает вычисления менее точными.


DIMENSION=10000  # Длина стороны квадратного участка поверхности.
                 # Он же -- верхний предел для генератора случайных чисел.

MAXSHOTS=1000    # Количество выстрелов.
                 # 10000 выстрелов (или больше) даст лучший результат,
                                                                 # но потребует значительного количества времени.
PMULTIPLIER=4.0  # Масштабирующий коэффициент.

get_random ()
{
SEED=$(head -1 /dev/urandom | od -N 1 | awk &#39;{ print $2 }&#39;)
RANDOM=$SEED                                  #  Из примера &quot;seeding-random.sh&quot;

let &quot;rnum = $RANDOM % $DIMENSION&quot;             #  Число не более чем 10000.
echo $rnum
}

distance=        # Объявление глобальной переменной.
hypotenuse ()    # Расчет гипотенузы прямоугольного треугольника.
{                # Из примера &quot;alt-bc.sh&quot;.
distance=$(bc -l &lt;&lt; EOF
scale = 0
sqrt ( $1 * $1 + $2 * $2 )
EOF
)
#  Установка &quot;scale&quot; в ноль приводит к округлению результата &quot;вниз&quot;,
#+ это и есть то самое ограничение, накладываемое командной оболочкой.
#  Что, к сожалению, снижает точность аппроксимации.
}


# main() {

# Инициализация переменных.
shots=0
splashes=0
thuds=0
Pi=0

while [ &quot;$shots&quot; -lt  &quot;$MAXSHOTS&quot; ]           # Главный цикл.
do

  xCoord=$(get_random)                        # Получить случайные координаты X и Y.
  yCoord=$(get_random)
  hypotenuse $xCoord $yCoord                  #  Гипотенуза = расстоянию.
  ((shots++))

  printf &quot;#%4d   &quot; $shots
  printf &quot;Xc = %4d  &quot; $xCoord
  printf &quot;Yc = %4d  &quot; $yCoord
  printf &quot;Distance = %5d  &quot; $distance         #  Растояние от
                                              #+ центра озера,
                                              #+ с координатами (0,0).

  if [ &quot;$distance&quot; -le &quot;$DIMENSION&quot; ]
  then
    echo -n &quot;ШЛЕП!  &quot;                         # попадание в озеро
    ((splashes++))
  else
    echo -n &quot;БУХ!    &quot;                        # попадание на твердую почву
    ((thuds++))
  fi

  Pi=$(echo &quot;scale=9; $PMULTIPLIER*$splashes/$shots&quot; | bc)
  # Умножение на коэффициент 4.0.
  echo -n &quot;PI ~ $Pi&quot;
  echo

done

echo
echo &quot;После $shots выстрела, примерное значение числа \&quot;пи\&quot; равно $Pi.&quot;
# Имеет тенденцию к завышению...
# Вероятно из-за ошибок округления и несовершенства генератора случайных чисел.
echo

# }

exit 0

#  Самое время задуматься над тем, является ли сценарий удобным средством
#+ для выполнения большого количества столь сложных вычислений.
#
#  Тем не менее, этот пример может расцениваться как
#  1) Доказательство возможностей языка командной оболочки.
#  2) Прототип для &quot;обкатки&quot; алгоритма перед тем как перенести
#+    его на высокоуровневые языки программирования компилирующего типа.
</pre>
                  </div>
                </dd>

                <dt><a
                 name="DCREF"></a><strong
                 class="COMMAND">dc</strong></dt>

                <dd>
                  <p>Утилита <strong
                   class="COMMAND">dc</strong> (<strong
                   class="COMMAND">d</strong>esk <strong
                   class="COMMAND">c</strong>alculator) -- это
                  калькулятор, использующий &quot;Обратную Польскую
                  Нотацию&quot;, и ориентированный на работу со
                  стеком.</p>

                  <p>Многие стараются избегать испоьзования <strong
                   class="COMMAND">dc</strong>, из-за непривычной формы
                  записи операндов и операций. Однако, <strong
                   class="COMMAND">dc</strong> имеет и своих
                  сторонников.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="HEXCONVERT"></a>

                    <p><strong>Пример 12-36. Преобразование чисел из
                    десятичной в шестнадцатиричную систему
                    счисления</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# hexconvert.sh: Преобразование чисел из десятичной в шестнадцатиричную систему счисления.

BASE=16     # Шестнадцатиричная.

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: $0 number&quot;
  exit $E_NOARGS
  # Необходим аргумент командной строки.
fi
# Упражнение: добавьте проверку корректности аргумента.


hexcvt ()
{
if [ -z &quot;$1&quot; ]
then
  echo 0
  return    # &quot;Return&quot; 0, если функции не был передан аргумент.
fi

echo &quot;&quot;$1&quot; &quot;$BASE&quot; o p&quot; | dc
#                 &quot;o&quot; устанавливает основание системы счисления для вывода.
#                   &quot;p&quot; выводит число, находящееся на вершине стека.
# См. &#39;man dc&#39;.
return
}

hexcvt &quot;$1&quot;

exit 0
</pre>
                  </div>

                  <p>Изучение страниц <span
                   class="emphasis"><em
                   class="EMPHASIS">info</em></span> <strong
                   class="COMMAND">dc</strong> позволит детальнее
                  разобраться с утилитой. Однако, отряд
                  &quot;гуру&quot;, которые могут похвастать своим
                  знанием этой мощной, но весьма запутанной утилиты,
                  весьма немногочислен.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="FACTR"></a>

                    <p><strong>Пример 12-37. Разложение числа на
                    простые множители</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# factr.sh: Разложение числа на простые множители

MIN=2       # Не работает с числами меньше 2.
E_NOARGS=65
E_TOOSMALL=66

if [ -z $1 ]
then
  echo &quot;Порядок использования: $0 number&quot;
  exit $E_NOARGS
fi

if [ &quot;$1&quot; -lt &quot;$MIN&quot; ]
then
  echo &quot;Исходное число должно быть больше или равно $MIN.&quot;
  exit $E_TOOSMALL
fi

# Упражнение: Добавьте проверку типа числа (не целые числа должны отвергаться).

echo &quot;Простые множители для числа $1:&quot;
# ---------------------------------------------------------------------------------
echo &quot;$1[p]s2[lip/dli%0=1dvsr]s12sid2%0=13sidvsr[dli%0=1lrli2+dsi!&gt;.]ds.xd1&lt;2&quot; | dc
# ---------------------------------------------------------------------------------
# Автор вышеприведенной строки: Michel Charpentier &lt;charpov@cs.unh.edu&gt;.
# Используется с его разрешения (спасибо).

 exit 0
</pre>
                  </div>
                </dd>

                <dt><a
                 name="AWKMATH"></a><strong
                 class="COMMAND">awk</strong></dt>

                <dd>
                  <p>Еще один способ выполнения математических
                  операций, над числами с плавающей запятой, состоит в
                  создании <a
                   href="#SHWRAPPER">сценария-обертки</a>,
                  использующего математические функции <a
                   href="#AWKREF">awk</a>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="HYPOT"></a>

                    <p><strong>Пример 12-38. Расчет гипотенузы
                    прямоугольного треугольника</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# hypotenuse.sh: Возвращает &quot;гипотенузу&quot; прямоугольного треугольника.
#               ( корень квадратный от суммы квадратов катетов)

ARGS=2                # В сценарий необходимо передать два катета.
E_BADARGS=65          # Ошибка в аргументах.

if [ $# -ne &quot;$ARGS&quot; ] # Проверка количества аргументов.
then
  echo &quot;Порядок использования: `basename $0` катет_1 катет_2&quot;
  exit $E_BADARGS
fi


AWKSCRIPT=&#39; { printf( &quot;%3.7f\n&quot;, sqrt($1*$1 + $2*$2) ) } &#39;
#            команды и параметры, передаваемые в awk


echo -n &quot;Гипотенуза прямоугольного треугольника, с катетами $1 и $2, = &quot;
echo $1 $2 | awk &quot;$AWKSCRIPT&quot;

exit 0
</pre>
                  </div>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="EXTMISC"></a>12.9. Прочие команды</h2>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="MISCCOMMANDLISTING1"></a>Команды, которые нельзя
              отнести ни к одной из вышеперечисленных
              категорий</strong></p>

              <dl>
                <dt><strong
                 class="COMMAND">jot</strong>, <strong
                 class="COMMAND">seq</strong></dt>

                <dd>
                  <p>Эти утилиты выводят последовательность целых чисел
                  с шагом, заданным пользователем.</p>

                  <p>По-умолчанию, выводимые числа отделяются друг от
                  друга символом перевода строки, однако, с помощью
                  ключа <tt
                   class="OPTION">-s</tt> может быть задан другой
                  разделитель.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>seq 5</strong></tt>
<tt
 class="COMPUTEROUTPUT">1
2
3
4
5</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>seq -s : 5</strong></tt>
<tt
 class="COMPUTEROUTPUT">1:2:3:4:5</tt>
             
</pre>
                  <br>
                  <br>

                  <p>Обе утилиты, и <strong
                   class="COMMAND">jot</strong>, и <strong
                   class="COMMAND">seq</strong>, очень удобно
                  использовать для генерации списка аргументов в цикле
                  <a
                   href="#FORLOOPREF1">for</a>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX53"></a>

                    <p><strong>Пример 12-39. Использование seq для
                    генерации списка аргументов цикла for</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Утилита &quot;seq&quot;

echo

for a in `seq 80`  # или так:   for a in $( seq 80 )
# То же самое, что и   for a in 1 2 3 4 5 ... 80   (но как экономит время и силы!).
# Можно использовать и &#39;jot&#39; (если эта утилита имеется в системе).
do
  echo -n &quot;$a &quot;
done      # 1 2 3 4 5 ... 80
# Пример использования вывода команды для генерации
# [списка] аргументов цикла &quot;for&quot;.

echo; echo


COUNT=80  # Да, &#39;seq&#39; допускает указание переменных в качестве параметра.

for a in `seq $COUNT`  # или так:   for a in $( seq $COUNT )
do
  echo -n &quot;$a &quot;
done      # 1 2 3 4 5 ... 80

echo; echo

BEGIN=75
END=80

for a in `seq $BEGIN $END`
#  Если &quot;seq&quot; передаются два аргумента, то первый означает начальное число последовательности,
#+ второй -- последнее,
do
  echo -n &quot;$a &quot;
done      # 75 76 77 78 79 80

echo; echo

BEGIN=45
INTERVAL=5
END=80

for a in `seq $BEGIN $INTERVAL $END`
#  Если &quot;seq&quot; передется три аргумента, то первый аргумент -- начальное число в последовательности,
#+ второй -- шаг последовательности,
#+ и третий -- последнее число в последовательности.
do
  echo -n &quot;$a &quot;
done      # 45 50 55 60 65 70 75 80

echo; echo

exit 0
</pre>
                  </div>
                </dd>

                <dt><a
                 name="GETOPTY"></a><strong
                 class="COMMAND">getopt</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">getopt</strong> служит для разбора
                  командной строки, выделяя из нее ключи -- символы, с
                  предшествующим знаком <a
                   href="#DASHREF">дефис</a>. Этой утилите имеется,
                  встроенный в Bash, аналог -- <a
                   href="#GETOPTSX">getopts</a>, более мощная и
                  универсальная команда.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX33A"></a>

                    <p><strong>Пример 12-40. Использование getopt для
                    разбора аргументов командной строки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# ex33a.sh

# Попробуйте следующие варианты вызова этого сценария.
#   sh ex33a -a
#   sh ex33a -abc
#   sh ex33a -a -b -c
#   sh ex33a -d
#   sh ex33a -dXYZ
#   sh ex33a -d XYZ
#   sh ex33a -abcd
#   sh ex33a -abcdZ
#   sh ex33a -z
#   sh ex33a a
# Объясните полученные результаты.

E_OPTERR=65

if [ &quot;$#&quot; -eq 0 ]
then   # Необходим по меньшей мере один аргумент.
  echo &quot;Порядок использования: $0 -[options a,b,c]&quot;
  exit $E_OPTERR
fi

set -- `getopt &quot;abcd:&quot; &quot;$@&quot;`
# Запись аргументов командной строки в позиционные параметры.
# Что произойдет, если вместо &quot;$@&quot; указать &quot;$*&quot;?

while [ ! -z &quot;$1&quot; ]
do
  case &quot;$1&quot; in
    -a) echo &quot;Опция \&quot;a\&quot;&quot;;;
    -b) echo &quot;Опция \&quot;b\&quot;&quot;;;
    -c) echo &quot;Опция \&quot;c\&quot;&quot;;;
    -d) echo &quot;Опция \&quot;d\&quot; $2&quot;;;
     *) break;;
  esac

  shift
done

#  Вместо &#39;getopt&#39; лучше использовать встроенную команду &#39;getopts&#39;,
#  См. &quot;ex33.sh&quot;.

exit 0
</pre>
                  </div>
                </dd>

                <dt><a
                 name="RUNPARTSREF"></a><strong
                 class="COMMAND">run-parts</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">run-parts</strong> <a
                   name="AEN9380"
                   href="#FTN.AEN9380"><span
                   class="footnote">[33]</span></a> запускает на
                  исполнение все сценарии, в порядке возрастания имен
                  файлов-сценариев, в заданном каталоге. Естественно,
                  файлы сценариев должны иметь права на исполнение.</p>

                  <p><a
                   href="#DAEMONREF">Демон</a> <a
                   href="#CRONREF">crond</a> вызывает <strong
                   class="COMMAND">run-parts</strong> для запуска
                  сценариев из каталогов <tt
                   class="FILENAME">/etc/cron.*</tt>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">yes</strong></dt>

                <dd>
                  <p>По-умолчанию, команда <strong
                   class="COMMAND">yes</strong> выводит на <tt
                   class="FILENAME">stdout</tt> непрерывную
                  последовательность символов <tt
                   class="COMPUTEROUTPUT">y</tt>, разделенных символами
                  перевода строки. Исполнение команды можно прервать
                  комбинацией клавиш <strong
                   class="KEYCAP">control</strong>-<strong
                   class="KEYCAP">c</strong>. Команду <strong
                   class="COMMAND">yes</strong> можно заставить
                  выводить иную последовательность символов. Теперь
                  самое время задаться вопросом о практической пользе
                  этой команды. Основное применение этой команды
                  состоит в том, что вывод от нее может быть передан,
                  через конвейер, другой команде, ожидающей реакции
                  пользователя. В результате получается, своего рода,
                  слабенькая версия команды <strong
                   class="COMMAND">expect</strong>.</p>

                  <p><tt
                   class="USERINPUT"><strong>yes | fsck
                  /dev/hda1</strong></tt> запускает <strong
                   class="COMMAND">fsck</strong> в неинтерактивном
                  режиме (будьте осторожны!).</p>

                  <p><tt
                   class="USERINPUT"><strong>yes | rm -r
                  dirname</strong></tt> имеет тот же эффект, что и <tt
                   class="USERINPUT"><strong>rm -rf
                  dirname</strong></tt> (будьте осторожны!).</p>

                  <div
                   class="WARNING">
                    <table
                     class="WARNING"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/warning.gif"
                         hspace="5"
                         alt="Warning"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Внимание! Передача вывода команды <strong
                           class="COMMAND">yes</strong> по конвейеру
                          потенциально опасным командам, таким как <a
                           href="#FSCKREF">fsck</a> или <a
                           href="#FDISKREF">fdisk</a> может дать
                          нежелательные побочные эффекты.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">banner</strong></dt>

                <dd>
                  <p>Печатает на <tt
                   class="FILENAME">stdout</tt> заданную строку
                  символов (не более 10), рисуя каждый символ строки
                  при помощи символа &#39;#&#39;. Вывод от команды
                  может быть перенаправлен на принтер.</p>
                </dd>

                <dt><strong
                 class="COMMAND">printenv</strong></dt>

                <dd>
                  <p>Выводит все <a
                   href="#ENVREF">переменные окружения</a> текущего
                  пользователя.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>printenv | grep HOME</strong></tt>
<tt
 class="COMPUTEROUTPUT">HOME=/home/bozo</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">lp</strong></dt>

                <dd>
                  <p>Команды <strong
                   class="COMMAND">lp</strong> и <strong
                   class="COMMAND">lpr</strong> отправляют файлы в
                  очередь печати <a
                   name="AEN9455"
                   href="#FTN.AEN9455"><span
                   class="footnote">[34]</span></a> для вывода на
                  принтер. Названия этих команд произошли от &quot;line
                  printers&quot;.</p>

                  <p><tt
                   class="PROMPT">bash$</tt> <tt
                   class="USERINPUT"><strong>lp file1.txt</strong></tt>
                  или <tt
                   class="PROMPT">bash</tt> <tt
                   class="USERINPUT"><strong>lp
                  &lt;file1.txt</strong></tt></p>

                  <p>Очень часто используются в комбинации с командой
                  форматированного вывода <strong
                   class="COMMAND">pr</strong>.</p>

                  <p><tt
                   class="PROMPT">bash$</tt> <tt
                   class="USERINPUT"><strong>pr -options file1.txt |
                  lp</strong></tt></p>

                  <p>Программы подготовки текста к печати, такие как
                  <strong
                   class="COMMAND">groff</strong> и <span
                   class="emphasis"><em
                   class="EMPHASIS">Ghostscript</em></span>, так же
                  могут напрямую взаимодействовать с <strong
                   class="COMMAND">lp</strong>.</p>

                  <p><tt
                   class="PROMPT">bash$</tt> <tt
                   class="USERINPUT"><strong>groff -Tascii file.tr |
                  lp</strong></tt></p>

                  <p><tt
                   class="PROMPT">bash$</tt> <tt
                   class="USERINPUT"><strong>gs -options | lp
                  file.ps</strong></tt></p>

                  <p>Команда <strong
                   class="COMMAND">lpq</strong> предназначена для
                  просмотра очереди заданий печати, а <strong
                   class="COMMAND">lprm</strong> -- для удаления
                  заданий из очереди.</p>
                </dd>

                <dt><strong
                 class="COMMAND">tee</strong></dt>

                <dd>
                  <p>[UNIX заимствовал эту идею из водопроводного
                  дела.]</p>

                  <p>Это опрератор перенаправления, но с некоторыми
                  особенностями. Подобно водопроводным трубам, <span
                   class="QUOTE">&quot;tee&quot;</span> позволяет <span
                   class="QUOTE">&quot;направить поток&quot;</span>
                  данных <span
                   class="emphasis"><em
                   class="EMPHASIS">в несколько файлов</em></span> и на
                  stdout одновременно, никак не влияя на сами данные.
                  Эта команда может оказаться очень полезной при
                  отладке.</p>
<pre
 class="SCREEN">
                   tee
                 |------&gt; в файл
                 |
  ===============|===============
  command---&gt;----|-operator--&gt;---&gt; результат работы команд(ы)
  ===============================
             
</pre>
<pre
 class="PROGRAMLISTING">
cat listfile* | sort | tee check.file | uniq &gt; result.file
</pre>
                  (Здесь, в файл <tt
                   class="FILENAME">check.file</tt> будут записаны
                  данные из всех <span
                   class="QUOTE">&quot;listfile*&quot;</span>, в
                  отсортированном виде до того, как повторяющиеся
                  строки будут удалены командой <a
                   href="#UNIQREF">uniq</a>.)<br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">mkfifo</strong></dt>

                <dd>
                  <p><a
                   name="NAMEDPIPEREF"></a>Эта, редко встречающаяся,
                  команда создает <span
                   class="emphasis"><em
                   class="EMPHASIS">именованный канал</em></span> -
                  очередь, через который производится обмен данными
                  между процессами. <a
                   name="AEN9514"
                   href="#FTN.AEN9514"><span
                   class="footnote">[35]</span></a> Как правило, один
                  процесс записывает данные в очередь (FIFO), а другой
                  читает данные из очереди. См. <a
                   href="#FIFO">Пример A-17</a>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">pathchk</strong></dt>

                <dd>
                  <p>Производит проверку полного имени файла --
                  проверяет, доступны ли на чтение, каталоги в пути к
                  файлу, и не превышает ли длина полного имени файла
                  255 символов. При несоблюдении одного из условий --
                  возвращает сообщение об ошибке.</p>

                  <p>К сожалению, <strong
                   class="COMMAND">pathchk</strong> не возвращает
                  соответствующего кода ошибки, и потому, в общем-то,
                  бесполезна в сценариях. Вместо нее лучше использовать
                  <a
                   href="#RTIF">операторы проверки файлов</a>.</p>
                </dd>

                <dt><a
                 name="DDREF"></a><strong
                 class="COMMAND">dd</strong></dt>

                <dd>
                  <p>Эта немного непонятная и &quot;страшная&quot;
                  команда (<span
                   class="QUOTE">&quot;data duplicator&quot;</span>)
                  изначально использовалась для переноса данных на
                  магнитной ленте между микрокомпьютерами с ОС UNIX и
                  майнфреймами IBM. Команда <strong
                   class="COMMAND">dd</strong> просто создает копию
                  файла (или <tt
                   class="FILENAME">stdin/stdout</tt>), выполняя по
                  пути некоторые преобразования. Один из вариантов:
                  преобразование из ASCII в EBCDIC, <a
                   name="AEN9546"
                   href="#FTN.AEN9546"><span
                   class="footnote">[36]</span></a> <tt
                   class="USERINPUT"><strong>dd --help</strong></tt>
                  выведет список возможных вариантов преобразований и
                  опций этой мощной утилиты.</p>
<pre
 class="PROGRAMLISTING">
# Изучаем &#39;dd&#39;.

n=3
p=5
input_file=project.txt
output_file=log.txt

dd if=$input_file of=$output_file bs=1 skip=$((n-1)) count=$((p-n+1)) 2&gt; /dev/null
# Извлечет из $input_file символы с n-го по p-й.




echo -n &quot;hello world&quot; | dd cbs=1 conv=unblock 2&gt; /dev/null
# Выведет &quot;hello world&quot; вертикально.


# Спасибо, S.C.
</pre>
                  <br>
                  <br>

                  <p>Для демонстрации возможностей <strong
                   class="COMMAND">dd</strong>, попробуем перехватить
                  нажатия на клавиши.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="DDKEYPRESS"></a>

                    <p><strong>Пример 12-41. Захват нажатых
                    клавиш</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Захват нажатых клавиш.


keypresses=4                      # Количество фиксируемых нажатий.


old_tty_setting=$(stty -g)        # Сохранить настройки терминала.

echo &quot;Нажмите $keypresses клавиши.&quot;
stty -icanon -echo                # Запретить канонический режим.
                                  # Запретить эхо-вывод.
keys=$(dd bs=1 count=$keypresses 2&gt; /dev/null)
# &#39;dd&#39; использует stdin, если &quot;if&quot; не задан.

stty &quot;$old_tty_setting&quot;           # Восстановить настройки терминала.

echo &quot;Вы нажали клавиши \&quot;$keys\&quot;.&quot;

# Спасибо S.C.
exit 0
</pre>
                  </div>

                  <p>Команда <strong
                   class="COMMAND">dd</strong> имеет возможность
                  произвольного доступа к данным в потоке.</p>
<pre
 class="PROGRAMLISTING">
echo -n . | dd bs=1 seek=4 of=file conv=notrunc
# Здесь, опция &quot;conv=notrunc&quot; означает, что выходной файлне будет усечен.

# Спасибо, S.C.
</pre>
                  <br>
                  <br>

                  <p>Команда <strong
                   class="COMMAND">dd</strong> может использоваться для
                  создания образов дисков, считывая данные прямо с
                  устройств, таких как дискеты, компакт диски,
                  магнитные ленты (<a
                   href="#COPYCD">Пример A-6</a>). Обычно она
                  используется для создания загрузочных дискет.</p>

                  <p><tt
                   class="USERINPUT"><strong>dd if=kernel-image
                  of=/dev/fd0H1440</strong></tt></p>

                  <p>Точно так же, <strong
                   class="COMMAND">dd</strong> может скопировать все
                  содержимое дискеты, даже с неизвестной файловой
                  системой, на жесткий диск в виде файла-образа.</p>

                  <p><tt
                   class="USERINPUT"><strong>dd if=/dev/fd0
                  of=/home/bozo/projects/floppy.img</strong></tt></p>

                  <p>Еще одно применение <strong
                   class="COMMAND">dd</strong> -- создание временного
                  swap-файла (<a
                   href="#EX73">Пример 28-2</a>) и ram-дисков (<a
                   href="#RAMDISK">Пример 28-3</a>). Она может
                  создавать даже образы целых разделов жесткого диска,
                  хотя и не рекомендуется делать это без особой на то
                  необходимости.</p>

                  <p>Многие (которые, вероятно, не знают чем себя
                  занять) постоянно придумывают все новые и новые
                  области применения команды <strong
                   class="COMMAND">dd</strong>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="BLOTOUT"></a>

                    <p><strong>Пример 12-42. Надежное удаление
                    файла</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# blotout.sh: Надежно удаляет файл.

#  Этот суенарий записывает случайные данные в заданный файл,
#+ затем записывает туда нули и наконец удаляет файл.
#  После такого удаления даже анализ дисковых секторов
#+ не даст ровным счетом ничего.

PASSES=7         # Количество проходов по файлу.
BLOCKSIZE=1      #  операции ввода/вывода в/из /dev/urandom требуют указания размера блока,
                 #+ иначе вы не получите желаемого результата.
E_BADARGS=70
E_NOT_FOUND=71
E_CHANGED_MIND=72

if [ -z &quot;$1&quot; ]   # Имя файла не указано.
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

file=$1

if [ ! -e &quot;$file&quot; ]
then
  echo &quot;Файл \&quot;$file\&quot; не найден.&quot;
  exit $E_NOT_FOUND
fi

echo; echo -n &quot;Вы совершенно уверены в том, что желаете уничтожить \&quot;$file\&quot; (y/n)? &quot;
read answer
case &quot;$answer&quot; in
[nN]) echo &quot;Передумали? Операция отменена.&quot;
      exit $E_CHANGED_MIND
      ;;
*)    echo &quot;Уничтожается файл \&quot;$file\&quot;.&quot;;;
esac


flength=$(ls -l &quot;$file&quot; | awk &#39;{print $5}&#39;)  # Поле с номером 5 -- это длина файла.

pass_count=1

echo

while [ &quot;$pass_count&quot; -le &quot;$PASSES&quot; ]
do
  echo &quot;Проход #$pass_count&quot;
  sync         # Вытолкнуть буферы.
  dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength
               # Заполнить файл случайными данными.
  sync         # Снова вытолкнуть буферы.
  dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength
               # Заполнить файл нулями.
  sync         # Снова вытолкнуть буферы.
  let &quot;pass_count += 1&quot;
  echo
done


rm -f $file    # Наконец удалить изрядно &quot;подпорченный&quot; файл.
sync           # Вытолкнуть буферы в последний раз.

echo &quot;Файл \&quot;$file\&quot; уничтожен.&quot;; echo


#  Это довольно надежный, хотя и достаточно медленный способ уничтожения файлов.
#+ Более эффективно это делает команда &quot;shred&quot;,
#+ входящая в состав пакета GNU &quot;fileutils&quot;.

#  Уничтоженный таким образом файл, не сможет быть восстановлен обычными методами.
#  Однако...
#+ эта метода вероятно НЕ сможет противостоять аналитическим службам
#+ из СООТВЕТСТВУЮЩИХ ОРГАНОВ


#  Tom Vier разработал пакет &quot;wipe&quot;, который более надежно стирает файлы
#+ чем этот простой сценарий.
#     http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2

#  Для более глубоко изучения проблемы надежного удаления файлов,
#+ рекомендую обратиться к cnfnmt Peter Gutmann,
#+     &quot;Secure Deletion of Data From Magnetic and Solid-State Memory&quot;.
#         http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html


exit 0
</pre>
                  </div>
                </dd>

                <dt><a
                 name="ODREF"></a><strong
                 class="COMMAND">od</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">od</strong> (<span
                   class="emphasis"><em
                   class="EMPHASIS">octal dump</em></span>) производит
                  преобразование ввода (или файла) в один или несколько
                  форматов, в соответствии с указанными опциями. При
                  отсутствии опций используется восьмеричный формат
                  (опция -o). Эта команда полезна при просмотре или
                  обработке файлов с двоичными данными, например <tt
                   class="FILENAME">/dev/urandom</tt>. См. <a
                   href="#SEEDINGRANDOM">Пример 9-26</a> и <a
                   href="#RND">Пример 12-10</a>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">hexdump</strong></dt>

                <dd>
                  <p>Выводит дамп двоичных данных из файла в
                  восьмеричном, шестнадцатиричном, десятичном виде или
                  в виде ASCII. Эту команду, с массой оговорок, можно
                  назвать эквивалентом команды of <strong
                   class="COMMAND">od</strong>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">objdump</strong></dt>

                <dd>
                  <p>Отображает содержимое исполняемого или объектного
                  файла либо в шестнадцатиричной форме, либо в виде
                  дизассемблерного листинга (с ключом <tt
                   class="OPTION">-d</tt>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>objdump -d /bin/ls</strong></tt>
<tt
 class="COMPUTEROUTPUT">/bin/ls:     file format elf32-i386

 Disassembly of section .init:

 080490bc &lt;.init&gt;:
  80490bc:       55                      push   %ebp
  80490bd:       89 e5                   mov    %esp,%ebp
  . . .</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">mcookie</strong></dt>

                <dd>
                  <p>Эта команда создает псевдослучайные
                  шестнадцатиричные 128-битные числа, так называемые
                  <span
                   class="QUOTE">&quot;magic cookie&quot;</span>,
                  обычно используется X-сервером в качестве <span
                   class="QUOTE">&quot;сигнатуры&quot;</span>
                  авторизации. В сценариях может использоваться как
                  малоэффективный генератор случайных чисел.</p>
<pre
 class="PROGRAMLISTING">
random000=`mcookie | sed -e &#39;2p&#39;`
# &#39;sed&#39; удаляет посторонние символы.
</pre>
                  <br>
                  <br>

                  <p>Конечно, для тех же целей, сценарий может
                  использовать <a
                   href="#MD5SUMREF">md5</a>.</p>
<pre
 class="PROGRAMLISTING">
# Сценарий вычисляет контрольную сумму для самого себя.
random001=`md5sum $0 | awk &#39;{print $1}&#39;`
# &#39;awk&#39; удаляет имя файла.
</pre>
                  <br>
                  <br>

                  <p>С помощью <strong
                   class="COMMAND">mcookie</strong> можно создавать
                  <span
                   class="QUOTE">&quot;уникальные&quot;</span> имена
                  файлов.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="TEMPFILENAME"></a>

                    <p><strong>Пример 12-43. Генератор имен
                    файлов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# tempfile-name.sh:  Генератор имен временных файлов

BASE_STR=`mcookie`   # 32-символьный (128 бит) magic cookie.
POS=11               # Произвольная позиция в строке magic cookie.
LEN=5                # $LEN последовательных символов.

prefix=temp          #  В конце концов это временный (&quot;temp&quot;) файл.

suffix=${BASE_STR:POS:LEN}
                     # Извлечь строку, длиной в 5 символов, начиная с позиции 11.

temp_filename=$prefix.$suffix
                     # Сборка имени файла.

echo &quot;Имя временного файла = \&quot;$temp_filename\&quot;&quot;

# sh tempfile-name.sh
# Имя временного файла = temp.e19ea

exit 0
</pre>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">units</strong></dt>

                <dd>
                  <p>Эта утилита производит преобразование величин из
                  одних единиц измерения в другие. Как правило
                  вызывается в интерактивном режиме, ниже приводится
                  пример использования <strong
                   class="COMMAND">units</strong> в сценарии.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="UNITCONVERSION"></a>

                    <p><strong>Пример 12-44. Преобразование метров в
                    мили</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# unit-conversion.sh


convert_units ()  # Принимает в качестве входных параметров единицы измерения.
{
  cf=$(units &quot;$1&quot; &quot;$2&quot; | sed --silent -e &#39;1p&#39; | awk &#39;{print $2}&#39;)
  # Удаляет все кроме коэффициентов преобразования.
  echo &quot;$cf&quot;
}

Unit1=miles
Unit2=meters
cfactor=`convert_units $Unit1 $Unit2`
quantity=3.73

result=$(echo $quantity*$cfactor | bc)

echo &quot;В $quantity милях $result метров.&quot;

#  Что произойдет, если в функцию передать несовместимые единицы измерения,
#+ например &quot;acres&quot; (акры) and &quot;miles&quot; (мили)?

exit 0
</pre>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">m4</strong></dt>

                <dd>
                  <p>Не команда, а клад, <strong
                   class="COMMAND">m4</strong> -- это мощный фильтр
                  обработки макроопределений, <a
                   name="AEN9671"
                   href="#FTN.AEN9671"><span
                   class="footnote">[37]</span></a> фактически -- целый
                  язык программирования. Изначально создававшаяся как
                  препроцессор для <span
                   class="emphasis"><em
                   class="EMPHASIS">RatFor</em></span>, <strong
                   class="COMMAND">m4</strong> оказалась очень полезной
                  и как самостоятельная утилита. Фактически, <strong
                   class="COMMAND">m4</strong> сочетает в себе
                  функциональные возможности <a
                   href="#EVALREF">eval</a>, <a
                   href="#TRREF">tr</a>, <a
                   href="#AWKREF">awk</a>, и дополнительно
                  предоставляет обширные возможности по созданию новых
                  макроопределений.</p>

                  <p>В апрельском выпуске, за 2002 год, журнала <a
                   href="http://www.linuxjournal.com"
                   target="_top">Linux Journal</a> вы найдете
                  замечательную статью, описывающую возможности утилиты
                  <strong
                   class="COMMAND">m4</strong>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="M4"></a>

                    <p><strong>Пример 12-45. Пример работы с
                    m4</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# m4.sh: Демонстрация некоторых возможносией макропроцессора m4

# Строки
string=abcdA01
echo &quot;len($string)&quot; | m4                           # 7
echo &quot;substr($string,4)&quot; | m4                      # A01
echo &quot;regexp($string,[0-1][0-1],\&amp;Z)&quot; | m4     # 01Z

# Арифметика
echo &quot;incr(22)&quot; | m4                               # 23
echo &quot;eval(99 / 3)&quot; | m4                           # 33

exit 0
</pre>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">doexec</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">doexec</strong> предоставляет
                  возможность передачи произвольного списка аргументов
                  внешней программе. В частности, передавая <tt
                   class="VARNAME">argv[0]</tt> (для сценариев
                  соответствует специальной переменной <a
                   href="#POSPARAMREF1">$0</a>), можно вызвать
                  программу под другим именем, определяя тем самым, ее
                  реакцию.</p>

                  <p>Например, Пусть в каталоге <tt
                   class="FILENAME">/usr/local/bin</tt> имеется
                  программа с именем <span
                   class="QUOTE">&quot;aaa&quot;</span>, которая при
                  вызове <strong
                   class="COMMAND">doexec /usr/local/bin/aaa
                  list</strong> выведет список всех файлов в текущем
                  каталоге, имена которых начинаются с символа <span
                   class="QUOTE">&quot;a&quot;</span>, а при вызове той
                  же самой программы как <strong
                   class="COMMAND">doexec /usr/local/bin/aaa
                  delete</strong> , она удалит эти файлы.</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Естественно, реакция программы на свое
                          собственное имя должна быть реализована в
                          коде программы, для сценария на языке
                          командной оболочки это может выглядеть
                          примерно так:</p>
<pre
 class="PROGRAMLISTING">
case `basename $0` in
&quot;name1&quot; ) реакция на вызов под именем name1;;
&quot;name2&quot; ) реакция на вызов под именем name2;;
&quot;name3&quot; ) реакция на вызов под именем name3;;
*       ) действия по-умолчанию;;
esac
</pre>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>
              </dl>
            </div>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="SYSTEM"></a>Глава 13. Команды системного
          администрирования</h1>

          <p>Примеры использования большинства этих команд вы найдете в
          сценариях начальной загрузки и остановки системы, в каталогах
          <tt
           class="FILENAME">/etc/rc.d</tt>. Они, обычно, вызываются
          пользователем root и используются для администрирования
          системы или восстановления файловой системы. Эти команды
          должны использоваться с большой осторожностью, так как
          некоторые из них могут разрушить систему, при неправильном
          использовании.</p>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="USERSGROUPS1"></a>Пользователи и группы</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">users</strong></dt>

              <dd>
                <p>Выведет список всех зарегистрировавшихся
                пользователей. Она, до некоторой степени, является
                эквивалентом команды <strong
                 class="COMMAND">who -q</strong>.</p>
              </dd>

              <dt><strong
               class="COMMAND">groups</strong></dt>

              <dd>
                <p>Выводит список групп, в состав которых входит
                текущий пользователь. Эта команда соответствует
                внутренней переменной <a
                 href="#GROUPSREF">$GROUPS</a>, но выводит названия
                групп, а не их числовые идентификаторы.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>groups</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozita cdrom cdwriter audio xgrp</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $GROUPS</strong></tt>
<tt
 class="COMPUTEROUTPUT">501</tt>
</pre>
              </dd>

              <dt><strong
               class="COMMAND">chown</strong>, <strong
               class="COMMAND">chgrp</strong></dt>

              <dd>
                <p>Команда <strong
                 class="COMMAND">chown</strong> изменяет владельца
                файла или файлов. Эта команда полезна в случаях, когда
                <tt
                 class="REPLACEABLE"><em>root</em></tt> хочет передать
                монопольное право на файл от одного пользователя
                другому. Обычный пользователь не в состоянии изменить
                владельца файла, за исключением своих собственных
                файлов.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">root#</tt> <tt
 class="USERINPUT"><strong>chown bozo *.txt</strong></tt>

             
</pre>
                <br>
                <br>

                <p>Команда <strong
                 class="COMMAND">chgrp</strong> изменяет группу,
                которой принадлежит файл или файлы. Чтобы изменить
                группу, вы должны быть владельцем файла (при этом
                должны входить в состав указываемой группы) или
                привилегированным пользователем (<tt
                 class="REPLACEABLE"><em>root</em></tt>).</p>
<pre
 class="PROGRAMLISTING">
chgrp --recursive dunderheads *.data
#  Группа &quot;dunderheads&quot; станет владельцем всех файлов &quot;*.data&quot;
#+ во всех подкаталогах текущей директории ($PWD) (благодаря ключу &quot;--recursive&quot;).
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">useradd</strong>, <strong
               class="COMMAND">userdel</strong></dt>

              <dd>
                <p>Команда <strong
                 class="COMMAND">useradd</strong> добавляет учетную
                запись нового пользователя в систему и создает домашний
                каталог для данного пользователя. Противоположная, по
                смыслу, команда <strong
                 class="COMMAND">userdel</strong> удаляет учетную
                запись пользователя из системы. <a
                 name="AEN9791"
                 href="#FTN.AEN9791"><span
                 class="footnote">[38]</span></a> и удалит
                соответствующие файлы.</p>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Команда <strong
                         class="COMMAND">adduser</strong> является
                        синонимом для <strong
                         class="COMMAND">useradd</strong> и, как
                        правило, является обычной символической ссылкой
                        на <strong
                         class="COMMAND">useradd</strong>.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><a
               name="IDREF"></a><strong
               class="COMMAND">id</strong></dt>

              <dd>
                <p>Команда <strong
                 class="COMMAND">id</strong> выводит идентификатор
                пользователя (реальный и эффективный) и идентификаторы
                групп, в состав которых входит пользователь. По сути --
                выводит содержимое переменных <a
                 href="#UIDREF">$UID</a>, <a
                 href="#EUIDREF">$EUID</a> и <a
                 href="#GROUPSREF">$GROUPS</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>id</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $UID</strong></tt>
<tt
 class="COMPUTEROUTPUT">501</tt>
</pre>

                <p>См. также <a
                 href="#AMIROOT">Пример 9-5</a>.</p>
              </dd>

              <dt><a
               name="WHOREF"></a><strong
               class="COMMAND">who</strong></dt>

              <dd>
                <p>Выводит список пользователей, работающих в настоящий
                момент в системе.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>who</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo  tty1     Apr 27 17:45
 bozo  pts/0    Apr 27 17:46
 bozo  pts/1    Apr 27 17:47
 bozo  pts/2    Apr 27 17:49</tt>
             
</pre>
                <br>
                <br>

                <p>С ключом <tt
                 class="OPTION">-m</tt> -- выводит информацию только о
                текущем пользователе. Если число аргументов,
                передаваемых команде, равно двум, то это эквивалентно
                вызову <strong
                 class="COMMAND">who -m</strong>, например <strong
                 class="COMMAND">who am i</strong> или <strong
                 class="COMMAND">who The Man</strong>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>who -m</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">localhost.localdomain!bozo  pts/2    Apr 27 17:49</tt>
             
</pre>
                <br>
                <br>

                <p><a
                 name="WHOAMIREF"></a><strong
                 class="COMMAND">whoami</strong> -- похожа на <strong
                 class="COMMAND">who -m</strong>, но выводит только имя
                пользователя.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>whoami</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>
             
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">w</strong></dt>

              <dd>
                <p>Выводит информацию о системе, список пользователей,
                подключенных к системе и процессы, связанные с
                пользователями. Это расширенная версия команды <strong
                 class="COMMAND">who</strong>. Вывод от команды <strong
                 class="COMMAND">w</strong> может быть передан по
                конвейеру команде <strong
                 class="COMMAND">grep</strong>, с целью поиска
                требуемого пользователя и/или процесса.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>w | grep startx</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">bozo  tty1     -                 4:22pm  6:41   4.47s  0.45s  startx</tt>
</pre>
              </dd>

              <dt><strong
               class="COMMAND">logname</strong></dt>

              <dd>
                <p>Выводит имя текущего пользователя (из файла <tt
                 class="FILENAME">/var/run/utmp</tt>). Это довольно
                близкий эквивалент команды <a
                 href="#WHOAMIREF">whoami</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>logname</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>whoami</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>
</pre>

                <p>Однако...</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>su</strong></tt>
<tt
 class="COMPUTEROUTPUT">Password: ......</tt>

<tt
 class="PROMPT">bash#</tt> <tt
 class="USERINPUT"><strong>whoami</strong></tt>
<tt
 class="COMPUTEROUTPUT">root</tt>
<tt
 class="PROMPT">bash#</tt> <tt
 class="USERINPUT"><strong>logname</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>
</pre>
              </dd>

              <dt><a
               name="SUREF"></a><strong
               class="COMMAND">su</strong></dt>

              <dd>
                <p>Команда предназначена для запуска программы или
                сценария от имени другого пользователя. <strong
                 class="COMMAND">su rjones</strong> -- запускает
                командную оболочку от имени пользователя <span
                 class="emphasis"><em
                 class="EMPHASIS">rjones</em></span>. Запуск команды
                <strong
                 class="COMMAND">su</strong> без параметров означает
                запуск командной оболочки от имени привилегированного
                пользователя <span
                 class="emphasis"><em
                 class="EMPHASIS">root</em></span>. См. <a
                 href="#FIFO">Пример A-17</a>.</p>
              </dd>

              <dt><strong
               class="COMMAND">sudo</strong></dt>

              <dd>
                <p>Исполняет заданную команду от имени пользователя
                root (или другого пользователя).</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Доступ к &quot;секретным&quot; файлам.
sudo cp /root/secretfile /home/bozo/secret
</pre>
                <br>
                <br>

                <p>Имена пользователей, которым разрешено использовать
                команду <strong
                 class="COMMAND">sudo</strong>, хранятся в файле <tt
                 class="FILENAME">/etc/sudoers</tt>.</p>
              </dd>

              <dt><strong
               class="COMMAND">passwd</strong></dt>

              <dd>
                <p>Устанавливает или изменяет пароль пользователя.</p>

                <p>Команда <strong
                 class="COMMAND">passwd</strong> может использоваться в
                сценариях, но это плохая практика.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
#  set-new-password.sh: Плохая идея.
#  Этот сценарий должен запускаться пользователем root,
#+ а еще лучше -- не запускать его вообще.

ROOT_UID=0         # $UID root = 0.
E_WRONG_USER=65    # Не root?

if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo; echo &quot;Только root может запускать этот сценарий.&quot;; echo
  exit $E_WRONG_USER
else
  echo; echo &quot;Вам не следовало бы запускать этот сценарий.&quot;
fi


username=bozo
NEWPASSWORD=security_violation

echo &quot;$NEWPASSWORD&quot; | passwd --stdin &quot;$username&quot;
#  Ключ &#39;--stdin&#39; указывает &#39;passwd&#39;
#+ получить новый пароль со stdin (или из конвейера).

echo; echo &quot;Пароль пользователя $username изменен!&quot;

# Использование команды &#39;passwd&#39; в сценариях -- опасно.

exit 0
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">ac</strong></dt>

              <dd>
                <p>Выводит время работы пользователей, основываясь на
                записях в файле <tt
                 class="FILENAME">/var/log/wtmp</tt>. Это одна из
                утилит пакета GNU acct.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ac</strong></tt>
 <tt
 class="COMPUTEROUTPUT">       total       68.08</tt>
</pre>
              </dd>

              <dt><strong
               class="COMMAND">last</strong></dt>

              <dd>
                <p>Выводит информацию о <span
                 class="emphasis"><em
                 class="EMPHASIS">последних</em></span> входах/выходах
                пользователей в ситему, основываясь на записях в файле
                <tt
                 class="FILENAME">/var/log/wtmp</tt>. Эта команда может
                отображать информацию об удаленных (в смысле -- с
                удаленного терминала) соединениях.</p>
              </dd>

              <dt><strong
               class="COMMAND">newgrp</strong></dt>

              <dd>
                <p>Позволяет сменить активную группу пользователя.
                Пользователь остается в системе и текущий каталог не
                изменяется, но права доступа к файлам вычисляются в
                соответствии с новыми реальным и эффективным
                идентификаторами группы. Эта команда используется
                довольно редко, так как пользователь, обычно, является
                членом нескольких групп.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="TERMINALSSYS1"></a>Терминалы</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">tty</strong></dt>

              <dd>
                <p>Выводит имя терминала текущего пользователя.
                Обратите внимание: каждое отдельное окно xterm
                считается отдельным терминалом.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>tty</strong></tt>
<tt
 class="COMPUTEROUTPUT">/dev/pts/1</tt>
</pre>
              </dd>

              <dt><a
               name="STTYREF"></a><strong
               class="COMMAND">stty</strong></dt>

              <dd>
                <p>Выводит и/или изменяет настройки терминала. Эта
                сложная команда используется в сценариях для управления
                поведением терминала.</p>

                <div
                 class="EXAMPLE">
                  <a
                   name="ERASE"></a>

                  <p><strong>Пример 13-1. Установка символа
                  &quot;забоя&quot;</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# erase.sh: Использование команды &quot;stty&quot; для смены клавиши &quot;забоя&quot; при чтении ввода.

echo -n &quot;Как Вас зовут? &quot;
read name                      # Попробуйте стереть последние символы при вводе.
                               # Все работает.
echo &quot;Вас зовут $name.&quot;

stty erase &#39;#&#39;                 # Теперь, чтобы стереть символ нужно использовать клавишу &quot;#&quot;.
echo -n &quot;Как Вас зовут? &quot;
read name                      # Попробуйте стереть последние символы при вводе с помощью &quot;#&quot;.
echo &quot;Вас зовут $name.&quot;

exit 0
</pre>
                </div>

                <div
                 class="EXAMPLE">
                  <a
                   name="SECRETPW"></a>

                  <p><strong>Пример 13-2. невидимый пароль: Отключение
                  эхо-вывода на терминал</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo
echo -n &quot;Введите пароль &quot;
read passwd
echo &quot;Вы ввели пароль: $passwd&quot;
echo -n &quot;Если кто-нибудь в это время заглядывал Вам через плечо, &quot;
echo &quot;то теперь он знает Ваш пароль.&quot;

echo &amp;&amp; echo  # Две пустых строки через &quot;and list&quot;.

stty -echo    # Отключить эхо-вывод.

echo -n &quot;Введите пароль еще раз &quot;
read passwd
echo
echo &quot;Вы ввели пароль: $passwd&quot;
echo

stty echo     # Восстановить эхо-вывод.

exit 0
</pre>
                </div>

                <p>Перехват нажатия на клавиши с помощью <strong
                 class="COMMAND">stty</strong>.</p>

                <div
                 class="EXAMPLE">
                  <a
                   name="KEYPRESS"></a>

                  <p><strong>Пример 13-3.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# keypress.sh: Определение нажатых клавиш.

echo

old_tty_settings=$(stty -g)   # Сохранить прежние настройки.
stty -icanon
Keypress=$(head -c1)          # или $(dd bs=1 count=1 2&gt; /dev/null)
                              # для других, не GNU, систем

echo
echo &quot;Была нажата клавиша \&quot;&quot;$Keypress&quot;\&quot;.&quot;
echo

stty &quot;$old_tty_settings&quot;      # Восстановить прежние настройки.

# Спасибо, Stephane Chazelas.

exit 0
</pre>
                </div>

                <p>См. также <a
                 href="#TIMEOUT">Пример 9-3</a>.</p>

                <table
                 class="SIDEBAR"
                 border="1"
                 cellpadding="5">
                  <tr>
                    <td>
                      <div
                       class="SIDEBAR">
                        <a
                         name="AEN10028"></a>

                        <p><strong>терминалы и их режимы
                        работы</strong></p>

                        <p>Как правило, терминалы работают в <span
                         class="emphasis"><em
                         class="EMPHASIS">каноническом</em></span>
                        режиме. Когда пользователь нажимает какую-либо
                        клавишу, то соответствующий ей символ не сразу
                        передается программе, исполняемой в окне
                        терминала. Этот символ поступает сначала в
                        локальный буфер терминала. Когда пользователь
                        нажимает клавишу <strong
                         class="KEYCAP">ENTER</strong>, то тогда все
                        содержимое буфера передается программе.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>stty -a</strong></tt>
<tt
 class="COMPUTEROUTPUT">speed 9600 baud; rows 36; columns 96; line = 0;
intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;
start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O;
...
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt</tt>
               
</pre>
                        <br>
                        <br>

                        <p>В каноническом режиме можно использовать
                        символы редактирования во время ввода.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat &gt; filexxx</strong></tt>
<tt
 class=
"USERINPUT"><strong>wha&lt;ctl-W&gt;I&lt;ctl-H&gt;foo bar&lt;ctl-U&gt;hello world&lt;ENTER&gt;</strong></tt>
<tt
 class="USERINPUT"><strong>&lt;ctl-D&gt;</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat filexxx</strong></tt>
<tt
 class="COMPUTEROUTPUT">hello world</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>bash$ wc -c &lt; file</strong></tt>
<tt
 class="COMPUTEROUTPUT">13</tt>
               
</pre>
                        Процесс в терминале получит только 13 символов
                        (12 алфавитных символов и символ перевода
                        строки), хотя пользователь нажал 26 клавиш.
                        <br>
                        <br>

                        <p>В неканоническом (<span
                         class="QUOTE">&quot;сыром&quot;</span>)
                        режиме, каждая нажатая клавиша (включая
                        специальные символы редактирования, такие как
                        <strong
                         class="KEYCAP">ctl-H</strong>) сразу же
                        передается исполняющемуся в терминале
                        процессу.</p>

                        <p>Под управлением Bash, базовый терминальный
                        редактор заменяется более сложным терминальным
                        редактором Bash. Например, если вы нажмете
                        комбинацию клавиш <strong
                         class="KEYCAP">ctl-A</strong> в командной
                        строке Bash, то вы не увидите символов <strong
                         class="KEYCAP">^A</strong>, которые выводит
                        терминал, вместо этого Bash получит символ
                        <strong
                         class="KEYCAP">\1</strong>, проанализирует его
                        и переместит курсор в начало строки.</p>

                        <p><span
                         class="emphasis"><em
                         class="EMPHASIS">Stephane
                        Chazelas</em></span></p>
                      </div>
                    </td>
                  </tr>
                </table>
              </dd>

              <dt><strong
               class="COMMAND">tset</strong></dt>

              <dd>
                <p>Выводит или изменяет настройки терминала. Это более
                слабая версия <strong
                 class="COMMAND">stty</strong>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>tset -r</strong></tt>
<tt
 class="COMPUTEROUTPUT">Terminal type is xterm-xfree86.
Kill is control-U (^U).
Interrupt is control-C (^C).</tt>
             
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">setserial</strong></dt>

              <dd>
                <p>Настройка параметров последовательного порта. Эта
                команда должна запускаться пользователем, обладающим
                привилегиями root. Эту команду можно встретить в
                сценариях настройки системы.</p>
<pre
 class="PROGRAMLISTING">
# Взято из /etc/pcmcia/serial :

IRQ=`setserial /dev/$DEVICE | sed -e &#39;s/.*IRQ: //&#39;`
setserial /dev/$DEVICE irq 0 ; setserial /dev/$DEVICE irq $IRQ
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">getty</strong>, <strong
               class="COMMAND">agetty</strong></dt>

              <dd>
                <p>Программа <strong
                 class="COMMAND">getty</strong> или <strong
                 class="COMMAND">agetty</strong> запускается процессом
                init и обслуживает процедуру входа пользователя в
                систему. Эти команды не используются в сценариях.</p>
              </dd>

              <dt><a
               name="MESGREF"></a><strong
               class="COMMAND">mesg</strong></dt>

              <dd>
                <p>Разрешает или запрещает доступ к терминалу текущего
                пользователя командой <a
                 href="#WRITEREF">write</a>.</p>

                <div
                 class="TIP">
                  <table
                   class="TIP"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/tip.gif"
                       hspace="5"
                       alt="Tip"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Наверное это очень неприятно, когда, во
                        время работы над текстовым файлом, в окне
                        терминала, прямо среди текста, вдруг появляется
                        предложение заказать пиццу. Поэтому, при работе
                        в многопользовательской системе, вам наверняка
                        захочется отключить доступ к своему
                        терминалу.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">wall</strong></dt>

              <dd>
                <p>Имя этой команды -- аббревиатура от <span
                 class="QUOTE">&quot;<a
                 href="#WRITEREF">write</a> all&quot;</span>, т.е.,
                передать сообщение всем пользователям на все терминалы
                в сети. Это, в первую очередь, инструмет
                администратора, который можно использовать, например,
                для оповещения всех пользователей о предстоящей, в
                ближайшее время, перезагрузке системы (см. <a
                 href="#EX70">Пример 17-2</a>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>wall System going down for maintenance in 5 minutes!</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Broadcast message from bozo (pts/1) Sun Jul  8 13:53:27 2001...

 System going down for maintenance in 5 minutes!</tt>
             
</pre>
                <br>
                <br>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Если доступ к терминалу был закрыт командой
                        <strong
                         class="COMMAND">mesg</strong>, то сообщение на
                        этом терминале выводиться не будет.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">dmesg</strong></dt>

              <dd>
                <p>Выводит все сообщения, выдаваемые системой во время
                загрузки на <tt
                 class="FILENAME">stdout</tt>. Очень полезная утилита
                для отладочных целей. Вывод <strong
                 class="COMMAND">dmesg</strong> может анализироваться с
                помощью <a
                 href="#GREPREF">grep</a>, <a
                 href="#SEDREF">sed</a> или <a
                 href="#AWKREF">awk</a> внутри сценария.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>dmesg | grep hda</strong></tt>
<tt
 class="COMPUTEROUTPUT">Kernel command line: ro root=/dev/hda2
 hda: IBM-DLGA-23080, ATA DISK drive
 hda: 6015744 sectors (3080 MB) w/96KiB Cache, CHS=746/128/63
 hda: hda1 hda2 hda3 &lt; hda5 hda6 hda7 &gt; hda4</tt>
             
</pre>
                <br>
                <br>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="STATISTICSSYS1"></a>Информационные и статистические
            утилиты</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">uname</strong></dt>

              <dd>
                <p>Выводит на <tt
                 class="FILENAME">stdout</tt> имя системы. С ключом <tt
                 class="OPTION">-a</tt>, выводит подробную информацию,
                содержащую имя системы, имя узла (то есть имя, под
                которым система известна в сети), версию операционной
                системы, наименование модификации операционной системы,
                аппаратную архитектуру (см. <a
                 href="#EX41">Пример 12-4</a>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uname -a</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Linux localhost.localdomain 2.2.15-2.5.0 #1 Sat Feb 5 00:13:43 EST 2000 i686 unknown</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uname -s</strong></tt>
<tt
 class="COMPUTEROUTPUT">Linux</tt>
</pre>
              </dd>

              <dt><strong
               class="COMMAND">arch</strong></dt>

              <dd>
                <p>Выводит тип аппаратной платформы компьютерв.
                Эквивалентна команде <strong
                 class="COMMAND">uname -m</strong>. См. <a
                 href="#CASECMD">Пример 10-26</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>arch</strong></tt>
<tt
 class="COMPUTEROUTPUT">i686</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uname -m</strong></tt>
<tt
 class="COMPUTEROUTPUT">i686</tt>
</pre>
              </dd>

              <dt><strong
               class="COMMAND">lastcomm</strong></dt>

              <dd>
                <p>Выводит информацию, о ранее выполненных командах, из
                файла <tt
                 class="FILENAME">/var/account/pacct</tt>.
                Дополнительно могут указываться команда и пользователь.
                Это одна из утилит пакета GNU acct.</p>
              </dd>

              <dt><strong
               class="COMMAND">lastlog</strong></dt>

              <dd>
                <p>Выводит список всех пользователей, с указанием
                времени последнего входа в систему. Данные берутся из
                файла <tt
                 class="FILENAME">/var/log/lastlog</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lastlog</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">root          tty1                      Fri Dec  7 18:43:21 -0700 2001
 bin                                     **Never logged in**
 daemon                                  **Never logged in**
 ...
 bozo          tty1                      Sat Dec  8 21:14:29 -0700 2001</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lastlog | grep root</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">root          tty1                      Fri Dec  7 18:43:21 -0700 2001</tt>
             
</pre>
                <br>
                <br>

                <div
                 class="CAUTION">
                  <table
                   class="CAUTION"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/caution.gif"
                       hspace="5"
                       alt="Caution"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Исполнение этой команды будет завершаться
                        неудачей, если пользователь, вызвавший утилиту,
                        не имеет прав на чтение файла <tt
                         class="FILENAME">/var/log/lastlog</tt>.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">lsof</strong></dt>

              <dd>
                <p>Выводит детальный список открытых, в настоящий
                момент времени, файлов в виде таблицы. В таблице
                указаны -- владелец файла, размер файла, тип файла,
                процесс, открывший файл, и многое другое. Само собой
                разумеется, что вывод команды <strong
                 class="COMMAND">lsof</strong> может быть обработан, в
                конвейере, с помощью утилит <a
                 href="#GREPREF">grep</a> и/или <a
                 href="#AWKREF">awk</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lsof</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">COMMAND    PID    USER   FD   TYPE     DEVICE    SIZE     NODE NAME
 init         1    root  mem    REG        3,5   30748    30303 /sbin/init
 init         1    root  mem    REG        3,5   73120     8069 /lib/ld-2.1.3.so
 init         1    root  mem    REG        3,5  931668     8075 /lib/libc-2.1.3.so
 cardmgr    213    root  mem    REG        3,5   36956    30357 /sbin/cardmgr
 ...</tt>
             
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">strace</strong></dt>

              <dd>
                <p>Диагностическая и отладочная утилита,
                предназначенная для трассировки системных вызовов и
                сигналов. В простейшем случае, запускается как: <strong
                 class="COMMAND">strace COMMAND</strong>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>strace df</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">execve(&quot;/bin/df&quot;, [&quot;df&quot;], [/* 45 vars */]) = 0
 uname({sys=&quot;Linux&quot;, node=&quot;bozo.localdomain&quot;, ...}) = 0
 brk(0)                                  = 0x804f5e4
 ...</tt>
           
</pre>
                <br>
                <br>

                <p>Эквивалентна команде <strong
                 class="COMMAND">truss</strong>.</p>
              </dd>

              <dt><strong
               class="COMMAND">nmap</strong></dt>

              <dd>
                <p>Сканер сетевых портов. Эта утилита сканирует сервер
                в поисках открытых портов и сервисов. Это очень важный
                инструмент, используемый для поиска уязвимостей при
                настройке системы.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

SERVER=$HOST                           # localhost.localdomain (127.0.0.1).
PORT_NUMBER=25                         # порт службы SMTP.

nmap $SERVER | grep -w &quot;$PORT_NUMBER&quot;  # Проверить -- открыт ли данный порт?
#              grep -w -- поиск только целых слов,
#+             так, например, порт 1025 будет пропущен.

exit 0

# 25/tcp     open        smtp
</pre>
                <br>
                <br>
              </dd>

              <dt><a
               name="FREEREF"></a><strong
               class="COMMAND">free</strong></dt>

              <dd>
                <p>Показывает информацию об использовании памяти, в
                табличной форме. Вывод команды может быть
                проанализирован с помощью <a
                 href="#GREPREF">grep</a>, <a
                 href="#AWKREF">awk</a> или <strong
                 class="COMMAND">Perl</strong>. Команда <strong
                 class="COMMAND">procinfo</strong> тоже выводит эту
                информацию, среди всего прочего.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">free</strong>
 <tt
 class=
"COMPUTEROUTPUT">               total       used       free     shared    buffers     cached
   Mem:         30504      28624       1880      15820       1608       16376
   -/+ buffers/cache:      10640      19864
   Swap:        68540       3128      65412</tt>
</pre>

                <p>Показать размер неиспользуемой памяти RAM:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">free | grep Mem | awk &#39;{ print $4 }&#39;</strong>
<tt
 class="COMPUTEROUTPUT">1880</tt>
</pre>
              </dd>

              <dt><a
               name="PROCINFOREF"></a><strong
               class="COMMAND">procinfo</strong></dt>

              <dd>
                <p>Извлекает и выводит информацию из <a
                 href="#DEVPROCREF">файловой системы <tt
                 class="FILENAME">/proc</tt></a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>procinfo | grep Bootup</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Bootup: Wed Mar 21 15:15:50 2001    Load average: 0.04 0.21 0.34 3/47 6829</tt>
</pre>
              </dd>

              <dt><a
               name="LSDEVREF"></a><strong
               class="COMMAND">lsdev</strong></dt>

              <dd>
                <p>Список аппаратных устройств в системе.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lsdev</strong></tt>
<tt
 class="COMPUTEROUTPUT">Device            DMA   IRQ  I/O Ports
 ------------------------------------------------
 cascade             4     2
 dma                          0080-008f
 dma1                         0000-001f
 dma2                         00c0-00df
 fpu                          00f0-00ff
 ide0                     14  01f0-01f7 03f6-03f6
 ...</tt>
             
</pre>
                <br>
                <br>
              </dd>

              <dt><a
               name="DUREF"></a><strong
               class="COMMAND">du</strong></dt>

              <dd>
                <p>Выводит сведения о занимаемом дисковом пространстве
                в каталоге и вложенных подкаталогах. Если каталог не
                указан, то по-умолчанию выводятся сведения о текущем
                каталоге.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">du -ach</strong>
<tt
 class="COMPUTEROUTPUT">1.0k    ./wi.sh
 1.0k    ./tst.sh
 1.0k    ./random.file
 6.0k    .
 6.0k    total</tt>
</pre>
              </dd>

              <dt><a
               name="DFREF"></a><strong
               class="COMMAND">df</strong></dt>

              <dd>
                <p>Выводит в табличной форме сведения о смонтированных
                файловых системах.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">df</strong>
<tt
 class=
"COMPUTEROUTPUT">Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/hda5               273262     92607    166547  36% /
/dev/hda8               222525    123951     87085  59% /home
/dev/hda7              1408796   1075744    261488  80% /usr</tt>
</pre>
              </dd>

              <dt><strong
               class="COMMAND">stat</strong></dt>

              <dd>
                <p>Дает подробную информацию о заданном файле (каталоге
                или файле устройства) или наборе файлов.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>stat test.cru</strong></tt>
 <tt
 class="COMPUTEROUTPUT"> File: &quot;test.cru&quot;
   Size: 49970        Allocated Blocks: 100          Filetype: Regular File
   Mode: (0664/-rw-rw-r--)         Uid: (  501/ bozo)  Gid: (  501/ bozo)
 Device:  3,8   Inode: 18185     Links: 1
 Access: Sat Jun  2 16:40:24 2001
 Modify: Sat Jun  2 16:40:24 2001
 Change: Sat Jun  2 16:40:24 2001</tt>
             
</pre>
                <br>
                <br>

                <p>Если заданный файл отсутствует, то <strong
                 class="COMMAND">stat</strong> вернет сообщение об
                ошибке.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>stat nonexistent-file</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">nonexistent-file: No such file or directory</tt>
             
</pre>
                <br>
                <br>
              </dd>

              <dt><a
               name="VMSTATREF"></a><strong
               class="COMMAND">vmstat</strong></dt>

              <dd>
                <p>Выводит информацию о виртуальной памяти.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>vmstat</strong></tt>
 <tt
 class=
"COMPUTEROUTPUT">  procs                      memory    swap          io system         cpu
 r  b  w   swpd   free   buff  cache  si  so    bi    bo   in    cs  us  sy id
 0  0  0      0  11040   2636  38952   0   0    33     7  271    88   8   3 89</tt>
           
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">netstat</strong></dt>

              <dd>
                <p>Показывает сведения о сетевой подсистеме, такие как:
                таблицы маршрутизации и активные соединения. Эта
                утилита получает сведения из <tt
                 class="FILENAME">/proc/net</tt> (<a
                 href="#DEVPROC">Глава 27</a>). См. <a
                 href="#CONSTAT">Пример 27-2</a>.</p>

                <p><strong
                 class="COMMAND">netstat -r</strong> -- эквивалентна
                команде <a
                 href="#ROUTEREF">route</a>.</p>
              </dd>

              <dt><a
               name="UPTIMEREF"></a><strong
               class="COMMAND">uptime</strong></dt>

              <dd>
                <p>Показывает количество времени, прошедшего с момента
                последней перезагрузки системы.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uptime</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">10:28pm  up  1:57,  3 users,  load average: 0.17, 0.34, 0.27</tt>
</pre>
              </dd>

              <dt><a
               name="HNAMEREF"></a><strong
               class="COMMAND">hostname</strong></dt>

              <dd>
                <p>Выводит имя узла (сетевое имя системы). С помощью
                этой команды устанавливается сетевое имя системы в
                сценарии <tt
                 class="FILENAME">/etc/rc.d/rc.sysinit</tt>.
                Эквивалентна команде <strong
                 class="COMMAND">uname -n</strong> и внутренней
                переменной <a
                 href="#HOSTNAMEREF">$HOSTNAME</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>hostname</strong></tt>
<tt
 class="COMPUTEROUTPUT">localhost.localdomain</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $HOSTNAME</strong></tt>
<tt
 class="COMPUTEROUTPUT">localhost.localdomain</tt>
</pre>
              </dd>

              <dt><a
               name="HOSTIDREF"></a><strong
               class="COMMAND">hostid</strong></dt>

              <dd>
                <p>Выводит 32-битный шестнадцатиричный идентификатор
                системы.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>hostid</strong></tt>
<tt
 class="COMPUTEROUTPUT">7f0100</tt>
</pre>
                <br>
                <br>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Эта команда генерирует <span
                         class="QUOTE">&quot;уникальный&quot;</span>
                        числовой идентификатор системы. Некоторые
                        программные продукты используют этот
                        идентификатор в процедуре регистрации. К
                        сожалению, при генерации идентификатора,
                        <strong
                         class="COMMAND">hostid</strong> использует
                        только IP адрес системы, переводя его в
                        шестнадцатиричное представление и переставляя
                        местами пары байт.</p>

                        <p>Обычно, IP адрес системы можно найти в файле
                        <tt
                         class="FILENAME">/etc/hosts</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /etc/hosts</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">127.0.0.1               localhost.localdomain localhost</tt>
</pre>
                        <br>
                        <br>

                        <p>Переставив местами байты, попарно, в
                        начальном адресе <tt
                         class=
                        "USERINPUT"><strong>127.0.0.1</strong></tt>, мы
                        получим <tt
                         class=
                        "USERINPUT"><strong>0.127.1.0</strong></tt>, в
                        шестнадцатиричном представлении это будет <tt
                         class=
                        "USERINPUT"><strong>007f0100</strong></tt>, что
                        в точности совпадает с приведенным выше
                        результатом выполнения <strong
                         class="COMMAND">hostid</strong>. Наверняка
                        можно найти несколько миллионов компьютеров с
                        таким же <span
                         class="QUOTE">&quot;уникальным&quot;</span>
                        идентификатором.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">sar</strong></dt>

              <dd>
                <p>Команда <strong
                 class="COMMAND">sar</strong> (system activity report)
                выводит очень подробную статистику о функционировании
                операционной системы. Эту команду можно найти в
                отдельных коммерческих дистрибутивах UNIX-систем. Она,
                как правило, не входит в базовый комплект пакетов
                Linux-систем. Она входит в состав пакета <a
                 href="http://perso.wanadoo.fr/sebastien.godard/"
                 target="_top">sysstat utilities</a>, автор: <a
                 href="mailto:sebastien.godard@wanadoo.fr"
                 target="_top">Sebastien Godard</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>sar</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Linux 2.4.7-10 (localhost.localdomain)         12/31/2001

 10:30:01 AM       CPU     %user     %nice   %system     %idle
 10:40:00 AM       all      1.39      0.00      0.77     97.84
 10:50:00 AM       all     76.83      0.00      1.45     21.72
 11:00:00 AM       all      1.32      0.00      0.69     97.99
 11:10:00 AM       all      1.17      0.00      0.30     98.53
 11:20:00 AM       all      0.51      0.00      0.30     99.19
 06:30:00 PM       all    100.00      0.00    100.01      0.00
 Average:          all      1.39      0.00      0.66     97.95</tt>
          
</pre>
              </dd>

              <dt><strong
               class="COMMAND">readelf</strong></dt>

              <dd>
                <p>Показывает сведения о заданном бинарном файле
                формата <span
                 class="emphasis"><em
                 class="EMPHASIS">elf</em></span>. Входит в состав
                пакета <span
                 class="emphasis"><em
                 class="EMPHASIS">binutils</em></span>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>readelf -h /bin/bash</strong></tt>
<tt
 class="COMPUTEROUTPUT">ELF Header:
   Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
   Class:                             ELF32
   Data:                              2&#39;s complement, little endian
   Version:                           1 (current)
   OS/ABI:                            UNIX - System V
   ABI Version:                       0
   Type:                              EXEC (Executable file)
   . . .</tt>
</pre>
              </dd>

              <dt><strong
               class="COMMAND">size</strong></dt>

              <dd>
                <p>Команда <strong
                 class="COMMAND">size [/path/to/binary]</strong>
                выведет информацию о размерах различных сегментов в
                исполняемых или библиотечных файлах. В основном
                используется программистами.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>size /bin/bash</strong></tt>
 <tt
 class="COMPUTEROUTPUT">  text    data     bss     dec     hex filename
  495971   22496   17392  535859   82d33 /bin/bash</tt>
             
</pre>
                <br>
                <br>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="SYSLOG1"></a>Системный журнал</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">logger</strong></dt>

              <dd>
                <p>Добавляет в системный журнал (<tt
                 class="FILENAME">/var/log/messages</tt>) сообщение от
                пользователя. Для добавления сообщения пользователь не
                должен обладать привилегиями суперпользователя.</p>
<pre
 class="PROGRAMLISTING">
logger Experiencing instability in network connection at 23:10, 05/21.
# Теперь попробуйте дать команду &#39;tail /var/log/messages&#39;.
</pre>
                <br>
                <br>

                <p>Встраивая вызов <strong
                 class="COMMAND">logger</strong> в сценарии, вы
                получаете возможность заносить отладочную информацию в
                системный журнал <tt
                 class="FILENAME">/var/log/messages</tt>.</p>
<pre
 class="PROGRAMLISTING">
logger -t $0 -i Logging at line &quot;$LINENO&quot;.
# Ключ &quot;-t&quot; задает тэг записи в журнале.
# Ключ &quot;-i&quot; -- записывает ID процесса.

# tail /var/log/message
# ...
# Jul  7 20:48:58 localhost ./test.sh[1712]: Logging at line 3.
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">logrotate</strong></dt>

              <dd>
                <p>Эта утилита производит манипуляции над системным
                журналом: ротация, сжатие, удаление и/или отправляет
                его по электронной почте, по мере необходимости. Как
                правило, утилита <strong
                 class="COMMAND">logrotate</strong> вызывается демоном
                <a
                 href="#CRONREF">crond</a> ежедневно.</p>

                <p>Добавляя соответствующие строки в <tt
                 class="FILENAME">/etc/logrotate.conf</tt>, можно
                заставить <strong
                 class="COMMAND">logrotate</strong> обрабатывать не
                только системный журнал, но и ваш личный.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="JOBCONTROLSYS1"></a>Управление
            заданиями</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">ps</strong></dt>

              <dd>
                <p><tt
                 class="REPLACEABLE"><em>P</em></tt>rocess <tt
                 class="REPLACEABLE"><em>S</em></tt>tatistics: Список
                исполняющихся в данный момент процессов. Обычно
                вызывается с ключами <tt
                 class="OPTION">ax</tt>, вывод команды может быть
                обработан командами <a
                 href="#GREPREF">grep</a> или <a
                 href="#SEDREF">sed</a>, с целью поиска требуемого
                процесса (см. <a
                 href="#EX44">Пример 11-10</a> и <a
                 href="#PIDID">Пример 27-1</a>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ps ax | grep sendmail</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">295 ?     S      0:00 sendmail: accepting connections on port 25</tt>
</pre>
              </dd>

              <dt><strong
               class="COMMAND">pstree</strong></dt>

              <dd>
                <p>Список исполняющихся процессов в виде <span
                 class="QUOTE">&quot;дерева&quot;</span>. С ключом <tt
                 class="OPTION">-p</tt> -- вместе с именами процессов
                отображает их PID.</p>
              </dd>

              <dt><strong
               class="COMMAND">top</strong></dt>

              <dd>
                <p>Выводит список наиболее активных процессов. С ключом
                <tt
                 class="OPTION">-b</tt> -- отображение ведется в
                обычном текстовом режиме, что дает возможность анализа
                вывода от команды внутри сценария.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>top -b</strong></tt>
 <tt
 class=
"COMPUTEROUTPUT"> 8:30pm  up 3 min,  3 users,  load average: 0.49, 0.32, 0.13
 45 processes: 44 sleeping, 1 running, 0 zombie, 0 stopped
 CPU states: 13.6% user,  7.3% system,  0.0% nice, 78.9% idle
 Mem:    78396K av,   65468K used,   12928K free,       0K shrd,    2352K buff
 Swap:  157208K av,       0K used,  157208K free                   37244K cached

   PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND
   848 bozo      17   0   996  996   800 R     5.6  1.2   0:00 top
     1 root       8   0   512  512   444 S     0.0  0.6   0:04 init
     2 root       9   0     0    0     0 SW    0.0  0.0   0:00 keventd
   ...</tt>
             
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">nice</strong></dt>

              <dd>
                <p>Запускает фоновый процесс с заданным приоритетом.
                Приоритеты могут задаваться числом из диапазона от 19
                (низший приоритет) до -20 (высший приоритет). Но только
                <span
                 class="emphasis"><em
                 class="EMPHASIS">root</em></span> может указать
                значение приоритета меньше нуля (отрицательные
                значения). См. так же команды <strong
                 class="COMMAND">renice</strong>, <strong
                 class="COMMAND">snice</strong> и <strong
                 class="COMMAND">skill</strong>.</p>
              </dd>

              <dt><strong
               class="COMMAND">nohup</strong></dt>

              <dd>
                <p>Запуск команд в режиме игнорирования сигналов
                прерывания и завершения, что предотвращает завершение
                работы команды даже если пользователь, запустивший ее,
                вышел из системы. Если после команды не указан символ
                <span
                 class="TOKEN">&amp;</span>, то она будет исполняться
                как процесс &quot;переднего плана&quot;. Если вы
                собираетесь использовать <strong
                 class="COMMAND">nohup</strong> в сценариях, то вам
                потребуется использовать его в связке с командой <a
                 href="#WAITREF">wait</a>, чтобы не породить процесс
                &quot;зомби&quot;.</p>
              </dd>

              <dt><a
               name="PIDOFREF"></a><strong
               class="COMMAND">pidof</strong></dt>

              <dd>
                <p>Возвращает идентификатор процесса <span
                 class="emphasis"><em
                 class="EMPHASIS">(pid)</em></span> по его имени.
                Поскольку многие команды управления процессами, такие
                как <a
                 href="#KILLREF">kill</a> и <strong
                 class="COMMAND">renice</strong>, требуют указать <span
                 class="emphasis"><em
                 class="EMPHASIS">pid</em></span> процесса, а не его
                имя, то <strong
                 class="COMMAND">pidof</strong> может сослужить
                неплохую службу при идентификации процесса по его
                имени. Эта коменда может рассматриваться как
                приблизительный эквивалент внутренней переменной <a
                 href="#PPIDREF">$PPID</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>pidof xclock</strong></tt>
<tt
 class="COMPUTEROUTPUT">880</tt>
             
</pre>
                <br>
                <br>

                <div
                 class="EXAMPLE">
                  <a
                   name="KILLPROCESS"></a>

                  <p><strong>Пример 13-4. Использование команды pidof
                  при остановке процесса</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# kill-process.sh

NOPROCESS=2

process=xxxyyyzzz  # Несуществующий процесс.
# Только в демонстрационных целях...
# ... чтобы не уничтожить этим сценарием какой-нибудь процесс.
#
# Если с помощью этого сценария вы задумаете разрыватть связь с Internet, то
#     process=pppd

t=`pidof $process`       # Поиск pid (process id) процесса $process.
# pid требует команда &#39;kill&#39; (невозможно остановить процесс, указав его имя).

if [ -z &quot;$t&quot; ]           # Если процесс с таким именем не найден, то &#39;pidof&#39; вернет null.
then
  echo &quot;Процесс $process не найден.&quot;
  exit $NOPROCESS
fi

kill $t                  # В некоторых случаях может потребоваться &#39;kill -9&#39;.

# Здесь нужно проверить -- был ли уничтожен процесс.
# Возможно так: &quot; t=`pidof $process` &quot;.


# Этот сценарий мог бы быть заменен командой
#    kill $(pidof -x process_name)
# но это было бы не так поучительно.

exit 0
</pre>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">fuser</strong></dt>

              <dd>
                <p>Возвращает идентификаторы процессов, использующих
                указанный файл(ы) или каталог. С ключом <tt
                 class="OPTION">-k</tt>, завершает найденные процессы.
                Может с успехом использоваться для защиты системы,
                особенно в сценариях разграничения доступа к системным
                службам.</p>
              </dd>

              <dt><a
               name="CRONREF"></a><strong
               class="COMMAND">crond</strong></dt>

              <dd>
                <p>Планировщик заданий. С его помощью выполняются такие
                задачи, как очистка и удаление устаревших файлов
                системных журналов, обновление базы данных <span
                 class="DATABASE">slocate</span>. Это
                суперпользовательская версия команды <a
                 href="#ATREF">at</a> (хотя любой пользователь может
                создать собственную таблицу <tt
                 class="FILENAME">crontab</tt>). Эта утилита
                запускается как фоновый процесс-<a
                 href="#DAEMONREF">daemon</a> и выполняет задания,
                находящиеся в файле <tt
                 class="FILENAME">/etc/crontab</tt>.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="RUNCONTROLSYS1"></a>Команды управления процессами и
            загрузкой</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">init</strong></dt>

              <dd>
                <p><strong
                 class="COMMAND">init</strong> -- <a
                 href="#FORKREF">предок (родитель)</a> всех процессов в
                системе. Вызывается на последнем этапе загрузки системы
                и определяет уровень загрузки (runlevel) из файла <tt
                 class="FILENAME">/etc/inittab</tt>.</p>
              </dd>

              <dt><strong
               class="COMMAND">telinit</strong></dt>

              <dd>
                <p>Символическая ссылка на <strong
                 class="COMMAND">init</strong> -- инструмент для смены
                уровня загрузки (runlevel), как правило используется
                при обслуживании системы или восстановлении файловой
                системы. Может быть вызвана только суперпользователем.
                Эта команда может быть очень опасна, при неумелом
                обращении -- прежде чем использовать ее, убедитесь в
                том, что вы совершенно точно понимаете что делаете!</p>
              </dd>

              <dt><strong
               class="COMMAND">runlevel</strong></dt>

              <dd>
                <p>Выводит предыдущий и текущий уровни загрузки
                (runlevel). Уровень загрузки может иметь одно из 6
                значений: <tt
                 class="LITERAL">0</tt> -- остановка системы, <tt
                 class="LITERAL">1</tt> -- однопользовательский режим,
                <tt
                 class="LITERAL">2</tt> или <tt
                 class="LITERAL">3</tt> -- многопользовательский режим,
                <tt
                 class="LITERAL">5</tt> -- многопользовательский режим
                и запуск X Window, <tt
                 class="LITERAL">6</tt> -- перезагрузка. Уровни
                загрузки определяются из файла <tt
                 class="FILENAME">/var/run/utmp</tt>.</p>
              </dd>

              <dt><strong
               class="COMMAND">halt</strong>, <strong
               class="COMMAND">shutdown</strong>, <strong
               class="COMMAND">reboot</strong></dt>

              <dd>
                <p>Набор команд для остановки системы, обычно перед
                выключением питания.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="NETWORKSYS1"></a>Команды для работы с
            сетью</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">ifconfig</strong></dt>

              <dd>
                <p>Утилита конфигурирования и запуска сетевых
                интерфейсов. Чаще всего используется в сценариях
                начальной загрузки системы, для настройки и запуска
                сетевых интерфейсов или для их остановки перед
                остановкой или перезагрузкой.</p>
<pre
 class="PROGRAMLISTING">
# Фрагменты кода из /etc/rc.d/init.d/network

# ...

# Проверка сетевой полсистемы.
[ ${NETWORKING} = &quot;no&quot; ] &amp;&amp; exit 0

[ -x /sbin/ifconfig ] || exit 0

# ...

for i in $interfaces ; do
  if ifconfig $i 2&gt;/dev/null | grep -q &quot;UP&quot; &gt;/dev/null 2&gt;&amp;1 ; then
    action &quot;Останавливается $i: &quot; ./ifdown $i boot
  fi
# Ключ &quot;-q&quot;, характерный для GNU-версии &quot;grep&quot;, означает &quot;quiet&quot; (&quot;молча&quot;), т.е. подавляет вывод.
# Поэтому нет необходимости переадресовывать вывод на /dev/null.

# ...

echo &quot;В настоящее время активны устройства:&quot;
echo `/sbin/ifconfig | grep ^[a-z] | awk &#39;{print $1}&#39;`
#                            ^^^^^  скобки необходимы для предотвращения подстановки имен файлов (globbing).
#  Следующий код делает то же самое.
#    echo $(/sbin/ifconfig | awk &#39;/^[a-z]/ { print $1 })&#39;
#    echo $(/sbin/ifconfig | sed -e &#39;s/ .*//&#39;)
#  Спасибо S.C. за комментарии.
</pre>
                См. также <a
                 href="#ONLINE">Пример 29-6</a>.<br>
                <br>
              </dd>

              <dt><a
               name="ROUTEREF"></a><strong
               class="COMMAND">route</strong></dt>

              <dd>
                <p>Выводит сведения о таблице маршрутизации ядра или
                вносит туда изменения.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>route</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
 pm3-67.bozosisp *               255.255.255.255 UH       40 0          0 ppp0
 127.0.0.0       *               255.0.0.0       U        40 0          0 lo
 default         pm3-67.bozosisp 0.0.0.0         UG       40 0          0 ppp0</tt>
             
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">chkconfig</strong></dt>

              <dd>
                <p>Проверка сетевой конфигурации. Обслуживает список,
                запускаемых на этапе загрузки, сетевых сервисов, список
                сервисов хранится в каталогах <tt
                 class="FILENAME">/etc/rc?.d</tt> (строго говоря,
                chkconfig работает не только с сетевыми сервисами, а с
                сервисами вообще, не зависимо от того сетевые это
                службы или нет. прим. перев.).</p>

                <p>Изначально эта утилита была перенесена в Red Hat
                Linux из ОС IRIX, <strong
                 class="COMMAND">chkconfig</strong> входит в состав
                далеко не всех дистрибутивов Linux.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>chkconfig --list</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">atd             0:off   1:off   2:off   3:on    4:on    5:on    6:off
rwhod           0:off   1:off   2:off   3:off   4:off   5:off   6:off
 ...</tt>
             
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">tcpdump</strong></dt>

              <dd>
                <p><span
                 class="QUOTE">&quot;Сниффер&quot;</span> (<span
                 class="QUOTE">&quot;sniffer&quot;</span>) сетевых
                пакетов. Инструмент для перехвата и анализа сетевого
                трафика по определенным критериям.</p>

                <p>Дамп трафика ip-пакетов между двумя узлами сети --
                <span
                 class="emphasis"><em
                 class="EMPHASIS">bozoville</em></span> и <span
                 class="emphasis"><em
                 class="EMPHASIS">caduceus</em></span>:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>tcpdump ip host bozoville and caduceus</strong></tt>
             
</pre>
                <br>
                <br>

                <p>Конечно же, вывод команды <strong
                 class="COMMAND">tcpdump</strong> может быть
                проанализирован с помощью <a
                 href="#TPCOMMANDLISTING1">команд обработки текста</a>,
                обсуждавшихся выше.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="FILESYSTEMSYS1"></a>Команды для работы с файловыми
            системами</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">mount</strong></dt>

              <dd>
                <p>Выполняет монтирование файловой системы, обычно на
                устройстве со сменными носителями, такими как дискеты
                или CDROM. Файл <tt
                 class="FILENAME">/etc/fstab</tt> содержит перечень
                доступных для монтирования файловых систем, разделов и
                устройств, включая опции монтирования, благодаря этому
                файлу, монтирование может производиться автоматически
                или вручеую. Файл <tt
                 class="FILENAME">/etc/mtab</tt> содержит список
                смонтированных файловых систем и разделов (включая
                виртуальные, такие как <tt
                 class="FILENAME">/proc</tt>).</p>

                <p><strong
                 class="COMMAND">mount -a</strong> -- монтирует все
                (all) файловые системы и разделы, перечисленные в <tt
                 class="FILENAME">/etc/fstab</tt>, за исключением тех,
                которые имеют флаг <tt
                 class="OPTION">noauto</tt>. Эту команду можно
                встретить в сценариях начальной загрузки системы из <tt
                 class="FILENAME">/etc/rc.d</tt> (<tt
                 class="FILENAME">rc.sysinit</tt> или нечто
                похожее).</p>
<pre
 class="PROGRAMLISTING">
mount -t iso9660 /dev/cdrom /mnt/cdrom
# Монтирование CDROM-а
mount /mnt/cdrom
# Более короткий и удобный вариант, если точка монтирования /mnt/cdrom описана в /etc/fstab
</pre>
                <br>
                <br>

                <p>Эта команда может даже смонтировать обычный файл как
                блочное устройство. Достигается это за счет связывания
                файла с <a
                 href="#LOOPBACKREF">loopback-устройством</a>. Эту
                возможность можно использовать для проверки ISO9660
                образа компакт-диска перед его записью на болванку. <a
                 name="AEN10873"
                 href="#FTN.AEN10873"><span
                 class="footnote">[39]</span></a></p>

                <div
                 class="EXAMPLE">
                  <a
                   name="ISOMOUNTREF"></a>

                  <p><strong>Пример 13-5. Проверка образа
                  CD</strong></p>
<pre
 class="PROGRAMLISTING">
# С правами root...

mkdir /mnt/cdtest  # Подготовка точки монтирования.

mount -r -t iso9660 -o loop cd-image.iso /mnt/cdtest   # Монтирование образа диска.
#             ключ &quot;-o loop&quot; эквивалентен &quot;losetup /dev/loop0&quot;
cd /mnt/cdtest     # Теперь проверим образ диска.
ls -alR            # Вывод списка файлов
</pre>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">umount</strong></dt>

              <dd>
                <p>Отмонтирует смонтированную файловую систему. Перед
                тем как физически вынуть компакт-диск или дискету из
                устройства, это устройство должно быть отмонтировано
                командой <strong
                 class="COMMAND">umount</strong>, иначе файловая
                система может оказаться поврежденной (особенно это
                относится к накопителям на гибких магнитных дисках,
                прим. перев.).</p>
<pre
 class="PROGRAMLISTING">
umount /mnt/cdrom
# Теперь вы можете извлечь диск из привода.
</pre>
                <br>
                <br>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Утилита <strong
                         class="COMMAND">automount</strong>, если она
                        установлена, может выполнять атоматическое
                        монтирование/размонтирование устройств со
                        сменными носителями, такие как дискеты и
                        компакт-диски. На ноутбуках со сменными
                        устройствами FDD и CDROM, такой подход может
                        привести к возникновению определенных
                        проблем.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">sync</strong></dt>

              <dd>
                <p>Принудительный сброс содержимого буферов на жесткий
                диск (синхронизация содержимого буферов ввода-вывода и
                устройства-носителя). Несмотря на то, что нет такой уж
                острой необходимости в этой утилите, тем не менее
                <strong
                 class="COMMAND">sync</strong> придает уверенности
                системным администраторам или пользователям в том, что
                их данные будут сохранены на жестком диске, и не будут
                потеряны в случае какого-либо сбоя. В былые дни,
                команда <tt
                 class="USERINPUT"><strong>sync; sync</strong></tt>
                (дважды -- для абсолютной уверенности) была упреждающей
                мерой перед перезагрузкой системы.</p>

                <p>Иногда возникает необходимость принудительной
                синхронизации буферов ввода-вывода с содержимым на
                магнитном носителе, как, например, при надежном
                удалении файла (см. <a
                 href="#BLOTOUT">Пример 12-42</a>) или когда
                наблюдаются скачки напряжения в сети
                электроснабжения.</p>
              </dd>

              <dt><a
               name="LOSETUPREF"></a><strong
               class="COMMAND">losetup</strong></dt>

              <dd>
                <p>Устанавливает и конфигурирует <a
                 href="#LOOPBACKREF">loopback-устройства</a>.</p>

                <div
                 class="EXAMPLE">
                  <a
                   name="CREATEFS"></a>

                  <p><strong>Пример 13-6. Создание файловой системы в
                  обычном файле</strong></p>
<pre
 class="PROGRAMLISTING">
SIZE=1048576  # 1 Мб

head -c $SIZE &lt; /dev/zero &gt; file  # Создается файл нужного размера.
losetup /dev/loop0 file           # Файл назначается как loopback-устройство.
mke2fs /dev/loop0                 # Создание файловой системы.
mount -o loop /dev/loop0 /mnt     # Монтирование только что созданной файловой системы.

# Спасибо S.C.
</pre>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">mkswap</strong></dt>

              <dd>
                <p>Создание swap-раздела или swap-файла. Созданный
                swap-раздел (файл) нужно затем подключить командой
                <strong
                 class="COMMAND">swapon</strong>.</p>
              </dd>

              <dt><strong
               class="COMMAND">swapon</strong>, <strong
               class="COMMAND">swapoff</strong></dt>

              <dd>
                <p>Разрешает/запрещает использование swap-раздела
                (файла). Эта команда обычно используется во время
                загрузки системы или во время остановки.</p>
              </dd>

              <dt><a
               name="MKE2FSREF"></a><strong
               class="COMMAND">mke2fs</strong></dt>

              <dd>
                <p>Создает файловую систему ext2. Должна вызываться с
                правами суперпользователя.</p>

                <div
                 class="EXAMPLE">
                  <a
                   name="ADDDRV"></a>

                  <p><strong>Пример 13-7. Добавление нового жесткого
                  диска</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Добавление в систему второго жесткого диска.
# Программное конфигурирование. Предполагается, что устройство уже подключено к аппаратуре компьютера.
# Взято из статьи автора документа.
# &quot;Linux Gazette&quot;, выпуск #38, http://www.linuxgazette.com.

ROOT_UID=0     # Этот сценарий должен запускать только root.
E_NOTROOT=67   # Код ошибки, если сценарий запущен простым пользователем.

if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo &quot;Для запуска этого сценария вы должны обладать правами root.&quot;
  exit $E_NOTROOT
fi

# Будьте крайне осторожны!
# Если что-то пойдет не так, то вы можете потерять текущую файловую систему.


NEWDISK=/dev/hdb         # Предполагается, что /dev/hdb -- это новое устройство. Проверьте!
MOUNTPOINT=/mnt/newdisk  # Или выберите иное устройство для монтирования.


fdisk $NEWDISK
mke2fs -cv $NEWDISK1   # Проверка на &quot;плохие&quot; блоки (bad blocks) и подробный вывод.
#  Обратите внимание:    /dev/hdb1, *не* то же самое, что /dev/hdb!
mkdir $MOUNTPOINT
chmod 777 $MOUNTPOINT  # Сделать новое устройство доступным для всех пользователей.


# Теперь проаерим...
# mount -t ext2 /dev/hdb1 /mnt/newdisk
# Попробуйте создать каталог.
# Если получилось -- отмонтируйте устройство и продолжим.

# Последний штрих:
# Добавьте следующую строку в /etc/fstab.
# /dev/hdb1  /mnt/newdisk  ext2  defaults  1 1

exit 0
</pre>
                </div>

                <p>См. также <a
                 href="#CREATEFS">Пример 13-6</a> и <a
                 href="#RAMDISK">Пример 28-3</a>.</p>
              </dd>

              <dt><strong
               class="COMMAND">tune2fs</strong></dt>

              <dd>
                <p>Настройка отдельных параметров файловой системы
                ext2, например счетчик максимального количества
                монтирований без проверки. Должна вызываться с
                привилегиями пользователя root.</p>

                <div
                 class="WARNING">
                  <table
                   class="WARNING"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/warning.gif"
                       hspace="5"
                       alt="Warning"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Очень опасная утилита. Вы можете
                        использовать ее только на свой страх и риск,
                        поскольку, по неосторожности, вы запросто
                        можете разрушить файловую систему.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">dumpe2fs</strong></dt>

              <dd>
                <p>Выводит на <tt
                 class="FILENAME">stdout</tt> очень подробную
                информацию о файловой системе. Должна вызываться с
                привилегиями пользователя root.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">root#</tt> <strong
 class=
"COMMAND">dumpe2fs /dev/hda7 | grep &#39;ount count&#39;</strong>
<tt
 class=
"COMPUTEROUTPUT">dumpe2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09
 Mount count:              6
 Maximum mount count:      20</tt>
</pre>
              </dd>

              <dt><strong
               class="COMMAND">hdparm</strong></dt>

              <dd>
                <p>Выводит или изменяет параметры настройки жесткого
                диска. Должна вызываться с привилегиями пользователя
                root. Потенциально опасна при неправильном
                использовании.</p>
              </dd>

              <dt><a
               name="FDISKREF"></a><strong
               class="COMMAND">fdisk</strong></dt>

              <dd>
                <p>Создание или изменение таблицы разделов на
                устройствах хранения информации, обычно -- жестких
                дисках. Должна вызываться с привилегиями пользователя
                root.</p>

                <div
                 class="WARNING">
                  <table
                   class="WARNING"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/warning.gif"
                       hspace="5"
                       alt="Warning"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Пользуйтесь этой утилитой с особой
                        осторожностью, т.к. при неправильном
                        использовании можно легко разрушить
                        существующую файловую систему.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><a
               name="FSCKREF"></a><strong
               class="COMMAND">fsck</strong>, <strong
               class="COMMAND">e2fsck</strong>, <strong
               class="COMMAND">debugfs</strong></dt>

              <dd>
                <p>Набор команд для проверки, восстановления и отладки
                файловой системы.</p>

                <p><strong
                 class="COMMAND">fsck</strong>: интерфейсная утилита
                для проверки файловых систем в UNIX (может вызывать
                другие утилиты проверки).</p>

                <p><strong
                 class="COMMAND">e2fsck</strong>: проверка файловой
                системы ext2.</p>

                <p><strong
                 class="COMMAND">debugfs</strong>: отладчик файловой
                системы ext2. Одно из применений этой универсальной (и
                опасной) утилиты -- это восстановление удаленных
                файлов. Только для опытных пользователей!</p>

                <div
                 class="CAUTION">
                  <table
                   class="CAUTION"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/caution.gif"
                       hspace="5"
                       alt="Caution"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Все эти утилиты должны вызываться с
                        привилегиями пользователя root. При
                        неправильном использовании, любая из них может
                        разрушить файловую систему.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">badblocks</strong></dt>

              <dd>
                <p>Выполняет поиск плохих блоков (физические
                повреждения носителей) на устройствах хранения
                информации. Эта команда может использоваться для поиска
                плохих блоков при форматировании вновь устанавливаемых
                жестких дисков или для проверки устройств резервного
                копирования. <a
                 name="AEN11062"
                 href="#FTN.AEN11062"><span
                 class="footnote">[40]</span></a> Например, <strong
                 class="COMMAND">badblocks /dev/fd0</strong>, проверит
                дискету на наличие поврежденных блоков.</p>

                <p>Утилита <strong
                 class="COMMAND">badblocks</strong> может быть вызвана
                в деструктивном (проверка осуществляется путем записи
                некоторого шаблона в каждый блок, а затем производится
                попытка чтения этого блока) или в недеструктивном
                (неразрушающем -- только чтение) режиме.</p>
              </dd>

              <dt><strong
               class="COMMAND">mkbootdisk</strong></dt>

              <dd>
                <p>Создание загрузочной дискеты, которая может быть
                использована для загрузки системы, если, например, была
                повреждена MBR (master boot record -- главная
                загрузочная запись). Команда <strong
                 class="COMMAND">mkbootdisk</strong> -- это сценарий на
                языке командной оболочки Bash, автор: Erik Troan,
                располагается в каталоге <tt
                 class="FILENAME">/sbin</tt>.</p>
              </dd>

              <dt><strong
               class="COMMAND">chroot</strong></dt>

              <dd>
                <p>CHange ROOT -- смена корневого каталога. Обычно,
                команды и утилиты ориентируются в файловой системе
                посредством переменной <a
                 href="#PATHREF">$PATH</a>, относительно корневого
                каталога <tt
                 class="FILENAME">/</tt>. Команда <strong
                 class="COMMAND">chroot</strong> изменяет корневой
                каталог по-умолчанию на другой (рабочий каталог также
                изменяется). Эта утилита, как правило, используется с
                целью защиты системы, например, с ее помощью можно
                ограничить доступ к разделам файловой системы для
                пользователей, подключающихся к системе с помощью <a
                 href="#TELNETREF">telnet</a> (это называется -- <span
                 class="QUOTE">&quot;поместить пользователя в chroot
                окружение&quot;</span>). Обратите внимание: после
                выполнения команды <strong
                 class="COMMAND">chroot</strong> изменяется путь к
                исполняемым файлам системы.</p>

                <p>Команда <tt
                 class="USERINPUT"><strong>chroot /opt</strong></tt>
                приведет к тому, что все обращения к каталогу <tt
                 class="FILENAME">/usr/bin</tt> будут переводиться на
                каталог <tt
                 class="FILENAME">/opt/usr/bin</tt>. Аналогично, <tt
                 class="USERINPUT"><strong>chroot /aaa/bbb
                /bin/ls</strong></tt> будет пытаться вызвать команду
                <strong
                 class="COMMAND">ls</strong> из каталога <tt
                 class="FILENAME">/aaa/bbb/bin</tt>, при этом, корневым
                каталогом для ls станет каталог /aaa/bbb. Поместив
                строчку <strong
                 class="COMMAND">alias XX &#39;chroot /aaa/bbb
                ls&#39;</strong> в пользовательский <tt
                 class="FILENAME">~/.bashrc</tt>, можно эффективно
                ограничить доступ команде <span
                 class="QUOTE">&quot;XX&quot;</span>, запускаемой
                пользователем, к разделам файловой системы.</p>

                <div
                 class="CAUTION">
                  <table
                   class="CAUTION"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/caution.gif"
                       hspace="5"
                       alt="Caution"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>При изменении корневого каталога, вам
                        наверняка потребуется скопировать системные
                        утилиты и разделяемые библиотеки в новый
                        корневой каталог, поскольку после смены
                        корневого каталога, директории с системными
                        утилитами могут оказаться за пределами нового
                        корневого каталога.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">lockfile</strong></dt>

              <dd>
                <p>Эта утилита входит в состав пакета <strong
                 class="COMMAND">procmail</strong> (<a
                 href="http://www.procmail.org"
                 target="_top">www.procmail.org</a>). Она создает <span
                 class="emphasis"><em
                 class="EMPHASIS">lock file</em></span>, файл-семафор
                (или, если угодно, файл блокировки), который управляет
                доступом к заданному файлу, устройству или ресурсу.
                Lock file служит признаком того, что данный файл,
                устройство или ресурс <span
                 class="QUOTE">&quot;занят&quot;</span> некоторым
                процессом, и ограничивает (или вообще запрещает) доступ
                к ресурсу другим процессам.</p>

                <p>Файлы блокировок широко применяются для защиты
                системных почтовых каталогов от одновременной записи
                несколькими пользователями, для индикации занятости
                порта модема, и т.п. Сценарии могут использовать файлы
                блокировок для того, чтобы выяснить -- запущен ли тот
                или иной процесс. Обратите внимание: если в сценарии
                будет предпринята попытка создать файл блокировки,
                когда он уже существует, то такой сценарий скорее всего
                зависнет.</p>

                <p>Как правило, файлы блокировки создаются в каталоге
                <tt
                 class="FILENAME">/var/lock</tt>. Проверка наличия
                файла блокировки может быть проверена примерно таким
                образом:.</p>
<pre
 class="PROGRAMLISTING">
appname=xyzip
# Приложение &quot;xyzip&quot; создает файл блокировки &quot;/var/lock/xyzip.lock&quot;.

if [ -e &quot;/var/lock/$appname.lock ]
then
  ...
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">mknod</strong></dt>

              <dd>
                <p>Создает специальный файл для блочного или
                символьного устройства (может потребоваться при
                установке новых устройств в компьютер).</p>
              </dd>

              <dt><strong
               class="COMMAND">tmpwatch</strong></dt>

              <dd>
                <p>Автоматически удаляет файлы, к которым не было
                обращений в течение заданного периода времени. Обычно
                вызывается демоном <a
                 href="#CRONREF">crond</a> для удаления устаревших
                файлов системного журнала.</p>
              </dd>

              <dt><strong
               class="COMMAND">MAKEDEV</strong></dt>

              <dd>
                <p>Утилита предназначена для создания файлов-устройств.
                Должна запускаться с привилегиями пользователя root, в
                каталоге <tt
                 class="FILENAME">/dev</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">root#</tt> <strong
 class="COMMAND">./MAKEDEV</strong>
</pre>
                Это своего рода расширенная версия утилиты <strong
                 class="COMMAND">mknod</strong>.<br>
                <br>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="PERIPHSYS1"></a>Команды резервного
            копирования</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">dump</strong>, <strong
               class="COMMAND">restore</strong></dt>

              <dd>
                <p>Команда <strong
                 class="COMMAND">dump</strong> создает резервные копии
                целых файловых систем, обычно используется в крупных
                системах и сетях. <a
                 name="AEN11188"
                 href="#FTN.AEN11188"><span
                 class="footnote">[41]</span></a> Она считывает
                дисковые разделы и сохраняет их в файле, в двоичном
                формате. Созданные таким образом файлы, могут быть
                сохранены на каком-либо носителе -- на жестком диске
                или магнитной ленте. Команда <strong
                 class="COMMAND">restore</strong> -- <span
                 class="QUOTE">&quot;разворачивает&quot;</span> файлы,
                созданные утилитой <strong
                 class="COMMAND">dump</strong>.</p>
              </dd>

              <dt><strong
               class="COMMAND">fdformat</strong></dt>

              <dd>
                <p>Выполняет низкоуровневое форматирование дискет.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="SYSRESOURCES1"></a>Команды управления системными
            ресурсами</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">ulimit</strong></dt>

              <dd>
                <p>Устанавливает <span
                 class="emphasis"><em
                 class="EMPHASIS">верхний предел</em></span> для
                системных ресурсов. Как правило вызывается с ключом <tt
                 class="OPTION">-f</tt>, что означает наложение
                ограничений на размер файлов (<strong
                 class="COMMAND">ulimit -f 1000</strong> ограничит
                размер вновь создаваемых файлов одним мегабайтом). Ключ
                <tt
                 class="OPTION">-c</tt> ограничивает размер файлов
                coredump (<strong
                 class="COMMAND">ulimit -c 0</strong> запретит создание
                coredump-файлов). Обычно, все ограничения прописываются
                в файле <tt
                 class="FILENAME">/etc/profile</tt> и/или <tt
                 class="FILENAME">~/.bash_profile</tt> (см. <a
                 href="#FILES">Глава 26</a>).</p>

                <div
                 class="IMPORTANT">
                  <table
                   class="IMPORTANT"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/important.gif"
                       hspace="5"
                       alt="Important"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Грамотное использование <strong
                         class="COMMAND">ulimit</strong> поможет
                        избежать нападений, целью которых является
                        исчерпание системных ресурсов, известных под
                        названием <span
                         class="emphasis"><em
                         class="EMPHASIS">fork bomb</em></span>.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

while 1     #  Бесконечный цикл.
do
  $0 &amp;      #  Этот сценарий вызывает сам себя . . .
            #+ порождая дочерние процессы бесконечное число раз . . .
            #+ точнее -- до тех пор, пока не иссякнут системные ресурсы.
done        #  Это печально известный сценарий <span
 class="QUOTE">&quot;sorcerer&#39;s appentice&quot;</span>.

exit 0      #  Сценарий никогда не завершит свою работу.
</pre>
                        <br>
                        <br>

                        <p>Команда <strong
                         class="COMMAND">ulimit -Hu XX</strong> (где
                        <span
                         class="emphasis"><em
                         class="EMPHASIS">XX</em></span> -- это верхний
                        предел количества процессов, которые может
                        запустить пользователь одновременно) в <tt
                         class="FILENAME">/etc/profile</tt> вызовет
                        аварийное завершение этого сценария, когда
                        количество процессов превысит установленный
                        предел.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">umask</strong></dt>

              <dd>
                <p>Установка маски режима создания файлов. Накладывает
                ограничения на атрибуты по-умлчанию для создаваемых
                файлов. Маска представляет собой восьмеричное значение
                и определяет запрещенные атрибуты файла. Например,
                <strong
                 class="COMMAND">umask 022</strong> удаляет права на
                запись для группы и прочих пользователей (у файлов,
                создававшихся с режимом 777, он оказывается равным 755;
                а режим 666 преобразуется в 644, т.е. 777 NAND 022 =
                755, 666 NAND 022 = 644). <a
                 name="AEN11247"
                 href="#FTN.AEN11247"><span
                 class="footnote">[42]</span></a> Конечно же,
                впоследствие, пользователь может откорректировать права
                доступа к своему файлу с помощью команды <a
                 href="#CHMODREF">chmod</a>. Как правило, значение
                <strong
                 class="COMMAND">umask</strong> устанавливается в файле
                <tt
                 class="FILENAME">/etc/profile</tt> и/или <tt
                 class="FILENAME">~/.bash_profile</tt> (см. <a
                 href="#FILES">Глава 26</a>).</p>
              </dd>

              <dt><strong
               class="COMMAND">rdev</strong></dt>

              <dd>
                <p>Выводит или изменяет корневое устройство, размер
                RAM-диска или видео режим. Функциональные возможности
                утилиты <strong
                 class="COMMAND">rdev</strong> вообще повторяются
                загрузчиком <strong
                 class="COMMAND">lilo</strong>, но <strong
                 class="COMMAND">rdev</strong> по прежнему остается
                востребованной, например, при установке электронного
                диска (RAM-диск). Это еще одна потенциально опасная,
                при неумелом использовании, утилита.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="MODULESSYS1"></a>Команды для работы с модулями
            ядра</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">lsmod</strong></dt>

              <dd>
                <p>Выводит список загруженных модулей.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lsmod</strong></tt>
<tt
 class="COMPUTEROUTPUT">Module                  Size  Used by
 autofs                  9456   2 (autoclean)
 opl3                   11376   0
 serial_cs               5456   0 (unused)
 sb                     34752   0
 uart401                 6384   0 [sb]
 sound                  58368   0 [opl3 sb uart401]
 soundlow                 464   0 [sound]
 soundcore               2800   6 [sb sound]
 ds                      6448   2 [serial_cs]
 i82365                 22928   2
 pcmcia_core            45984   0 [serial_cs ds i82365]</tt>
             
</pre>
                <br>
                <br>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Команда <strong
                         class="COMMAND">cat /proc/modules</strong>
                        выведет на экран эту же информацию.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">insmod</strong></dt>

              <dd>
                <p>Принудительная загрузка модуля ядра (старайтесь
                вместо <strong
                 class="COMMAND">insmod</strong> использовать команду
                <strong
                 class="COMMAND">modprobe</strong>). Должна вызываться
                с привилегиями пользователя root.</p>
              </dd>

              <dt><strong
               class="COMMAND">rmmod</strong></dt>

              <dd>
                <p>Выгружает модуль ядра. Должна вызываться с
                привилегиями пользователя root.</p>
              </dd>

              <dt><strong
               class="COMMAND">modprobe</strong></dt>

              <dd>
                <p>Загрузчик модулей, который обычно вызывается из
                сценариев начальной загрузки системы. Должна вызываться
                с привилегиями пользователя root.</p>
              </dd>

              <dt><strong
               class="COMMAND">depmod</strong></dt>

              <dd>
                <p>Создает файл зависимостей между модулями, обычно
                вызывается из сценариев начальной загрузки системы.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="MISCSYS1"></a>Прочие команды</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">env</strong></dt>

              <dd>
                <p>Запускает указанную программу или сценарий с
                модифицированными <a
                 href="#ENVREF">переменными окружения</a> (не изменяя
                среду системы в целом, изменения касаются только
                окружения запускаемой программы/сценария). Посредством
                <tt
                 class="OPTION">[varname=xxx]</tt>, устанавливает
                значение переменной окружения <tt
                 class="VARNAME">varname</tt>, которая будет доступна
                из запускаемой программы/сценария. Без параметров --
                просто выводит список переменных окружения с их
                значениями.</p>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>В Bash, и других производных от Bourne
                        shell, имеется возможность установки переменных
                        окружения и запуска программы (или сценария)
                        одной командной строкой.</p>
<pre
 class="PROGRAMLISTING">
var1=value1 var2=value2 commandXXX
# $var1 и $var2 -- будут определены только в окружении для &#39;commandXXX&#39;.
</pre>
                        <br>
                        <br>
                      </td>
                    </tr>
                  </table>
                </div>

                <div
                 class="TIP">
                  <table
                   class="TIP"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/tip.gif"
                       hspace="5"
                       alt="Tip"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>В первой строке сценария (<span
                         class="QUOTE">&quot;sha-bang&quot;</span>)
                        можно указать команду <strong
                         class="COMMAND">env</strong>, если путь к
                        командному интерпретатору не известен.</p>
<pre
 class="PROGRAMLISTING">
#! /usr/bin/env perl

print &quot;Этот сценарий, на языке программирования Perl, будет запущен,\n&quot;;
print &quot;даже если я не знаю где в системе находится Perl.\n&quot;;

# Прекрасно подходит для написания кросс-платформенных сценариев,
# когда Perl может находиться совсем не там, где вы ожидаете.
# Спасибо S.C.
</pre>
                        <br>
                        <br>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>

              <dt><strong
               class="COMMAND">ldd</strong></dt>

              <dd>
                <p>Выводит список разделяемых библиотек, необходимых
                для исполняемого файла.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ldd /bin/ls</strong></tt>
<tt
 class="COMPUTEROUTPUT">libc.so.6 =&gt; /lib/libc.so.6 (0x4000c000)
/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x80000000)</tt>
</pre>
              </dd>

              <dt><a
               name="WATCHREF"></a><strong
               class="COMMAND">watch</strong></dt>

              <dd>
                <p>Периодически запускает указанную программу с
                заданным интервалом времени.</p>

                <p>По-умолчанию интервал между запусками принимается
                равным 2 секундам, но может быть изменен ключом <tt
                 class="OPTION">-n</tt>.</p>
<pre
 class="PROGRAMLISTING">
watch -n 5 tail /var/log/messages
# Выводит последние 10 строк из системного журнала, /var/log/messages, каждые пять секунд.
</pre>
                <br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">strip</strong></dt>

              <dd>
                <p>Удаляет отладочную информацию из исполняемого файла.
                Это значительно уменьщает размер исполняемого файла, но
                при этом делает отладку программы невозможной.</p>

                <p>Эту команду часто можно встретить в <a
                 href="#MAKEFILEREF">Makefile</a>-ах, и редко -- в
                сценариях на языке командной оболочки.</p>
              </dd>

              <dt><strong
               class="COMMAND">nm</strong></dt>

              <dd>
                <p>Выводит список символов (используемых в целях
                отладки), содержащихся в откомпилированном двоичном
                файле.</p>
              </dd>

              <dt><strong
               class="COMMAND">rdist</strong></dt>

              <dd>
                <p>Позволяет на заданных машинах хранить идентичные
                копии файлов. По умолчанию, rdist просматривает только
                те файлы, версия которых на удаленных машинах более
                старая, чем на локальной машине. Это делается
                сравнением последнего времени модификации и размера
                файла на локальной машине и на удаленных.</p>
              </dd>
            </dl>
          </div>

          <p>А теперь, используя полученные нами знания, попробуем
          разобраться с одним из системных сценариев. Один из самых
          коротких и простых -- это <strong
           class="COMMAND">killall</strong>, который вызывается для
          остановки процессов при перезагрузке или выключении
          компьютера.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX55"></a>

            <p><strong>Пример 13-8. Сценарий killall, из каталога <tt
             class="FILENAME">/etc/rc.d/init.d</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/sh

# --&gt; Комментарии, начинающиеся с &quot;# --&gt;&quot;, добавлены автором документа.

# --&gt; Этот сценарий является частью пакета &#39;rc&#39;-сценариев
# --&gt; Автор: Miquel van Smoorenburg, &lt;miquels@drinkel.nl.mugnet.org&gt;

# --&gt; Этот сценарий характерен для дистрибутива Red Hat
# --&gt; (в других дистрибутивах может отсутствовать).

# Остановить все ненужные сервисы которые еще работают (собственно,
# их уже не должно быть, это лишь формальная проверка, на всякий случай)

for i in /var/lock/subsys/*; do
        # --&gt; Стандартный заголовок цикла for/in, но, поскольку &quot;do&quot;
                                # --&gt; находится в той же самой строке, что и for,
        # --&gt; необходимо разделить их символом &quot;;&quot;.
        # Проверяется наличие сценария.
        [ ! -f $i ] &amp;&amp; continue
        # --&gt; Очень интересное использование &quot;И-списка&quot;, эквивалентно:
        # --&gt; if [ ! -f &quot;$i&quot; ]; then continue

        # Получить имя подсистемы.
        subsys=${i#/var/lock/subsys/}
        # --&gt; В данном случае совпадает с именем файла.
        # --&gt; Это точный эквивалент subsys=`basename $i`.

        # --&gt;  Таким образом получается имя файла блокировки (если он присутствует,
        # --&gt;+ то это означает, что процесс запущен).
        # --&gt;  См. описание команды &quot;lockfile&quot; выше.


        # Остановить службу.
        if [ -f /etc/rc.d/init.d/$subsys.init ]; then
            /etc/rc.d/init.d/$subsys.init stop
        else
            /etc/rc.d/init.d/$subsys stop
        # --&gt; Останавливает задачу или демона
        # --&gt; посредством встроенной команды &#39;stop&#39;.
        fi
done
</pre>
          </div>

          <p>Вобщем все довольно понятно. Кроме хитрого манипулирования
          с переменными, при определении имени подсистемы (службы),
          здесь нет ничего нового.</p>

          <div
           class="FORMALPARA">
            <p><strong>Упражнение 1.</strong> Просмотрите сценарий
            <strong
             class="COMMAND">halt</strong> в каталоге <tt
             class="FILENAME">/etc/rc.d/init.d</tt>. Он по размеру
            немного больше, чем <strong
             class="COMMAND">killall</strong>, но придерживается той же
            концепции. Создайте копию этого сценария в своем домашнем
            каталоге и поэкспериментируйте с ним (<span
             class="emphasis"><em
             class="EMPHASIS">НЕ</em></span> запускайте его с
            привилегиями суперпользователя). Попробуйте запустить его с
            ключами <tt
             class="OPTION">-vn</tt> (<tt
             class="USERINPUT"><strong>sh -vn
            scriptname</strong></tt>). Добавьте свои комментарии.
            Замените действующие команды на <span
             class="QUOTE">&quot;echo&quot;</span>.</p>
          </div>

          <div
           class="FORMALPARA">
            <p><strong>Упражнение 2.</strong> Просмотрите другие, более
            сложные сценарии из <tt
             class="FILENAME">/etc/rc.d/init.d</tt>. Попробуйте
            разобраться в их работе. Проверьте их работу, следуя
            рекомендациям, приведенным выше. За дополнительной
            информацией вы можете обратиться к документу <tt
             class="FILENAME">sysvinitfiles</tt> в каталоге <tt
             class="FILENAME">/usr/share/doc/initscripts-?.??</tt>,
            который входит в пакет документации к <span
             class="QUOTE">&quot;initscripts&quot;</span>.</p>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="COMMANDSUB"></a>Глава 14. Подстановка команд</h1>

          <p><a
           name="COMMANDSUBREF"></a><strong
           class="COMMAND">Подстановка команд</strong> -- это
          подстановка результатов выполнения команды <a
           name="AEN11451"
           href="#FTN.AEN11451"><span
           class="footnote">[43]</span></a> или даже серии команд;
          буквально, эта операция позволяет вызвать команду в другом
          окружении.</p>

          <p><a
           name="BACKQUOTESREF"></a>Классический пример подстановки
          команд -- использование обратных одиночных кавычек (`...`).
          Команды внутри этих кавычек представляют собой текст
          командной строки.</p>
<pre
 class="PROGRAMLISTING">
script_name=`basename $0`
echo &quot;Имя этого файла-сценария: $script_name.&quot;
</pre>
          <br>
          <br>

          <div
           class="FORMALPARA">
            <p><strong>Вывод от команд может использоваться: как
            аргумент другой команды, для установки значения переменной
            и даже для генерации списка аргументов цикла <a
             href="#FORLOOPREF1">for</a>.</strong></p>
          </div>
<pre
 class="PROGRAMLISTING">
rm `cat filename`   # здесь <span
 class=
"QUOTE">&quot;filename&quot;</span> содержит список удаляемых файлов.
#
# S. C. предупреждает, что в данном случае может возникнуть ошибка &quot;arg list too long&quot;.
# Такой вариант будет лучше:   xargs rm -- &lt; filename
# ( -- подходит для случая, когда <span
 class="QUOTE">&quot;filename&quot;</span> начинается с символа <span
 class="QUOTE">&quot;-&quot;</span> )

textfile_listing=`ls *.txt`
# Переменная содержит имена всех файлов *.txt в текущем каталоге.
echo $textfile_listing

textfile_listing2=$(ls *.txt)   # Альтернативный вариант.
echo $textfile_listing2
# Результат будет тем же самым.

# Проблема записи списка файлов в строковую переменную состоит в том,
# что символы перевода строки заменяются на пробел.
#
# Как вариант решения проблемы -- записывать список файлов в массив.
#      shopt -s nullglob    # При несоответствии, имя файла игнорируется.
#      textfile_listing=( *.txt )
#
# Спасибо S.C.
</pre>
          <br>
          <br>

          <div
           class="CAUTION">
            <table
             class="CAUTION"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/caution.gif"
                 hspace="5"
                 alt="Caution"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Подстанавливаемая команда может получиться
                  разбитой на отдельные слова.</p>
<pre
 class="PROGRAMLISTING">
COMMAND `echo a b`     # 2 аргумента: a и b

COMMAND &quot;`echo a b`&quot;   # 1 аргумент: &quot;a b&quot;

COMMAND `echo`         # без аргументов

COMMAND &quot;`echo`&quot;       # один пустой аргумент


# Спасибо S.C.
</pre>
                  <br>
                  <br>

                  <p>Даже когда не происходит разбиения на слова,
                  операция подстановки команд может удалять завершающие
                  символы перевода строки.</p>
<pre
 class="PROGRAMLISTING">
# cd &quot;`pwd`&quot;  # Должна выполняться всегда.
# Однако...

mkdir &#39;dir with trailing newline
&#39;

cd &#39;dir with trailing newline
&#39;

cd &quot;`pwd`&quot;  # Ошибка:
# bash: cd: /tmp/dir with trailing newline: No such file or directory

cd &quot;$PWD&quot;   # Выполняется без ошибки.





old_tty_setting=$(stty -g)   # Сохранить настройки терминала.
echo &quot;Нажмите клавишу &quot;
stty -icanon -echo           # Запретить &quot;канонический&quot; режим терминала.
                             # Также запрещает эхо-вывод.
key=$(dd bs=1 count=1 2&gt; /dev/null)   # Поймать нажатие на клавишу.
stty &quot;$old_tty_setting&quot;      # Восстановить настройки терминала.
echo &quot;Количество нажатых клавиш = ${#key}.&quot;  # ${#variable} = количество символов в переменной $variable
#
# Нажмите любую клавишу, кроме RETURN, на экране появится &quot;Количество нажатых клавиш = 1.&quot;
# Нажмите RETURN, и получите: &quot;Количество нажатых клавиш = 0.&quot;
# Символ перевода строки будет &quot;съеден&quot; операцией подстановки команды.

Спасибо S.C.
</pre>
                  <br>
                  <br>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="CAUTION">
            <table
             class="CAUTION"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/caution.gif"
                 hspace="5"
                 alt="Caution"></td>

                <td
                 align="left"
                 valign="top">
                  <p>При выводе значений переменных, полученных в
                  результате подстановки команд, командой <strong
                   class="COMMAND">echo</strong>, без кавычек, символы
                  перевода строки будут удалены. Это может оказаться
                  неприятным сюрпризом.</p>
<pre
 class="PROGRAMLISTING">
dir_listing=`ls -l`
echo $dir_listing     # без кавычек

# Вы наверно ожидали увидеть удобочитаемый список каталогов.

# Однако, вы получите:
# total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo
# bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh

# Символы перевода строки были заменены пробелами.


echo &quot;$dir_listing&quot;   # в кавычках
# -rw-rw-r--    1 bozo       30 May 13 17:15 1.txt
# -rw-rw-r--    1 bozo       51 May 15 20:57 t2.sh
# -rwxr-xr-x    1 bozo      217 Mar  5 21:13 wi.sh
</pre>
                  <br>
                  <br>
                </td>
              </tr>
            </table>
          </div>

          <p>Подстановка команд позволяет даже записывать в переменные
          содержимое целых файлов, с помощью <a
           href="#IOREDIRREF">перенаправления</a> или команды <a
           href="#CATREF">cat</a>.</p>
<pre
 class="PROGRAMLISTING">
variable1=`&lt;file1`      # Записать в переменную  &quot;variable1&quot; содержимое файла &quot;file1&quot;.
variable2=`cat file2`   # Записать в переменную &quot;variable2&quot; содержимое файла &quot;file2&quot;.

#  Замечание 1:
#  Удаляются символы перевода строки.
#
#  Замечание 2:
#  В переменные можно записать даже управляющие символы.
</pre>
          <br>
          <br>
<pre
 class="PROGRAMLISTING">
#  Выдержки из системного файла /etc/rc.d/rc.sysinit
#+ (Red Hat Linux)


if [ -f /fsckoptions ]; then
        fsckoptions=`cat /fsckoptions`
...
fi
#
#
if [ -e &quot;/proc/ide/${disk[$device]}/media&quot; ] ; then
             hdmedia=`cat /proc/ide/${disk[$device]}/media`
...
fi
#
#
if [ ! -n &quot;`uname -r | grep -- &quot;-&quot;`&quot; ]; then
       ktag=&quot;`cat /proc/version`&quot;
...
fi
#
#
if [ $usb = &quot;1&quot; ]; then
    sleep 5
    mouseoutput=`cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E &quot;^I.*Cls=03.*Prot=02&quot;`
    kbdoutput=`cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E &quot;^I.*Cls=03.*Prot=01&quot;`
...
fi
</pre>
          <br>
          <br>

          <div
           class="CAUTION">
            <table
             class="CAUTION"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/caution.gif"
                 hspace="5"
                 alt="Caution"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Не используйте переменные для хранения содержимого
                  текстовых файлов <span
                   class="emphasis"><em
                   class="EMPHASIS">большого</em></span> объема, без
                  веских на то оснований. Не записывайте в переменные
                  содержимое <span
                   class="emphasis"><em
                   class="EMPHASIS">бинарных</em></span> файлов, даже
                  шутки ради.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="STUPSCR"></a>

                    <p><strong>Пример 14-1. Глупая выходка</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# stupid-script-tricks.sh: Люди! Будьте благоразумны!
# Из &quot;Глупые выходки&quot;, том I.


dangerous_variable=`cat /boot/vmlinuz`   # Сжатое ядро Linux.

echo &quot;длина строки \$dangerous_variable = ${#dangerous_variable}&quot;
# длина строки $dangerous_variable = 794151
# (&#39;wc -c /boot/vmlinuz&#39; даст другой результат.)

# echo &quot;$dangerous_variable&quot;
# Даже не пробуйте раскомментарить эту строку! Это приведет к зависанию сценария.


#  Автор этого документа не знает, где можно было бы использовать
#+ запись содержимого двоичных файлов в переменные.

exit 0
</pre>
                  </div>

                  <p>Обратите внимание: в данной ситуации не возникает
                  ошибки <span
                   class="emphasis"><em
                   class="EMPHASIS">переполнения буфера</em></span>.
                  Этот пример показывает превосходство защищенности
                  интерпретирующих языков, таких как Bash, от ошибок
                  программиста, над компилирующими языками
                  программирования.</p>
                </td>
              </tr>
            </table>
          </div>

          <p>Подстановка команд, позволяет записать в переменную
          результаты выполнения <a
           href="#FORLOOPREF1">цикла</a>. Ключевым моментом здесь
          является команда <a
           href="#ECHOREF">echo</a>, в теле цикла.</p>

          <div
           class="EXAMPLE">
            <a
             name="CSUBLOOP"></a>

            <p><strong>Пример 14-2. Запись результатов выполнения цикла
            в переменную</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# csubloop.sh: Запись результатов выполнения цикла в переменную

variable1=`for i in 1 2 3 4 5
do
  echo -n &quot;$i&quot;                 #  Здесь &#39;echo&#39; -- это ключевой момент
done`

echo &quot;variable1 = $variable1&quot;  # variable1 = 12345


i=0
variable2=`while [ &quot;$i&quot; -lt 10 ]
do
  echo -n &quot;$i&quot;                 # Опять же, команда &#39;echo&#39; просто необходима.
  let &quot;i += 1&quot;                 # Увеличение на 1.
done`

echo &quot;variable2 = $variable2&quot;  # variable2 = 0123456789

exit 0
</pre>
          </div>

          <table
           class="SIDEBAR"
           border="1"
           cellpadding="5">
            <tr>
              <td>
                <div
                 class="SIDEBAR">
                  <a
                   name="AEN11497"></a>

                  <p>Подстановка команд позволяет существенно расширить
                  набор инструментальных средств, которыми располагает
                  Bash. Суть состоит в том, чтобы написать программу
                  или сценарий, которая выводит результаты своей работы
                  на <tt
                   class="FILENAME">stdout</tt> (как это делает
                  подавляющее большинство утилит в UNIX) и записать
                  вывод от программы в переменную.</p>
<pre
 class="PROGRAMLISTING">
#include &lt;stdio.h&gt;

/*  Программа на C &quot;Hello, world.&quot;  */

int main()
{
  printf( &quot;Hello, world.&quot; );
  return (0);
}
</pre>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>gcc -o hello hello.c</strong></tt>
             
</pre>
                  <br>
                  <br>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# hello.sh

greeting=`./hello`
echo $greeting
</pre>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>sh hello.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">Hello, world.</tt>
               
</pre>
                  <br>
                  <br>
                </div>
              </td>
            </tr>
          </table>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Альтернативой обратным одиночным кавычкам,
                  используемым для подстановки команд, можно считать
                  такую форму записи: <strong
                   class="COMMAND">$(COMMAND)</strong>.</p>
<pre
 class="PROGRAMLISTING">
output=$(sed -n /&quot;$1&quot;/p $file)   # К примеру из &quot;grp.sh&quot;.

# Запись в переменную содержимого текстового файла.
File_contents1=$(cat $file1)
File_contents2=$(&lt;$file2)        # Bash допускает и такую запись.
</pre>
                  <br>
                  <br>
                </td>
              </tr>
            </table>
          </div>

          <p>Примеры подстановки команд в сценариях:</p>

          <ol
           type="1">
            <li>
              <p><a
               href="#BINGREP">Пример 10-7</a></p>
            </li>

            <li>
              <p><a
               href="#CASECMD">Пример 10-26</a></p>
            </li>

            <li>
              <p><a
               href="#SEEDINGRANDOM">Пример 9-26</a></p>
            </li>

            <li>
              <p><a
               href="#EX57">Пример 12-2</a></p>
            </li>

            <li>
              <p><a
               href="#LOWERCASE">Пример 12-15</a></p>
            </li>

            <li>
              <p><a
               href="#GRP">Пример 12-12</a></p>
            </li>

            <li>
              <p><a
               href="#EX53">Пример 12-39</a></p>
            </li>

            <li>
              <p><a
               href="#EX24">Пример 10-13</a></p>
            </li>

            <li>
              <p><a
               href="#SYMLINKS">Пример 10-10</a></p>
            </li>

            <li>
              <p><a
               href="#STRIPC">Пример 12-24</a></p>
            </li>

            <li>
              <p><a
               href="#REDIR4">Пример 16-7</a></p>
            </li>

            <li>
              <p><a
               href="#TREE">Пример A-19</a></p>
            </li>

            <li>
              <p><a
               href="#PIDID">Пример 27-1</a></p>
            </li>

            <li>
              <p><a
               href="#MONTHLYPMT">Пример 12-32</a></p>
            </li>

            <li>
              <p><a
               href="#BASE">Пример 12-33</a></p>
            </li>

            <li>
              <p><a
               href="#ALTBC">Пример 12-34</a></p>
            </li>
          </ol>
          <br>
          <br>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="ARITHEXP"></a>Глава 15. Арифметические
          подстановки</h1>

          <p><a
           name="ARITHEXPREF"></a>Арифметические подстановки -- это
          мощный инструмент, предназначенный для выполнения
          арифметических операций в сценариях. Перевод строки в
          числовое выражение производится с помощью <a
           href="#BACKQUOTESREF">обратных одиночных кавычек</a>, <a
           href="#DBLPARENS">двойных круглых скобок</a> или предложения
          <a
           href="#LETREF">let</a>.</p>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="ARITHEXPVAR1"></a>Вариации</strong></p>

            <dl>
              <dt>Арифметические подстановки в обратных одиночных
              кавычках (часто используются совместно с командой <a
               href="#EXPRREF">expr</a>)</dt>

              <dd>
<pre
 class="PROGRAMLISTING">
z=`expr $z + 3`            # Команда &#39;expr&#39; вычисляет значение выражения.
</pre>
                <br>
                <br>
              </dd>

              <dt>Арифметические подстановки в двойных круглых скобках,
              и предложение <strong
               class="COMMAND">let</strong></dt>

              <dd>
                <p>В арифметических подстановках, обратные одиночные
                кавычки могут быть заменены на двойные круглые скобки
                <tt
                 class="USERINPUT"><strong>$((...))</strong></tt> или
                очень удобной конструкцией, с применением предложения
                <strong
                 class="COMMAND">let</strong>.</p>
<pre
 class="PROGRAMLISTING">
z=$(($z+3))
# $((EXPRESSION)) -- это подстановка арифметического выражения.  #  Не путайте с
                                                                 #+ подстановкой команд.

let z=z+3
let &quot;z += 3&quot;  # Кавычки позволяют вставляьб пробелы и специальные операторы.
#  Оператор &#39;let&#39; вычисляет арифметическое выражение,
#+ это не подстановка арифметического выражения.
</pre>
                Все вышеприведенные примеры эквивалентны. Вы можете
                использовать любую из этих форм записи <span
                 class="QUOTE">&quot;по своему вкусу&quot;</span>. <br>
                <br>

                <p>Примеры арифметических подстановок в сценариях:</p>

                <ol
                 type="1">
                  <li>
                    <p><a
                     href="#EX45">Пример 12-6</a></p>
                  </li>

                  <li>
                    <p><a
                     href="#EX25">Пример 10-14</a></p>
                  </li>

                  <li>
                    <p><a
                     href="#EX66">Пример 25-1</a></p>
                  </li>

                  <li>
                    <p><a
                     href="#BUBBLE">Пример 25-6</a></p>
                  </li>

                  <li>
                    <p><a
                     href="#TREE">Пример A-19</a></p>
                  </li>
                </ol>
                <br>
                <br>
              </dd>
            </dl>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="IO-REDIRECTION"></a>Глава 16. Перенаправление
          ввода/вывода</h1>

          <p><a
           name="IOREDIRREF"></a></p>

          <p>В системе по-умолчанию всегда открыты три <span
           class="QUOTE">&quot;файла&quot;</span> -- <tt
           class="FILENAME">stdin</tt> (клавиатура), <tt
           class="FILENAME">stdout</tt> (экран) и <tt
           class="FILENAME">stderr</tt> (вывод сообщений об ошибках на
          экран). Эти, и любые другие открытые файлы, могут быть
          перенапрвлены. В данном случае, термин
          &quot;перенаправление&quot; означает получить вывод из файла,
          команды, программы, сценария или даже отдельного блока в
          сценарии (см. <a
           href="#EX8">Пример 3-1</a> и <a
           href="#RPMCHECK">Пример 3-2</a>) и передать его на вход в
          другой файл, команду, программу или сценарий.</p>

          <p><a
           name="FDREF"></a>С каждым открытым файлом связан дескриптор
          файла. <a
           name="AEN11633"
           href="#FTN.AEN11633"><span
           class="footnote">[44]</span></a> Дескрипторы файлов <tt
           class="FILENAME">stdin</tt>, <tt
           class="FILENAME">stdout</tt> и <tt
           class="FILENAME">stderr</tt> -- 0, 1 и 2, соответственно.
          При открытии дополнительных файлов, дескрипторы с 3 по 9
          остаются незанятыми. Иногда дополнительные дескрипторы могут
          сослужить неплохую службу, временно сохраняя в себе ссылку на
          <tt
           class="FILENAME">stdin</tt>, <tt
           class="FILENAME">stdout</tt> или <tt
           class="FILENAME">stderr</tt>. <a
           name="AEN11642"
           href="#FTN.AEN11642"><span
           class="footnote">[45]</span></a> Это упрощает возврат
          дескрипторов в нормальное состояние после сложных манипуляций
          с перенаправлением и перестановками (см. <a
           href="#REDIR1">Пример 16-1</a>).</p>

          <p><a
           name="IOREDIRECTIONREF"></a></p>
<pre
 class="PROGRAMLISTING">
   COMMAND_OUTPUT &gt;
      # Перенаправление stdout (вывода) в файл.
      # Если файл отсутствовал, то он создется, иначе -- перезаписывается.

      ls -lR &gt; dir-tree.list
      # Создает файл, содержащий список дерева каталогов.

   : &gt; filename
      # Операция &gt; усекает файл &quot;filename&quot; до нулевой длины.
      # Если до выполнения операции файла не существовало,
      # то создается новый файл с нулевой длиной (тот же эффект дает команда &#39;touch&#39;).
      # Символ : выступает здесь в роли местозаполнителя, не выводя ничего.

   &gt; filename
      # Операция &gt; усекает файл &quot;filename&quot; до нулевой длины.
      # Если до выполнения операции файла не существовало,
      # то создается новый файл с нулевой длиной (тот же эффект дает команда &#39;touch&#39;).
      # (тот же результат, что и выше -- &quot;: &gt;&quot;, но этот вариант неработоспособен
      # в некоторых командных оболочках.)

   COMMAND_OUTPUT &gt;&gt;
      # Перенаправление stdout (вывода) в файл.
      # Создает новый файл, если он отсутствовал, иначе -- дописывает в конец файла.


      # Однострочные команды перенаправления
      # (затрагивают только ту строку, в которой они встречаются):
      # --------------------------------------------------------------------

   1&gt;filename
      # Перенаправление вывода (stdout) в файл &quot;filename&quot;.
   1&gt;&gt;filename
      # Перенаправление вывода (stdout) в файл &quot;filename&quot;, файл открывается в режиме добавления.
   2&gt;filename
      # Перенаправление stderr в файл &quot;filename&quot;.
   2&gt;&gt;filename
      # Перенаправление stderr в файл &quot;filename&quot;, файл открывается в режиме добавления.
   &amp;&gt;filename
      # Перенаправление stdout и stderr в файл &quot;filename&quot;.

      #==============================================================================
      # Перенаправление stdout, только для одной строки.
      LOGFILE=script.log

      echo &quot;Эта строка будет записана в файл \&quot;$LOGFILE\&quot;.&quot; 1&gt;$LOGFILE
      echo &quot;Эта строка будет добавлена в конец файла \&quot;$LOGFILE\&quot;.&quot; 1&gt;&gt;$LOGFILE
      echo &quot;Эта строка тоже будет добавлена в конец файла \&quot;$LOGFILE\&quot;.&quot; 1&gt;&gt;$LOGFILE
      echo &quot;Эта строка будет выведена на экран и не попадет в файл \&quot;$LOGFILE\&quot;.&quot;
      # После каждой строки, сделанное перенаправление автоматически &quot;сбрасывается&quot;.



      # Перенаправление stderr, только для одной строки.
      ERRORFILE=script.errors

      bad_command1 2&gt;$ERRORFILE       #  Сообщение об ошибке запишется в $ERRORFILE.
      bad_command2 2&gt;&gt;$ERRORFILE      #  Сообщение об ошибке добавится в конец $ERRORFILE.
      bad_command3                    #  Сообщение об ошибке будет выведено на stderr,
                                      #+ и не попадет в $ERRORFILE.
      # После каждой строки, сделанное перенаправление также автоматически &quot;сбрасывается&quot;.
      #==============================================================================



   2&gt;&amp;1
      # Перенаправляется stderr на stdout.
      # Сообщения об ошибках передаются туда же, куда и стандартный вывод.

   i&gt;&amp;j
      # Перенаправляется файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">i</em></span> в <span
 class="emphasis"><em
 class="EMPHASIS">j</em></span>.
      # Вывод в файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">i</em></span> передается в файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">j</em></span>.

   &gt;&amp;j
      # Перенаправляется  файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">1</em></span> (stdout) в файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">j</em></span>.
      # Вывод на stdout передается в файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">j</em></span>.

   0&lt; FILENAME
    &lt; FILENAME
      # Ввод из файла.
      # Парная команде <span
 class=
"QUOTE">&quot;&gt;&quot;</span>, часто встречается в комбинации с ней.
      #
      # grep search-word &lt;filename


   [j]&lt;&gt;filename
      # Файл &quot;filename&quot; открывается на чтение и запись, и связывается с дескриптором &quot;j&quot;.
      # Если &quot;filename&quot; отсутствует, то он создается.
      # Если дескриптор &quot;j&quot; не указан, то, по-умолчанию, бередся дескриптор 0, stdin.
      #
      # Как одно из применений этого -- запись в конкретную позицию в файле.
      echo 1234567890 &gt; File    # Записать строку в файл &quot;File&quot;.
      exec 3&lt;&gt; File       # Открыть &quot;File&quot; и связать с дескриптором 3.
      read -n 4 &lt;&amp;3             # Прочитать 4 символа.
      echo -n . &gt;&amp;3             # Записать символ точки.
      exec 3&gt;&amp;-                 # Закрыть дескриптор 3.
      cat File                  # ==&gt; 1234.67890
      # Произвольный доступ, да и только!



   |
      # Конвейер (канал).
      # Универсальное средство для объединения команд в одну цепочку.
      # Похоже на <span
 class=
"QUOTE">&quot;&gt;&quot;</span>, но на самом деле -- более обширная.
      # Используется для объединения команд, сценариев, файлов и программ в одну цепочку (конвейер).
      cat *.txt | sort | uniq &gt; result-file
      # Содержимое всех файлов .txt сортируется, удаляются повторяющиеся строки,
      # результат сохраняется в файле <span
 class="QUOTE">&quot;result-file&quot;</span>.
</pre>

          <p>Операции перенаправления и/или конвейеры могут
          комбинироваться в одной командной строке.</p>
<pre
 class="PROGRAMLISTING">
command &lt; input-file &gt; output-file

command1 | command2 | command3 &gt; output-file
</pre>
          См. <a
           href="#DERPM">Пример 12-23</a> и <a
           href="#FIFO">Пример A-17</a>.<br>
          <br>

          <p>Допускается перенаправление нескольких потоков в один
          файл.</p>
<pre
 class="PROGRAMLISTING">
ls -yz &gt;&gt; command.log 2&gt;&amp;1
# Сообщение о неверной опции &quot;yz&quot; в команде &quot;ls&quot; будет записано в файл &quot;command.log&quot;.
# Поскольку stderr перенаправлен в файл.
</pre>
          <br>
          <br>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="CFD"></a>Закрытие дескрипторов файлов</strong></p>

            <dl>
              <dt><span
               class="TOKEN">n&lt;&amp;-</span></dt>

              <dd>
                <p>Закрыть дескриптор входного файла <tt
                 class="REPLACEABLE"><em>n</em></tt>.</p>
              </dd>

              <dt><span
               class="TOKEN">0&lt;&amp;-</span>, <span
               class="TOKEN">&lt;&amp;-</span></dt>

              <dd>
                <p>Закрыть <tt
                 class="FILENAME">stdin</tt>.</p>
              </dd>

              <dt><span
               class="TOKEN">n&gt;&amp;-</span></dt>

              <dd>
                <p>Закрыть дескриптор выходного файла <tt
                 class="REPLACEABLE"><em>n</em></tt>.</p>
              </dd>

              <dt><span
               class="TOKEN">1&gt;&amp;-</span>, <span
               class="TOKEN">&gt;&amp;-</span></dt>

              <dd>
                <p>Закрыть <tt
                 class="FILENAME">stdout</tt>.</p>
              </dd>
            </dl>
          </div>

          <p>Дочерние процессы наследуют дескрипторы открытых файлов.
          По этой причине и работают конвейеры. Чтобы предотвратить
          наследование дескрипторов -- закройте их перед запуском
          дочернего процесса.</p>
<pre
 class="PROGRAMLISTING">
# В конвейер передается только stderr.

exec 3&gt;&amp;1                              # Сохранить текущее &quot;состояние&quot; stdout.
ls -l 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | grep bad 3&gt;&amp;-    # Закрыть дескр. 3 для &#39;grep&#39; (но не для &#39;ls&#39;).
#              ^^^^   ^^^^
exec 3&gt;&amp;-                              # Теперь закрыть его для оставшейся части сценария.

# Спасибо S.C.
</pre>
          <br>
          <br>

          <p>Дополнительные сведения о перенаправлении ввода/вывода вы
          найдете в <a
           href="#IOREDIRINTRO">Приложение D</a>.</p>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="AEN11702"></a>16.1. С помощью команды <strong
             class="COMMAND">exec</strong></h2>

            <p>Команда <strong
             class="COMMAND">exec &lt;filename</strong> перенаправляет
            ввод со <tt
             class="FILENAME">stdin</tt> на файл. С этого момента весь
            ввод, вместо <tt
             class="FILENAME">stdin</tt> (обычно это клавиатура), будет
            производиться из этого файла. Это дает возможность читать
            содержимое файла, строку за строкой, и анализировать каждую
            введенную строку с помощью <a
             href="#SEDREF">sed</a> и/или <a
             href="#AWKREF">awk</a>.</p>

            <div
             class="EXAMPLE">
              <a
               name="REDIR1"></a>

              <p><strong>Пример 16-1. Перенаправление <tt
               class="FILENAME">stdin</tt> с помощью exec</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Перенаправление stdin с помощью &#39;exec&#39;.


exec 6&lt;&amp;0          # Связать дескр. #6 со стандартным вводом (stdin).
                   # Сохраняя stdin.

exec &lt; data-file   # stdin заменяется файлом &quot;data-file&quot;

read a1            # Читается первая строка из &quot;data-file&quot;.
read a2            # Читается вторая строка из &quot;data-file.&quot;

echo
echo &quot;Следующие строки были прочитаны из файла.&quot;
echo &quot;-----------------------------------------&quot;
echo $a1
echo $a2

echo; echo; echo

exec 0&lt;&amp;6 6&lt;&amp;-
#  Восстанавливается stdin из дескр. #6, где он был предварительно сохранен,
#+ и дескр. #6 закрывается ( 6&lt;&amp;- ) освобождая его для других процессов.
#
# &lt;&amp;6 6&lt;&amp;-    дает тот же результат.

echo -n &quot;Введите строку  &quot;
read b1  # Теперь функция &quot;read&quot;, как и следовало ожидать, принимает данные с обычного stdin.
echo &quot;Строка, принятая со stdin.&quot;
echo &quot;--------------------------&quot;
echo &quot;b1 = $b1&quot;

echo

exit 0
</pre>
            </div>

            <p>Аналогично, конструкция <strong
             class="COMMAND">exec &gt;filename</strong> перенаправляет
            вывод на <tt
             class="FILENAME">stdout</tt> в заданный файл. После этого,
            весь вывод от команд, который обычно направляется на <tt
             class="FILENAME">stdout</tt>, теперь выводится в этот
            файл.</p>

            <div
             class="EXAMPLE">
              <a
               name="REASSIGNSTDOUT"></a>

              <p><strong>Пример 16-2. Перенаправление <tt
               class="FILENAME">stdout</tt> с помощью exec</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# reassign-stdout.sh

LOGFILE=logfile.txt

exec 6&gt;&amp;1           # Связать дескр. #6 со stdout.
                    # Сохраняя stdout.

exec &gt; $LOGFILE     # stdout замещается файлом &quot;logfile.txt&quot;.

# ----------------------------------------------------------- #
# Весь вывод от команд, в данном блоке, записывается в файл $LOGFILE.

echo -n &quot;Logfile: &quot;
date
echo &quot;-------------------------------------&quot;
echo

echo &quot;Вывод команды \&quot;ls -al\&quot;&quot;
echo
ls -al
echo; echo
echo &quot;Вывод команды \&quot;df\&quot;&quot;
echo
df

# ----------------------------------------------------------- #

exec 1&gt;&amp;6 6&gt;&amp;-      # Восстановить stdout и закрыть дескр. #6.

echo
echo &quot;== stdout восстановлено в значение по-умолчанию == &quot;
echo
ls -al
echo

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="UPPERCONV"></a>

              <p><strong>Пример 16-3. Одновременное перенаправление
              устройств, <tt
               class="FILENAME">stdin</tt> и <tt
               class="FILENAME">stdout</tt>, с помощью команды
              exec</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# upperconv.sh
# Преобразование символов во входном файле в верхний регистр.

E_FILE_ACCESS=70
E_WRONG_ARGS=71

if [ ! -r &quot;$1&quot; ]     # Файл доступен для чтения?
then
  echo &quot;Невозможно прочитать из заданного файла!&quot;
  echo &quot;Порядок использования: $0 input-file output-file&quot;
  exit $E_FILE_ACCESS
fi                   #  В случае, если входной файл ($1) не задан
                     #+ код завершения будет этим же.

if [ -z &quot;$2&quot; ]
then
  echo &quot;Необходимо задать выходной файл.&quot;
  echo &quot;Порядок использования: $0 input-file output-file&quot;
  exit $E_WRONG_ARGS
fi


exec 4&lt;&amp;0
exec &lt; $1            # Назначить ввод из входного файла.

exec 7&gt;&amp;1
exec &gt; $2            # Назначить вывод в выходной файл.
                     # Предполагается, что выходной файл доступен для записи
                     # (добавить проверку?).

# -----------------------------------------------
    cat - | tr a-z A-Z   # Перевод в верхний регистр
#   ^^^^^                # Чтение со stdin.
#           ^^^^^^^^^^   # Запись в stdout.
# Однако, и stdin и stdout были перенаправлены.
# -----------------------------------------------

exec 1&gt;&amp;7 7&gt;&amp;-       # Восстановить stdout.
exec 0&lt;&amp;4 4&lt;&amp;-       # Восстановить stdin.

# После восстановления, следующая строка выводится на stdout, чего и следовало ожидать.
echo &quot;Символы из \&quot;$1\&quot; преобразованы в верхний регистр, результат записан в \&quot;$2\&quot;.&quot;

exit 0

<a href="abs6.html">Advanced Bash-Scripting Guide - Часть 6</a>
  </body>
</html>

