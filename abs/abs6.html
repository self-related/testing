<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <meta
     name="generator"
     content=
    "HTML Tidy for Linux/x86 (vers 1st July 2002), see www.w3.org">

    <title>Advanced Bash-Scripting Guide - Часть 6</title>
    <meta
     http-equiv="Content-Type"
     content="text/html; charset=koi8-r">
    <meta
     name="GENERATOR"
     content="Modular DocBook HTML Stylesheet Version 1.7">
  </head>
        <h1
         class="TITLE"><a
         name="AEN2"></a>Advanced Bash-Scripting Guide - Часть 6</h1>
  <body
   class="BOOK"
   bgcolor="#FFFFFF"
   text="#000000"
   link="#0000FF"
   vlink="#840084"
   alink="#0000FF">
      <div
       class="TOC">
       
              <dt>17. <a
               href="#HERE-DOCS">Встроенные документы</a></dt>
            </dl>
          </dd>

          <dt>Часть 4. <a
           href="#PART4">Материал повышенной сложности</a></dt>

          <dd>
            <dl>
              <dt>18. <a
               href="#REGEXP">Регулярные выражения</a></dt>

              <dd>
                <dl>
                  <dt>18.1. <a
                   href="#AEN11904">Краткое введение в регулярные
                  выражения</a></dt>

                  <dt>18.2. <a
                   href="#GLOBBINGREF">Globbing -- Подстановка имен
                  файлов</a></dt>
                </dl>
              </dd>

              <dt>19. <a
               href="#SUBSHELLS">Подоболочки, или Subshells</a></dt>

              <dt>20. <a
               href="#RESTRICTED-SH">Ограниченный режим командной
              оболочки</a></dt>

              <dt>21. <a
               href="#PROCESS-SUB">Подстановка процессов</a></dt>

              <dt>22. <a
               href="#FUNCTIONS">Функции</a></dt>

              <dd>
                <dl>
                  <dt>22.1. <a
                   href="#COMPLEXFUNCT">Сложные функции и сложности с
                  функциями</a></dt>

                  <dt>22.2. <a
                   href="#LOCALVAR">Локальные переменные</a></dt>
                </dl>
              </dd>

              <dt>23. <a
               href="#ALIASES">Псевдонимы</a></dt>

              <dt>24. <a
               href="#LIST-CONS">Списки команд</a></dt>

              <dt>25. <a
               href="#ARRAYS">Массивы</a></dt>

              <dt>26. <a
               href="#FILES">Файлы</a></dt>

              <dt>27. <a
               href="#DEVPROC">/dev и /proc</a></dt>

              <dd>
                <dl>
                  <dt>27.1. <a
                   href="#DEVREF1"><tt
                   class="FILENAME">/dev</tt></a></dt>

                  <dt>27.2. <a
                   href="#PROCREF1"><tt
                   class="FILENAME">/proc</tt></a></dt>
                </dl>
              </dd>
	
<pre
 class="PROGRAMLISTING">
#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data       # По-умолчанию, если имя файла не задано.
else
  Filename=$1
fi
#  Конструкцию проверки выше, можно заменить следующей строкой (подстановка параметров):
#+ Filename=${1:-names.data}

count=0

echo

while [ &quot;$name&quot; != Smith ]  # Почему переменная $name взята в кавычки?
do
  read name                 # Чтение из $Filename, не со stdin.
  echo $name
  let &quot;count += 1&quot;
done &lt;&quot;$Filename&quot;           # Перенаправление на ввод из файла $Filename.
#    ^^^^^^^^^^^^

echo; echo &quot;Имен прочитано: $count&quot;; echo

#  Обратите внимание: в некоторых старых командных интерпретаторах,
#+ перенаправление в циклы приводит к запуску цикла в субоболочке (subshell).
#  Таким образом, переменная $count, по окончании цикла, будет содержать 0,
#  значение, записанное в нее до входа в цикл.
#  Bash и ksh стремятся избежать запуска субоболочки (subshell), если это возможно,
#+ так что этот сценарий, в этих оболочках, работает корректно.
#
# Спасибо Heiner Steven за это примечание.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="REDIR2A"></a>

              <p><strong>Пример 16-5. Альтернативная форма
              перенаправления в цикле <span
               class="emphasis"><em
               class="EMPHASIS">while</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Это альтернативный вариант предыдущего сценария.

#  Предложил: by Heiner Steven
#+ для случаев, когда циклы с перенаправлением
#+ запускаются в субоболочке, из-за чего переменные, устанавливаемые в цикле,
#+ не сохраняют свои значения по завершении цикла.


if [ -z &quot;$1&quot; ]
then
  Filename=names.data     # По-умолчанию, если имя файла не задано.
else
  Filename=$1
fi


exec 3&lt;&amp;0                 # Сохранить stdin в дескр. 3.
exec 0&lt;&quot;$Filename&quot;        # Перенаправить stdin.

count=0
echo


while [ &quot;$name&quot; != Smith ]
do
  read name               # Прочитать с перенаправленного stdin ($Filename).
  echo $name
  let &quot;count += 1&quot;
done &lt;&quot;$Filename&quot;         # Цикл читает из файла $Filename.
#    ^^^^^^^^^^^^


exec 0&lt;&amp;3                 # Восстановить stdin.
exec 3&lt;&amp;-                 # Закрыть временный дескриптор 3.

echo; echo &quot;Имен прочитано: $count&quot;; echo

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="REDIR3"></a>

              <p><strong>Пример 16-6. Перенаправление в цикл <span
               class="emphasis"><em
               class="EMPHASIS">until</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# То же самое, что и в предыдущем примере, только для цикла &quot;until&quot;.

if [ -z &quot;$1&quot; ]
then
  Filename=names.data         # По-умолчанию, если файл не задан.
else
  Filename=$1
fi

# while [ &quot;$name&quot; != Smith ]
until [ &quot;$name&quot; = Smith ]     # Проверка != изменена на =.
do
  read name                   # Чтение из $Filename, не со stdin.
  echo $name
done &lt;&quot;$Filename&quot;             # Перенаправление на ввод из файла $Filename.
#    ^^^^^^^^^^^^

# Результаты получаются теми же, что и в случае с циклом &quot;while&quot;, в предыдущем примере.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="REDIR4"></a>

              <p><strong>Пример 16-7. Перенаправление в цикл <span
               class="emphasis"><em
               class="EMPHASIS">for</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data          # По-умолчанию, если файл не задан.
else
  Filename=$1
fi

line_count=`wc $Filename | awk &#39;{ print $1 }&#39;`
#           Число строк в файле.
#
#  Слишком запутано, тем не менее показывает
#+ возможность перенаправления stdin внутри цикла &quot;for&quot;...
#+ если вы достаточно умны.
#
# Более короткий вариант    line_count=$(wc &lt; &quot;$Filename&quot;)


for name in `seq $line_count`  # &quot;seq&quot; выводит последовательность чисел.
# while [ &quot;$name&quot; != Smith ]   --   более запутанно, чем в случае с циклом &quot;while&quot;   --
do
  read name                    # Чтение из файла $Filename, не со stdin.
  echo $name
  if [ &quot;$name&quot; = Smith ]
  then
    break
  fi
done &lt;&quot;$Filename&quot;              # Перенаправление на ввод из файла $Filename.
#    ^^^^^^^^^^^^

exit 0
</pre>
            </div>

            <p>Предыдущий пример можно модифицировать так, чтобы
            перенаправить вывод из цикла.</p>

            <div
             class="EXAMPLE">
              <a
               name="REDIR4A"></a>

              <p><strong>Пример 16-8. Перенаправление устройств (<tt
               class="FILENAME">stdin</tt> и <tt
               class="FILENAME">stdout</tt>) в цикле <span
               class="emphasis"><em
               class="EMPHASIS">for</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data          # По-умолчанию, если файл не задан.
else
  Filename=$1
fi

Savefile=$Filename.new         # Имя файла, в котором сохраняются результаты.
FinalName=Jonah                # Имя, на котором завершается чтение.

line_count=`wc $Filename | awk &#39;{ print $1 }&#39;`  # Число строк в заданном файле.


for name in `seq $line_count`
do
  read name
  echo &quot;$name&quot;
  if [ &quot;$name&quot; = &quot;$FinalName&quot; ]
  then
    break
  fi
done &lt; &quot;$Filename&quot; &gt; &quot;$Savefile&quot;     # Перенаправление на ввод из файла $Filename,
#    ^^^^^^^^^^^^^^^^^^^^^^^^^^^       и сохранение результатов в файле.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="REDIR5"></a>

              <p><strong>Пример 16-9. Перенаправление в конструкции
              <span
               class="emphasis"><em
               class="EMPHASIS">if/then</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data   # По-умолчанию, если файл не задан.
else
  Filename=$1
fi

TRUE=1

if [ &quot;$TRUE&quot; ]          # конструкции &quot;if true&quot; и &quot;if :&quot; тоже вполне допустимы.
then
 read name
 echo $name
fi &lt;&quot;$Filename&quot;
#  ^^^^^^^^^^^^

# Читает только первую строку из файла.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="NAMESDATA"></a>

              <p><strong>Пример 16-10. Файл с именами <span
               class="QUOTE">&quot;names.data&quot;</span>, для
              примеров выше</strong></p>
<pre
 class="PROGRAMLISTING">
Aristotle
Belisarius
Capablanca
Euler
Goethe
Hamurabi
Jonah
Laplace
Maroczy
Purcell
Schmidt
Semmelweiss
Smith
Turing
Venn
Wilson
Znosko-Borowski

#  Это файл с именами для примеров
#+ &quot;redir2.sh&quot;, &quot;redir3.sh&quot;, &quot;redir4.sh&quot;, &quot;redir4a.sh&quot;, &quot;redir5.sh&quot;.
</pre>
            </div>

            <p>Перенаправление <tt
             class="FILENAME">stdout</tt> для блока кода, может
            использоваться для сохранения результатов работы этого
            блока в файл. См. <a
             href="#RPMCHECK">Пример 3-2</a>.</p>

            <p><a
             href="#HEREDOCREF">Встроенный документ</a> -- это особая
            форма перенаправления для блоков кода.</p>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="REDIRAPPS"></a>16.3. Область применения</h2>

            <p>Как один из вариантов грамотного применения
            перенаправления ввода/вывода, можно назвать разбор и
            &quot;сшивание&quot; вывода от команд (см. <a
             href="#READREDIR">Пример 11-6</a>). Это позволяет
            создавать файлы отчетов и журналов регистрации событий.</p>

            <div
             class="EXAMPLE">
              <a
               name="LOGEVENTS"></a>

              <p><strong>Пример 16-11. Регистрация событий</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# logevents.sh, автор: Stephane Chazelas.

# Регистрация событий в файле.
# Сценарий должен запускаться с привилегиями root (что бы иметь право на запись в /var/log).

ROOT_UID=0     # Привилегии root имеет только пользователь с $UID = 0.
E_NOTROOT=67   # Код завершения, если не root.


if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo &quot;Сценарий должен запускаться с привилегиями root.&quot;
  exit $E_NOTROOT
fi


FD_DEBUG1=3
FD_DEBUG2=4
FD_DEBUG3=5

# Раскомментарьте одну из двух строк, ниже, для активизации сценария.
# LOG_EVENTS=1
# LOG_VARS=1


log()  # Запись даты и времени в файл.
{
echo &quot;$(date)  $*&quot; &gt;&amp;7     # Добавляет в конец файла.
                              # См. ниже.
}



case $LOG_LEVEL in
 1) exec 3&gt;&amp;2         4&gt; /dev/null 5&gt; /dev/null;;
 2) exec 3&gt;&amp;2         4&gt;&amp;2         5&gt; /dev/null;;
 3) exec 3&gt;&amp;2         4&gt;&amp;2         5&gt;&amp;2;;
 *) exec 3&gt; /dev/null 4&gt; /dev/null 5&gt; /dev/null;;
esac

FD_LOGVARS=6
if [[ $LOG_VARS ]]
then exec 6&gt;&gt; /var/log/vars.log
else exec 6&gt; /dev/null               # Подавить вывод.
fi

FD_LOGEVENTS=7
if [[ $LOG_EVENTS ]]
then
  # then exec 7 &gt;(exec gawk &#39;{print strftime(), $0}&#39; &gt;&gt; /var/log/event.log)
  # Строка, выше, не работает в Bash, версии 2.04.
  exec 7&gt;&gt; /var/log/event.log        # Добавление в конец &quot;event.log&quot;.
  log                                      # Записать дату и время.
else exec 7&gt; /dev/null                  # Подавить вывод.
fi

echo &quot;DEBUG3: beginning&quot; &gt;&amp;${FD_DEBUG3}

ls -l &gt;&amp;5 2&gt;&amp;4                       # command1 &gt;&amp;5 2&gt;&amp;4

echo &quot;Done&quot;                                # command2

echo &quot;sending mail&quot; &gt;&amp;${FD_LOGEVENTS}   # Написать &quot;sending mail&quot; в дескр. #7.


exit 0
</pre>
            </div>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="HERE-DOCS"></a>Глава 17. Встроенные документы</h1>

          <p><a
           name="HEREDOCREF"></a></p>

          <p><em
           class="FIRSTTERM">Встроенный документ</em> (here document)
          является специальной формой <a
           href="#IOREDIRREF">перенаправления ввода/вывода</a>, которая
          позволяет передать список команд интерактивной программе или
          команде, например <a
           href="#FTPREF">ftp</a>, <a
           href="#TELNETREF">telnet</a> или <strong
           class="COMMAND">ex</strong>. Конец встроенного документа
          выделяется <span
           class="QUOTE">&quot;строкой-ограничителем&quot;</span>,
          которая задается с помощью специальной последовательности
          символов <span
           class="TOKEN">&lt;&lt;</span>. Эта последовательность --
          есть перенаправление вывода из файла в программу, напоминает
          конструкцию <tt
           class="USERINPUT"><strong>interactive-program &lt;
          command-file</strong></tt>, где <tt
           class="FILENAME">command-file</tt> содержит строки:</p>
<pre
 class="PROGRAMLISTING">
command #1
command #2
...
</pre>
          <br>
          <br>

          <p>Сценарий, использующий <span
           class="QUOTE">&quot;встроенный документ&quot;</span> для тех
          же целей, может выглядеть примерно так:</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
interactive-program &lt;&lt;LimitString
command #1
command #2
...
LimitString
</pre>
          <br>
          <br>

          <p>В качестве строки-ограничителя должна выбираться такая
          последовательность символов, которая не будет встречаться в
          теле <span
           class="QUOTE">&quot;встроенного документа&quot;</span>.</p>

          <p>Обратите внимание: использование <span
           class="emphasis"><em
           class="EMPHASIS">встроенных документов</em></span> может
          иногда с успехом применяться и при работе с неинтерактивными
          командами и утилитами.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX69"></a>

            <p><strong>Пример 17-1. dummyfile: Создание 2-х строчного
            файла-заготовки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Неинтерактивное редактирование файла с помощью &#39;vi&#39;.
# Эмуляция &#39;sed&#39;.

E_BADARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

TARGETFILE=$1

# Вставить 2 строки в файл и сохранить.
#--------Начало встроенного документа-----------#
vi $TARGETFILE &lt;&lt;x23LimitStringx23
i
Это строка 1.
Это строка 2.
^[
ZZ
x23LimitStringx23
#----------Конец встроенного документа-----------#

#  Обратите внимание: ^[, выше -- это escape-символ
#+ Control-V &lt;Esc&gt;.

#  Bram Moolenaar указывает, что этот скрипт может не работать с &#39;vim&#39;,
#+ из-за возможных проблем взаимодействия с терминалом.

exit 0
</pre>
          </div>

          <p>Этот сценарий, с тем же эффектом, мог бы быть реализован,
          основываясь не на <strong
           class="COMMAND">vi</strong>, а на <strong
           class="COMMAND">ex</strong>. Встроенные документы,
          содержащие команды для <strong
           class="COMMAND">ex</strong>, стали настолько обычным делом,
          что их уже смело можно вынести в отдельную категорию -- <em
           class="FIRSTTERM">ex-сценарии</em>.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX70"></a>

            <p><strong>Пример 17-2. broadcast: Передача сообщения всем,
            работающим в системе, пользователям</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

wall &lt;&lt;zzz23EndOfMessagezzz23
Пошлите, по электронной почте, ваш заказ на пиццу, системному администратору.
    (Добавьте дополнительный доллар, если вы желаете положить на пиццу анчоусы или грибы.)
# Внимание: строки комментария тоже будут переданы команде &#39;wall&#39; как часть текста.
zzz23EndOfMessagezzz23

# Возможно, более эффективно это может быть сделано так:
#         wall &lt;message-file
# Однако, встроенный документ помогает сэкономить ваши силы и время.

exit 0
</pre>
          </div>

          <div
           class="EXAMPLE">
            <a
             name="EX71"></a>

            <p><strong>Пример 17-3. Вывод многострочных сообщений с
            помощью cat</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Команда &#39;echo&#39; прекрасно справляется с выводом однострочных сообщений,
# но иногда необходимо вывести несколько строк.
# Команда &#39;cat&#39; и встроенный документ помогут вам в этом.

cat &lt;&lt;End-of-message
-------------------------------------
Это первая строка сообщения.
Это вторая строка сообщения.
Это третья строка сообщения.
Это четвертая строка сообщения.
Это последняя строка сообщения.
-------------------------------------
End-of-message

exit 0


#--------------------------------------------
# Команда &quot;exit 0&quot;, выше, не позволить исполнить нижележащие строки.

# S.C. отмечает, что следующий код работает точно так же.
echo &quot;-------------------------------------
Это первая строка сообщения.
Это вторая строка сообщения.
Это третья строка сообщения.
Это четвертая строка сообщения.
Это последняя строка сообщения.
-------------------------------------&quot;
# Однако, в этом случае, двойные кавычки в теле сообщения, должны экранироваться.
</pre>
          </div>

          <p>Если строка-ограничитель встроенного документа начинается
          с символа <tt
           class="OPTION">-</tt> (<tt
           class=
          "USERINPUT"><strong>&lt;&lt;-LimitString</strong></tt>), то
          это приводит к подавлению вывода символов табуляции (но не
          пробелов). Это может оказаться полезным при форматировании
          текста сценария для большей удобочитаемости.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX71A"></a>

            <p><strong>Пример 17-4. Вывод многострочных сообщений с
            подавлением символов табуляции</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# То же, что и предыдущий сценарий, но...

#  Символ &quot;-&quot;, начинающий строку-ограничитель встроенного документа: &lt;&lt;-
#  подавляет вывод символов табуляции, которые могут встречаться в теле документа,
#  но не пробелов.

cat &lt;&lt;-ENDOFMESSAGE
        Это первая строка сообщения.
        Это вторая строка сообщения.
        Это третья строка сообщения.
        Это четвертая строка сообщения.
        Это последняя строка сообщения.
ENDOFMESSAGE
# Текст, выводимый сценарием, будет смещен влево.
# Ведущие символы табуляции не будут выводиться.

# Вышеприведенные 5 строк текста &quot;сообщения&quot; начинаются с табуляции, а не с пробелов.


exit 0
</pre>
          </div>

          <p>Встроенные документы поддерживают подстановку команд и
          параметров. Что позволяет передавать различные параметры в
          тело встроенного документа.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX71B"></a>

            <p><strong>Пример 17-5. Встроенные документы и подстановка
            параметров</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вывод встроенного документа командой &#39;cat&#39;, с использованием подстановки параметров.

# Попробуйте запустить сценарий без аргументов,   ./scriptname
# Попробуйте запустить сценарий с одним аргументом,   ./scriptname Mortimer
# Попробуйте запустить сценарий с одним аргументом, из двух слов, в кавычках,
#                           ./scriptname &quot;Mortimer Jones&quot;

CMDLINEPARAM=1     # Минимальное число аргументов командной строки.

if [ $# -ge $CMDLINEPARAM ]
then
  NAME=$1          # Если аргументов больше одного,
                   # то рассматривается только первый.
else
  NAME=&quot;John Doe&quot;  # По-умолчанию, если сценарий запущен без аргументов.
fi

RESPONDENT=&quot;автора этого сценария&quot;


cat &lt;&lt;Endofmessage

Привет, $NAME!
Примите поздравления от $RESPONDENT.

# Этот комментарий тоже выводится (почему?).

Endofmessage

# Обратите внимание на то, что пустые строки тоже выводятся.

exit 0
</pre>
          </div>

          <p>Заключая строку-ограничитель в кавычки или экранируя ее,
          можно запретить подстановку параметров в теле встроенного
          документа.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX71C"></a>

            <p><strong>Пример 17-6. Отключение подстановки
            параметров</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вывод встроенного документа командой &#39;cat&#39;, с запретом подстановки параметров.

NAME=&quot;John Doe&quot;
RESPONDENT=&quot;автора этого сценария&quot;

cat &lt;&lt;&#39;Endofmessage&#39;

Привет, $NAME.
Примите поздравления от $RESPONDENT.

Endofmessage

#  Подстановка параметров не производится, если строка ограничитель
#  заключена в кавычки или экранирована.
#  Тот же эффект дают:
#  cat &lt;&lt;&quot;Endofmessage&quot;
#  cat &lt;&lt;\Endofmessage

exit 0
</pre>
          </div>

          <p>Еще один пример сценария, содержащего встроенный документ
          и подстановку параметров в его теле.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX72"></a>

            <p><strong>Пример 17-7. Передача пары файлов во входящий
            каталог на <span
             class="QUOTE">&quot;Sunsite&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# upload.sh

# Передача пары файлов (Filename.lsm, Filename.tar.gz)
# на Sunsite (ibiblio.org).

E_ARGERROR=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_ARGERROR
fi


Filename=`basename $1`           # Отсечь имя файла от пути к нему.

Server=&quot;ibiblio.org&quot;
Directory=&quot;/incoming/Linux&quot;
# Вообще, эти строки должны бы не &quot;зашиваться&quot; жестко в сценарий,
# а приниматься в виде аргумента из командной строки.

Password=&quot;your.e-mail.address&quot;   # Измените на свой.

ftp -n $Server &lt;&lt;End-Of-Session
# Ключ -n запрещает автоматическую регистрацию (auto-logon)

user anonymous &quot;$Password&quot;
binary
bell                # &quot;Звякнуть&quot; после передачи каждого файла
cd $Directory
put &quot;$Filename.lsm&quot;
put &quot;$Filename.tar.gz&quot;
bye
End-Of-Session

exit 0
</pre>
          </div>

          <p>Встроенные документы могут передаваться на вход функции,
          находящейся в том же сценарии.</p>

          <div
           class="EXAMPLE">
            <a
             name="HF"></a>

            <p><strong>Пример 17-8. Встроенные документы и
            функции</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# here-function.sh

GetPersonalData ()
{
  read firstname
  read lastname
  read address
  read city
  read state
  read zipcode
} # Это немного напоминает интерактивную функцию, но...


# Передать ввод в функцию.
GetPersonalData &lt;&lt;RECORD001
Bozo
Bozeman
2726 Nondescript Dr.
Baltimore
MD
21226
RECORD001


echo
echo &quot;$firstname $lastname&quot;
echo &quot;$address&quot;
echo &quot;$city, $state $zipcode&quot;
echo

exit 0
</pre>
          </div>

          <p><a
           name="ANONHEREDOC0"></a></p>

          <p>Встроенный документ можно передать &quot;пустой
          команде&quot; <span
           class="TOKEN">:</span>. Такая конструкция, фактически,
          создает <span
           class="QUOTE">&quot;анонимный&quot;</span> встроенный
          документ.</p>

          <div
           class="EXAMPLE">
            <a
             name="ANONHEREDOC"></a>

            <p><strong>Пример 17-9. <span
             class="QUOTE">&quot;Анонимный&quot;</span> Встроенный
            Документ</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

: &lt;&lt;TESTVARIABLES
${HOSTNAME?}${USER?}${MAIL?}  # Если одна из переменных не определена, то выводится сообщение об ошибке.
TESTVARIABLES

exit 0
</pre>
          </div>

          <p><a
           name="CBLOCK1"></a></p>

          <div
           class="TIP">
            <table
             class="TIP"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/tip.gif"
                 hspace="5"
                 alt="Tip"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Подобную технику можно использовать для создания
                  <span
                   class="QUOTE">&quot;блочных
                  комментариев&quot;</span>.</p>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="EXAMPLE">
            <a
             name="COMMENTBLOCK"></a>

            <p><strong>Пример 17-10. Блочный комментарий</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# commentblock.sh

: &lt;&lt; COMMENTBLOCK
echo &quot;Эта строка не будет выведена.&quot;
Эта строка комментария не начинается с символа &quot;#&quot;.
Это еще одна строка комментария, которая начинается не с символа &quot;#&quot;.

&amp;*@!!++=
Эта строка не вызовет ошибки,
поскольку Bash проигнорирует ее.
COMMENTBLOCK

echo &quot;Код завершения  \&quot;COMMENTBLOCK\&quot; = $?.&quot;   # 0
# Показывает, что ошибок не возникало.


#  Такая методика создания блочных комментариев
#+ может использоваться для комментирования блоков кода во время отладки.
#  Это экономит силы и время, т.к. не нужно втавлять символ &quot;#&quot; в начале каждой строки,
#+ а затем удалять их.

: &lt;&lt; DEBUGXXX
for file in *
do
 cat &quot;$file&quot;
done
DEBUGXXX

exit 0
</pre>
          </div>

          <div
           class="TIP">
            <table
             class="TIP"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/tip.gif"
                 hspace="5"
                 alt="Tip"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Еще одно остроумное применение встроенных
                  документов -- встроенная справка к сценарию.</p>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="EXAMPLE">
            <a
             name="SELFDOCUMENT"></a>

            <p><strong>Пример 17-11. Встроенная справка к
            сценарию</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# self-document.sh: сценарий со встроенной справкой
# Модификация сценария &quot;colm.sh&quot;.

DOC_REQUEST=70

if [ &quot;$1&quot; = &quot;-h&quot;  -o &quot;$1&quot; = &quot;--help&quot; ]     # Request help.
then
  echo; echo &quot;Порядок использования: $0 [directory-name]&quot;; echo
  sed --silent -e &#39;/DOCUMENTATIONXX$/,/^DOCUMENTATION/p&#39; &quot;$0&quot; |
  sed -e &#39;/DOCUMENTATIONXX/d&#39;; exit $DOC_REQUEST; fi

: &lt;&lt; DOCUMENTATIONXX
Сценарий выводит сведения о заданном каталоге в виде таблице.
-------------------------------------------------------------
Сценарию необходимо передать имя каталога. Если каталог не
указан или он недоступен для чтения, то выводятся сведения
о текущем каталоге.

DOCUMENTATIONXX

if [ -z &quot;$1&quot; -o ! -r &quot;$1&quot; ]
then
  directory=.
else
  directory=&quot;$1&quot;
fi

echo &quot;Сведения о каталоге &quot;$directory&quot;:&quot;; echo
(printf &quot;PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n&quot; \
; ls -l &quot;$directory&quot; | sed 1d) | column -t

exit 0
</pre>
          </div>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Для встроенных документов, во время исполнения,
                  создаются временные файлы, но эти файлы удаляются
                  после открытия и недоступны для других процессов.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>bash -c &#39;lsof -a -p $$ -d0&#39; &lt;&lt; EOF</strong></tt>
<tt
 class="PROMPT">&gt;</tt> <tt
 class="USERINPUT"><strong>EOF</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">lsof    1213 bozo    0r   REG    3,5    0 30386 /tmp/t1213-0-sh (deleted)</tt>
             
</pre>
                  <br>
                  <br>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="CAUTION">
            <table
             class="CAUTION"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/caution.gif"
                 hspace="5"
                 alt="Caution"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Некоторые утилиты не могут работать внутри <span
                   class="emphasis"><em
                   class="EMPHASIS">встроенных
                  документов</em></span>.</p>
                </td>
              </tr>
            </table>
          </div>

          <p>Если какая либо задача не может быть решена с помощью
          <span
           class="QUOTE">&quot;встроенного документа&quot;</span>, то
          вам следует попробовать язык сценариев <strong
           class="COMMAND">expect</strong>, который приспособлен для
          передачи параметров на вход интерактивных программ.</p>
        </div>
      </div>

      <div
       class="PART">
        <a
         name="PART4"></a>

        <div
         class="TITLEPAGE">
          <h1
           class="TITLE">Часть 4. Материал повышенной сложности</h1>

          <div
           class="PARTINTRO">
            <a
             name="AEN11891"></a>

            <p>Итак, мы вплотную подошли к изучению очень сложных и
            необычных аспектов написания сценариев. В этой части мы
            попытаемся <span
             class="QUOTE">&quot;сбросить покров тайны&quot;</span> и
            <span
             class="emphasis"><em
             class="EMPHASIS">заглянуть за пределы известного нам
            мира</em></span> (представьте себе путешествие по
            территории, не отмеченной на карте).</p>
          </div>

          <div
           class="TOC">
            <dl>
              <dt><strong>Содержание</strong></dt>

              <dt>18. <a
               href="#REGEXP">Регулярные выражения</a></dt>

              <dd>
                <dl>
                  <dt>18.1. <a
                   href="#AEN11904">Краткое введение в регулярные
                  выражения</a></dt>

                  <dt>18.2. <a
                   href="#GLOBBINGREF">Globbing -- Подстановка имен
                  файлов</a></dt>
                </dl>
              </dd>

              <dt>19. <a
               href="#SUBSHELLS">Подоболочки, или Subshells</a></dt>

              <dt>20. <a
               href="#RESTRICTED-SH">Ограниченный режим командной
              оболочки</a></dt>

              <dt>21. <a
               href="#PROCESS-SUB">Подстановка процессов</a></dt>

              <dt>22. <a
               href="#FUNCTIONS">Функции</a></dt>

              <dd>
                <dl>
                  <dt>22.1. <a
                   href="#COMPLEXFUNCT">Сложные функции и сложности с
                  функциями</a></dt>

                  <dt>22.2. <a
                   href="#LOCALVAR">Локальные переменные</a></dt>

                  <dd>
                    <dl>
                      <dt>22.2.1. <a
                       href="#LOCVARRECUR">Локальные переменные делают
                      возможной рекурсию.</a></dt>
                    </dl>
                  </dd>
                </dl>
              </dd>

              <dt>23. <a
               href="#ALIASES">Псевдонимы</a></dt>

              <dt>24. <a
               href="#LIST-CONS">Списки команд</a></dt>

              <dt>25. <a
               href="#ARRAYS">Массивы</a></dt>

              <dt>26. <a
               href="#FILES">Файлы</a></dt>

              <dt>27. <a
               href="#DEVPROC">/dev и /proc</a></dt>

              <dd>
                <dl>
                  <dt>27.1. <a
                   href="#DEVREF1"><tt
                   class="FILENAME">/dev</tt></a></dt>

                  <dt>27.2. <a
                   href="#PROCREF1"><tt
                   class="FILENAME">/proc</tt></a></dt>
                </dl>
              </dd>

              <dt>28. <a
               href="#ZEROS">/dev/zero и /dev/null</a></dt>

              <dt>29. <a
               href="#DEBUGGING">Отладка сценариев</a></dt>

              <dt>30. <a
               href="#OPTIONS">Необязательные параметры
              (ключи)</a></dt>

              <dt>31. <a
               href="#GOTCHAS">Широко распространенные ошибки</a></dt>

              <dt>32. <a
               href="#SCRSTYLE">Стиль программирования</a></dt>

              <dd>
                <dl>
                  <dt>32.1. <a
                   href="#UNOFFICIALST">Неофициальные рекомендации по
                  оформлению сценариев</a></dt>
                </dl>
              </dd>

              <dt>33. <a
               href="#MISCELLANY">Разное</a></dt>

              <dd>
                <dl>
                  <dt>33.1. <a
                   href="#INTANDNONINT">Интерактивный и неинтерактивный
                  режим работы</a></dt>

                  <dt>33.2. <a
                   href="#WRAPPER">Сценарии-обертки</a></dt>

                  <dt>33.3. <a
                   href="#TESTSANDCOMPARISONS">Операции сравнения:
                  Альтернативные решения</a></dt>

                  <dt>33.4. <a
                   href="#RECURSIONSCT">Рекурсия</a></dt>

                  <dt>33.5. <a
                   href="#COLORIZING"><span
                   class="QUOTE">&quot;Цветные&quot;</span>
                  сценарии</a></dt>

                  <dt>33.6. <a
                   href="#OPTIMIZATIONS">Оптимизация</a></dt>

                  <dt>33.7. <a
                   href="#ASSORTEDTIPS">Разные советы</a></dt>

                  <dt>33.8. <a
                   href="#SECURITYISSUES">Проблемы
                  безопасности</a></dt>

                  <dt>33.9. <a
                   href="#PORTABILITYISSUES">Проблемы
                  переносимости</a></dt>

                  <dt>33.10. <a
                   href="#WINSCRIPT">Сценарии командной оболочки под
                  Windows</a></dt>
                </dl>
              </dd>

              <dt>34. <a
               href="#BASH2">Bash, версия 2</a></dt>
            </dl>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="REGEXP"></a>Глава 18. Регулярные выражения</h1>

          <p><a
           name="REGEXREF"></a></p>

          <p>Для того, чтобы полностью реализовать потенциал командной
          оболочки, вам придется овладеть Регулярными Выражениями.
          Многие команды и утилиты, обычно используемые в сценариях,
          такие как <a
           href="#GREPREF">grep</a>, <a
           href="#EXPRREF">expr</a>, <a
           href="#SEDREF">sed</a> и <a
           href="#AWKREF">awk</a>, используют Регулярные Выражения.</p>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="AEN11904"></a>18.1. Краткое введение в регулярные
            выражения</h2>

            <p>Выражение -- это строка символов. Символы, которые имеют
            особое назначение, называются <span
             class="emphasis"><em
             class="EMPHASIS">метасимволами</em></span>. Так, например,
            кавычки могут выделять прямую речь, т.е. быть <span
             class="emphasis"><em
             class="EMPHASIS">метасимволами</em></span> для строки,
            заключенной в эти кавычки. Регулярные выражения -- это
            набор символов и/или метасимволов, которые наделены особыми
            свойствами. <a
             name="AEN11909"
             href="#FTN.AEN11909"><span
             class="footnote">[46]</span></a></p>

            <p>Основное назначение регулярных выражений -- это поиск
            текста по шаблону и работа со строками.</p>

            <ul>
              <li>
                <p>Звездочка -- <span
                 class="TOKEN">*</span> -- означает любое количество
                символов в строке, предшествующих
                &quot;звездочке&quot;, <span
                 class="emphasis"><em
                 class="EMPHASIS">в том числе и нулевое число
                символов</em></span>.</p>

                <p>Выражение <span
                 class="QUOTE">&quot;1133*&quot;</span> -- означает <tt
                 class="REPLACEABLE"><em>11 + один или более символов
                &quot;3&quot; + любые другие символы</em></tt>: <tt
                 class="REPLACEABLE"><em>113</em></tt>, <tt
                 class="REPLACEABLE"><em>1133</em></tt>, <tt
                 class="REPLACEABLE"><em>113312</em></tt>, и так
                далее.</p>
              </li>

              <li>
                <p><a
                 name="REGEXDOT"></a>Точка -- <span
                 class="TOKEN">.</span> -- означает не менее одного
                любого символа, за исключением символа перевода строки
                (\n). <a
                 name="AEN11937"
                 href="#FTN.AEN11937"><span
                 class="footnote">[47]</span></a></p>

                <p>Выражение <span
                 class="QUOTE">&quot;13.&quot;</span> будет означать
                <tt
                 class="REPLACEABLE"><em>13 + по меньшей мере один
                любой символ (включая пробел)</em></tt>: <tt
                 class="REPLACEABLE"><em>1133</em></tt>, <tt
                 class="REPLACEABLE"><em>11333</em></tt>, но не <tt
                 class="REPLACEABLE"><em>13</em></tt> (отсутствуют
                дополнительные символы).</p>
              </li>

              <li>
                <p>Символ -- <span
                 class="TOKEN">^</span> -- означает начало строки, но
                иногда, в зависимости от контекста, означает отрицание
                в регулярных выражениях.</p>
              </li>

              <li>
                <p><a
                 name="DOLLARSIGNREF"></a></p>

                <p>Знак доллара -- <span
                 class="TOKEN">$</span> -- в конце регулярного
                выражения соответствует концу строки.</p>

                <p>Выражение <span
                 class="QUOTE">&quot;^$&quot;</span> соответствует
                пустой строке.</p>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Символы <span
                         class="TOKEN">^</span> и <span
                         class="TOKEN">$</span> иногда еще называют
                        <span
                         class="emphasis"><em
                         class="EMPHASIS">якорями</em></span>,
                        поскольку они означают, или закрепляют, позицию
                        в регулярных выражениях.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </li>

              <li>
                <p><a
                 name="BRACKETSREF"></a></p>

                <p>Квадратные скобки -- <span
                 class="TOKEN">[...]</span> -- предназначены для
                задания подмножества символов. Квадратные скобки,
                внутри регулярного выражения, считаются одним символом,
                который может принимать значения, перечисленные внутри
                этих скобок..</p>

                <p>Выражение <span
                 class="QUOTE">&quot;[xyz]&quot;</span> --
                соответствует одному из символов <tt
                 class="REPLACEABLE"><em>x</em></tt>, <tt
                 class="REPLACEABLE"><em>y</em></tt> или <tt
                 class="REPLACEABLE"><em>z</em></tt>.</p>

                <p>Выражение <span
                 class="QUOTE">&quot;[c-n]&quot;</span> соответствует
                одному из символов в диапазоне от <tt
                 class="REPLACEABLE"><em>c</em></tt> до <tt
                 class="REPLACEABLE"><em>n</em></tt>, включительно.</p>

                <p>Выражение <span
                 class="QUOTE">&quot;[B-Pk-y]&quot;</span>
                соответствует одному из символов в диапазоне от <tt
                 class="REPLACEABLE"><em>B</em></tt> до <tt
                 class="REPLACEABLE"><em>P</em></tt> или в диапазоне от
                <tt
                 class="REPLACEABLE"><em>k</em></tt> до <tt
                 class="REPLACEABLE"><em>y</em></tt>, включительно.</p>

                <p>Выражение <span
                 class="QUOTE">&quot;[a-z0-9]&quot;</span>
                соответствует одному из символов латиницы в нижнем
                регистре или цифре.</p>

                <p>Выражение <span
                 class="QUOTE">&quot;[^b-d]&quot;</span> соответствует
                любому символу, кроме символов из диапазона от <tt
                 class="REPLACEABLE"><em>b</em></tt> до <tt
                 class="REPLACEABLE"><em>d</em></tt>, включительно. В
                данном случае, метасимвол <span
                 class="TOKEN">^</span> означает отрицание.</p>

                <p>Объединяя квадратные скобки в одну
                последовательность, можно задать шаблон искомого слова.
                Так, выражение <span
                 class="QUOTE">&quot;[Yy][Ee][Ss]&quot;</span>
                соответствует словам <tt
                 class="REPLACEABLE"><em>yes</em></tt>, <tt
                 class="REPLACEABLE"><em>Yes</em></tt>, <tt
                 class="REPLACEABLE"><em>YES</em></tt>, <tt
                 class="REPLACEABLE"><em>yEs</em></tt> и так далее.
                Выражение <span
                 class=
                "QUOTE">&quot;[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]&quot;</span>
                определяет шаблон для поиска любого номера карточки
                социального страхования (для США).</p>
              </li>

              <li>
                <p>Обратный слэш -- <span
                 class="TOKEN">\</span> -- служит для <a
                 href="#ESCP">экранирования</a> специальных символов,
                это означает, что экранированные символы должны
                интерпретироваться буквально, т.е. как простые
                символы.</p>

                <p>Комбинация <span
                 class="QUOTE">&quot;\$&quot;</span> указывает на то,
                что символ <span
                 class="QUOTE">&quot;$&quot;</span> трактуется как
                обычный символ, а не как признак конца строки в
                регулярных выражениях. Аналогично, комбинация <span
                 class="QUOTE">&quot;\\&quot;</span> соответствует
                простому символу <span
                 class="QUOTE">&quot;\&quot;</span>.</p>
              </li>

              <li>
                <p><a
                 name="ANGLEBRAC"></a></p>

                <p><a
                 href="#ESCP">Экранированные</a> <span
                 class="QUOTE">&quot;угловые скобки&quot;</span> --
                <span
                 class="TOKEN">\&lt;...\&gt;</span> -- отмечают границы
                слова.</p>

                <p>Угловые скобки должны экранироваться, иначе они
                будут интерпретироваться как простые символы.</p>

                <p>Выражение <span
                 class="QUOTE">&quot;\&lt;the\&gt;&quot;</span>
                соответствует слову <span
                 class="QUOTE">&quot;the&quot;</span>, и не
                соответствует словам <span
                 class="QUOTE">&quot;them&quot;</span>, <span
                 class="QUOTE">&quot;there&quot;</span>, <span
                 class="QUOTE">&quot;other&quot;</span> и т.п.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat textfile</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">This is line 1, of which there is only one instance.
This is the only instance of line 2.
This is line 3, another line.
This is line 4.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep &#39;the&#39; textfile</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">This is line 1, of which there is only one instance.
This is the only instance of line 2.
This is line 3, another line.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep &#39;\&lt;the\&gt;&#39; textfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">This is the only instance of line 2.</tt>
             
</pre>
                <br>
                <br>
              </li>
            </ul>

            <ul>
              <li
               style="list-style-type: square">
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   name="EXTREGEX"></a>Дополнительные
                  метасимволы.</strong> Использующиеся при работе с <a
                   href="#EGREPREF">egrep</a>, <a
                   href="#AWKREF">awk</a> и <a
                   href="#PERLREF">Perl</a></p>
                </div>
              </li>

              <li>
                <p><a
                 name="QUEXREGEX"></a></p>

                <p>Знак вопроса -- <span
                 class="TOKEN">?</span> -- означает, что предыдущий
                символ или регулярное выражение встречается 0 или 1
                раз. В основном используется для поиска одиночных
                символов.</p>
              </li>

              <li>
                <p><a
                 name="PLUSREF"></a></p>

                <p>Знак &quot;плюс&quot; -- <span
                 class="TOKEN">+</span> -- указывает на то, что
                предыдущий символ или выражение встречается 1 или более
                раз. Играет ту же роль, что и символ
                &quot;звездочка&quot; (<span
                 class="TOKEN">*</span>), за исключением случая
                нулевого количества вхождений.</p>
<pre
 class="PROGRAMLISTING">
# GNU версии sed и awk допускают использование &quot;+&quot;,
# но его необходимо экранировать.

echo a111b | sed -ne &#39;/a1\+b/p&#39;
echo a111b | grep &#39;a1\+b&#39;
echo a111b | gawk &#39;/a1+b/&#39;
# Все три варианта эквивалентны.

# Спасибо S.C.
</pre>
                <br>
                <br>
              </li>

              <li>
                <p><a
                 href="#ESCP">Экранированные</a> <span
                 class="QUOTE">&quot;фигурные скобки&quot;</span> --
                <span
                 class="TOKEN">\{ \}</span> -- задают число вхождений
                предыдущего выражения.</p>

                <p>Экранирование фигурных скобок -- обязательное
                условие, иначе они будут интерпретироваться как простые
                символы. Такой порядок использования, технически, не
                является частью основного набора правил построения
                регулярных выражений.</p>

                <p>Выражение <span
                 class="QUOTE">&quot;[0-9]\{5\}&quot;</span> -- в
                точности соответствует подстроке из пяти десятичных
                цифр (символов из диапазона от 0 до 9,
                включительно).</p>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>В <span
                         class="QUOTE">&quot;классической&quot;</span>
                        (не совместимой с POSIX) версии <a
                         href="#AWKREF">awk</a>, фигурные скобки не
                        могут быть использованы. Однако, в <strong
                         class="COMMAND">gawk</strong> предусмотрен
                        ключ <tt
                         class="OPTION">--re-interval</tt>, который
                        позволяет использовать (неэкранированные)
                        фигурные скобки.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo 2222 | gawk --re-interval &#39;/2{3}/&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">2222</tt>
             
</pre>
                        <br>
                        <br>

                        <p>Язык программирования <strong
                         class="COMMAND">Perl</strong> и некоторые
                        версии <strong
                         class="COMMAND">egrep</strong> не требуют
                        экранирования фигурных скобок.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </li>

              <li>
                <p>Круглые скобки -- <strong
                 class="COMMAND">( )</strong> -- предназначены для
                выделения групп регулярных выражений. Они полезны при
                использовании с оператором <span
                 class="QUOTE">&quot;<span
                 class="TOKEN">|</span>&quot;</span> и при <a
                 href="#EXPRPAREN">извлечении подстроки</a> с помощью
                команды <a
                 href="#EXPRREF">expr</a>.</p>
              </li>

              <li>
                <p>Вертикальная черта -- <strong
                 class="COMMAND">|</strong> -- выполняет роль
                логического оператора <span
                 class="QUOTE">&quot;ИЛИ&quot;</span> в регулярных
                выражениях и служит для задания набора альтернатив.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>egrep &#39;re(a|e)d&#39; misc.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">People who read seem to be better informed than those who do not.
The clarinet produces sound by the vibration of its reed.</tt>
             
</pre>
                <br>
                <br>
              </li>
            </ul>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Некоторые версии <strong
                     class="COMMAND">sed</strong>, <strong
                     class="COMMAND">ed</strong> и <strong
                     class="COMMAND">ex</strong> поддерживают
                    экранированные версии регулярных выражений,
                    описанных выше.</p>
                  </td>
                </tr>
              </table>
            </div>

            <ul>
              <li
               style="list-style-type: square">
                <div
                 class="FORMALPARA">
                  <p><strong><a
                   name="POSIXREF"></a>Классы символов POSIX.</strong>
                  <tt
                   class=
                  "USERINPUT"><strong>[:class:]</strong></tt></p>
                </div>

                <p>Это альтернативный способ указания диапазона
                символов.</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:alnum:]</strong></tt> --
                соответствует алфавитным символам и цифрам.
                Эквивалентно выражению <tt
                 class=
                "USERINPUT"><strong>[A-Za-z0-9]</strong></tt>.</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:alpha:]</strong></tt> --
                соответствует символам алфавита. Эквивалентно выражению
                <tt
                 class="USERINPUT"><strong>[A-Za-z]</strong></tt>.</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:blank:]</strong></tt> --
                соответствует символу пробела или символу
                табуляции.</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:cntrl:]</strong></tt> --
                соответствует управляющим символам (control
                characters).</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:digit:]</strong></tt> --
                соответствует набору десятичных цифр. Эквивалентно
                выражению <tt
                 class="USERINPUT"><strong>[0-9]</strong></tt>.</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:graph:]</strong></tt>
                (печатаемые и псевдографические символы) --
                соответствует набору символов из диапазона ASCII 33 -
                126. Это то же самое, что и класс <tt
                 class="USERINPUT"><strong>[:print:]</strong></tt>, за
                исключением символа пробела.</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:lower:]</strong></tt> --
                соответствует набору алфавитных символов в нижнем
                регистре. Эквивалентно выражению <tt
                 class="USERINPUT"><strong>[a-z]</strong></tt>.</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:print:]</strong></tt>
                (печатаемые символы) -- соответствует набору символов
                из диапазона ASCII 32 - 126. По своему составу этот
                класс идентичен классу <tt
                 class="USERINPUT"><strong>[:graph:]</strong></tt>,
                описанному выше, за исключением того, что в этом классе
                дополнительно присутствует символ пробела.</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:space:]</strong></tt> --
                соответствует пробельным символам (пробел и
                горизонтальная табуляция).</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:upper:]</strong></tt> --
                соответствует набору символов алфавита в верхнем
                регистре. Эквивалентно выражению <tt
                 class="USERINPUT"><strong>[A-Z]</strong></tt>.</p>
              </li>

              <li>
                <p>Класс <tt
                 class="USERINPUT"><strong>[:xdigit:]</strong></tt> --
                соответствует набору шестнадцатиричных цифр.
                Эквивалентно выражению <tt
                 class=
                "USERINPUT"><strong>[0-9A-Fa-f]</strong></tt>.</p>

                <div
                 class="IMPORTANT">
                  <table
                   class="IMPORTANT"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/important.gif"
                       hspace="5"
                       alt="Important"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Вообще, символьные классы POSIX требуют
                        заключения в кавычки или <a
                         href="#DBLBRACKETS">двойные квадратные
                        скобки</a> ([[ ]]).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep [[:digit:]] test.file</strong></tt>
<tt
 class="COMPUTEROUTPUT">abc=723</tt>
             
</pre>
                        <br>
                        <br>

                        <p>Эти символьные классы могут использоваться,
                        с некоторыми ограничениями, даже в операциях <a
                         href="#GLOBBINGREF">подстановки имен файлов
                        (globbing)</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l ?[[:digit:]][[:digit:]]?</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo         0 Aug 21 14:47 a33b</tt>
             
</pre>
                        <br>
                        <br>

                        <p>Примеры использования символьных классов в
                        сценариях вы найдете в <a
                         href="#EX49">Пример 12-14</a> и <a
                         href="#LOWERCASE">Пример 12-15</a>.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </li>
            </ul>

            <p><a
             href="#SEDREF">Sed</a>, <a
             href="#AWKREF">awk</a> и <a
             href="#PERLREF">Perl</a>, используемые в сценариях в
            качестве фильтров, могут принимать регулярные выражения в
            качестве входных аргументов. См. <a
             href="#BEHEAD">Пример A-13</a> и <a
             href="#TREE">Пример A-19</a>.</p>

            <p>Книга &quot;Sed &amp; Awk&quot; (авторы Dougherty и
            Robbins) дает полное и ясное представление о регулярных
            выражениях (см. раздел <a
             href="#BIBLIO"><em>Литература</em></a>).</p>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="GLOBBINGREF"></a>18.2. Globbing -- Подстановка имен
            файлов</h2>

            <p>Bash, сам по себе, не распознает регулярные выражения.
            Но в сценариях можно использовать команды и утилиты, такие
            как <a
             href="#SEDREF">sed</a> и <a
             href="#AWKREF">awk</a>, которые прекрасно справляются с
            обработкой регулярных выражений.</p>

            <p>Фактически, Bash может выполнять подстановку имен
            файлов, этот процесс называется <span
             class="QUOTE">&quot;globbing&quot;</span>, но при этом
            <span
             class="emphasis"><em
             class="EMPHASIS">не</em></span> используется стандартный
            набор регулярных выражений. Вместо этого, при выполнении
            подстановки имен файлов, производится распознавание и
            интерпретация шаблонных символов. В число интерпретируемых
            шаблонов входят символы <span
             class="TOKEN">*</span> и <span
             class="TOKEN">?</span>, списки символов в квадратных
            скобках и некоторые специальные символы (например <span
             class="TOKEN">^</span>, используемый для выполнения
            операции отрицания). Применение шаблонных символов имеет
            ряд важных ограничений. Например, если имена файлов
            начинаются с точки (например так: <tt
             class="FILENAME">.bashrc</tt>), то они не будут
            соответствовать шаблону, содержащему символ <tt
             class="REPLACEABLE"><em>*</em></tt>. <a
             name="AEN12295"
             href="#FTN.AEN12295"><span
             class="footnote">[48]</span></a> Аналогично, символ <tt
             class="REPLACEABLE"><em>?</em></tt> в операции подстановки
            имен файлов имеет иной смысл, нежели в регулярных
            выражениях.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 2
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l t?.sh</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l [ab]*</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l [a-c]*</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l [^ab]*</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l {b*,c*,*est*}</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo *</strong></tt>
<tt
 class="COMPUTEROUTPUT">a.1 b.1 c.1 t2.sh test1.txt</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo t*</strong></tt>
<tt
 class="COMPUTEROUTPUT">t2.sh test1.txt</tt>
             
</pre>
            <br>
            <br>

            <p>Даже команда <a
             href="#ECHOREF">echo</a> может интерпретировать шаблонные
            символы в именах файлов.</p>

            <p>См. также <a
             href="#LISTGLOB">Пример 10-4</a>.</p>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="SUBSHELLS"></a>Глава 19. Подоболочки, или
          Subshells</h1>

          <p><a
           name="SUBSHELLSREF"></a></p>

          <p>Запуск сценария приводит к запуску дочернего командного
          интерпретатора. Который выполняет интерпретацию и исполнение
          списка команд, содержащихся в файле сценария, точно так же,
          как если бы они были введены из командной строки. Любой
          сценарий запускается как дочерний процесс <a
           href="#FORKREF">родительской</a> командной оболочки, той
          самой, которая выводит перед вами строку приглашения к вводу
          на консоли или в окне xterm.</p>

          <p>Сценарий может, так же, запустить другой дочерний процесс,
          в своей подоболочке. Это позволяет сценариям распараллелить
          процесс обработки данных по нескольким задачам, исполняемым
          одновременно.</p>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="SUBSHELLPARENS1"></a>Список команд в круглых
            скобках</strong></p>

            <dl>
              <dt>( command1; command2; command3; ... )</dt>

              <dd>
                <p>Список команд, в круглых скобках, исполняется в
                подоболочке.</p>
              </dd>
            </dl>
          </div>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p><a
                   name="PARVIS"></a>Значения переменных, определенных
                  в дочерней оболочке, <span
                   class="emphasis"><em
                   class="EMPHASIS">не</em></span> могут быть переданы
                  родительской оболочке. Они недоступны <a
                   href="#FORKREF">родительскому процессу</a>.
                  Фактически, они ведут себя как <a
                   href="#LOCALVAR">локальные переменные</a>.</p>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="EXAMPLE">
            <a
             name="SUBSHELL"></a>

            <p><strong>Пример 19-1. Область видимости
            переменных</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# subshell.sh

echo

outer_variable=Outer

(
inner_variable=Inner
echo &quot;Дочерний процесс, \&quot;inner_variable\&quot; = $inner_variable&quot;
echo &quot;Дочерний процесс, \&quot;outer\&quot; = $outer_variable&quot;
)

echo

if [ -z &quot;$inner_variable&quot; ]
then
  echo &quot;Переменная inner_variable не определена в родительской оболочке&quot;
else
  echo &quot;Переменная inner_variable определена в родительской оболочке&quot;
fi

echo &quot;Родительский процесс, \&quot;inner_variable\&quot; = $inner_variable&quot;
# Переменная $inner_variable не будет определена
# потому, что переменные, определенные в дочернем процессе,
# ведут себя как &quot;локальные переменные&quot;.

echo

exit 0
</pre>
          </div>

          <p>См. также <a
           href="#SUBPIT">Пример 31-1</a>.</p>

          <p>+</p>

          <p>Смена текущего каталога в дочернем процессе (подоболочке)
          не влечет за собой смену текущего каталога в родительской
          оболочке.</p>

          <div
           class="EXAMPLE">
            <a
             name="ALLPROFS"></a>

            <p><strong>Пример 19-2. Личные настройки
            пользователей</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# allprofs.sh: вывод личных настроек (profiles) всех пользователей

# Автор: Heiner Steven
# С некоторыми изменениями, внесенными автором документа.

FILE=.bashrc  #  Файл настроек пользователя,
              #+ в оригинальном сценарии называется &quot;.profile&quot;.

for home in `awk -F: &#39;{print $6}&#39; /etc/passwd`
do
  [ -d &quot;$home&quot; ] || continue    # Перейти к следующей итерации, если нет домашнего каталога.
  [ -r &quot;$home&quot; ] || continue    # Перейти к следующей итерации, если не доступен для чтения.
  (cd $home; [ -e $FILE ] &amp;&amp; less $FILE)
done

#  По завершении сценария -- нет теобходимости выполнять команду &#39;cd&#39;, чтобы вернуться в первоначальный каталог,
#+ поскольку &#39;cd $home&#39; выполняется в подоболочке.

exit 0
</pre>
          </div>

          <p>Подоболочка может использоваться для задания <span
           class="QUOTE">&quot;специфического окружения&quot;</span>
          для группы команд.</p>
<pre
 class="PROGRAMLISTING">
COMMAND1
COMMAND2
COMMAND3
(
  IFS=:
  PATH=/bin
  unset TERMINFO
  set -C
  shift 5
  COMMAND4
  COMMAND5
  exit 3 # Выход только из подоболочки.
)
# Изменение переменных окружения не коснется родительской оболочки.
COMMAND6
COMMAND7
</pre>
          Как вариант использования подоболочки -- проверка переменных.
          
<pre
 class="PROGRAMLISTING">
if (set -u; : $variable) 2&gt; /dev/null
then
  echo &quot;Переменная определена.&quot;
fi

# Можно сделать то же самое по другому: [[ ${variable-x} != x || ${variable-y} != y ]]
# или                                   [[ ${variable-x} != x$variable ]]
# или                                   [[ ${variable+x} = x ]])
</pre>
          Еще одно применение -- проверка файлов блокировки: 
<pre
 class="PROGRAMLISTING">
if (set -C; : &gt; lock_file) 2&gt; /dev/null
then
  echo &quot;Этот сценарий уже запущен другим пользователем.&quot;
  exit 65
fi

# Спасибо S.C.
</pre>
          <br>
          <br>

          <p>Процессы в подоболочках могут исполняться параллельно. Это
          позволяет разбить сложную задачу на несколько простых
          подзадач, выполняющих параллельную обработку информации.</p>

          <div
           class="EXAMPLE">
            <a
             name="PARALLEL-PROCESSES"></a>

            <p><strong>Пример 19-3. Запуск нескольких процессов в
            подоболочках</strong></p>
<pre
 class="PROGRAMLISTING">
       (cat list1 list2 list3 | sort | uniq &gt; list123) &amp;
        (cat list4 list5 list6 | sort | uniq &gt; list456) &amp;
        # Слияние и сортировка двух списков производится одновременно.
        # Запуск в фоне гарантирует параллельное исполнение.
        #
        # Тот же эффект дает
        #   cat list1 list2 list3 | sort | uniq &gt; list123 &amp;
        #   cat list4 list5 list6 | sort | uniq &gt; list456 &amp;

        wait   # Ожидание завершения работы подоболочек.

        diff list123 list456
</pre>
          </div>

          <p>Перенаправление ввода/вывода в/из подоболочки производится
          оператором построения конвейера <span
           class="QUOTE">&quot;|&quot;</span>, например, <tt
           class="USERINPUT"><strong>ls -al |
          (command)</strong></tt>.</p>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Блок команд, заключенный в <tt
                   class="REPLACEABLE"><em>фигурные скобки</em></tt> не
                  приводит к запуску дочерней подоболочки.</p>

                  <p>{ command1; command2; command3; ... }</p>
                </td>
              </tr>
            </table>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="RESTRICTED-SH"></a>Глава 20. Ограниченный режим
          командной оболочки</h1>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="DISABLEDCOMMREF"></a>Команды, запрещенные в
            ограниченном режиме командной оболочки</strong></p>

            <dl>
              <dd>
                <div
                 class="FORMALPARA">
                  <p>Запуск сценария или его части в <span
                   class="emphasis"><em
                   class="EMPHASIS">ограниченном</em></span> режиме,
                  приводит к наложению ограничений на использование
                  некоторых команд. Эта мера предназначена для
                  ограничения привилегий пользователя, запустившего
                  сценарий, и минимизации возможного ущерба системе,
                  который может нанести сценарий.</p>
                </div>
              </dd>

              <dd>
                <div
                 class="FORMALPARA">
                  <p>В ограниченном режиме запрещена команда <tt
                   class="REPLACEABLE"><em>cd</em></tt> -- смена
                  текщего каталога.</p>
                </div>
              </dd>

              <dd>
                <p>Запрещено изменять <a
                 href="#ENVREF">переменные окружения</a> <tt
                 class="REPLACEABLE"><em>$PATH</em></tt>, <tt
                 class="REPLACEABLE"><em>$SHELL</em></tt>, <tt
                 class="REPLACEABLE"><em>$BASH_ENV</em></tt> и <tt
                 class="REPLACEABLE"><em>$ENV</em></tt>.</p>
              </dd>

              <dd>
                <p>Заперщен доступ к переменной <tt
                 class="REPLACEABLE"><em>$SHELLOPTS</em></tt>.</p>
              </dd>

              <dd>
                <p>Запрещено перенаправление вывода.</p>
              </dd>

              <dd>
                <p>Запрещен вызов утилит, в названии которых
                присутствует хотя бы один символ &quot;слэш&quot;
                (<span
                 class="TOKEN">/</span>).</p>
              </dd>

              <dd>
                <p>Запрещен вызов команды <span
                 class="emphasis"><em
                 class="EMPHASIS">exec</em></span> для запуска другого
                процесса.</p>
              </dd>

              <dd>
                <p>Запрещен ряд других команд, которые могут
                использовать сценарий для выполнения непредусмотренных
                действий.</p>
              </dd>

              <dd>
                <p>Запрещен выход из ограниченного режима.</p>
              </dd>
            </dl>
          </div>

          <div
           class="EXAMPLE">
            <a
             name="RESTRICTED"></a>

            <p><strong>Пример 20-1. Запуск сценария в ограниченном
            режиме</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Если sha-bang задать в таком виде: &quot;#!/bin/bash -r&quot;
# то это приведет к включению ограниченного режима с момента запуска скрипта.

echo

echo &quot;Смена каталога.&quot;
cd /usr/local
echo &quot;Текущий каталог: `pwd`&quot;
echo &quot;Переход в домашний каталог.&quot;
cd
echo &quot;Текущий каталог: `pwd`&quot;
echo

# До сих пор сценарий исполнялся в обычном, неограниченном режиме.

set -r
# set --restricted    имеет тот же эффект.
echo &quot;==&gt; Переход в ограниченный режим. &lt;==&quot;

echo
echo

echo &quot;Попытка сменить текущий каталог в ограниченном режиме.&quot;
cd ..
echo &quot;Текущий каталог остался прежним: `pwd`&quot;

echo
echo

echo &quot;\$SHELL = $SHELL&quot;
echo &quot;Попытка смены командного интерпретатора в ограниченном режиме.&quot;
SHELL=&quot;/bin/ash&quot;
echo
echo &quot;\$SHELL= $SHELL&quot;

echo
echo

echo &quot;Попытка перенаправления вывода в ограниченном режиме.&quot;
ls -l /usr/bin &gt; bin.files
ls -l bin.files    # Попробуем найти файл, который пытались создать.

echo

exit 0
</pre>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="PROCESS-SUB"></a>Глава 21. Подстановка процессов</h1>

          <p><a
           name="PROCESSSUBREF"></a><tt
           class="REPLACEABLE"><em>Подстановка процессов</em></tt> --
          это аналог <a
           href="#COMMANDSUBREF">подстановки команд</a>. Операция
          подстановки команд записывает в переменную результат
          выполнения некоторой команды, например, <strong
           class="COMMAND">dir_contents=`ls -al`</strong> или <strong
           class="COMMAND">xref=$(grep word datafile)</strong>.
          Операция подстановки процессов передает вывод одного процесса
          на ввод другого (другими словами, передает результат
          выполнения одной команды -- другой).</p>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="COMMANDSPARENS1"></a>Шаблон подстановки
            команды</strong></p>

            <dl>
              <dt>Внутри круглых скобок</dt>

              <dd>
                <p><strong
                 class="COMMAND">&gt;(command)</strong></p>

                <p><strong
                 class="COMMAND">&lt;(command)</strong></p>

                <p>Таким образом инициируется подстановка процессов.
                Здесь, для передачи результата работы процесса в
                круглых скобках, используются файлы <tt
                 class="FILENAME">/dev/fd/&lt;n&gt;</tt>. <a
                 name="AEN12454"
                 href="#FTN.AEN12454"><span
                 class="footnote">[49]</span></a></p>

                <div
                 class="NOTE">
                  <table
                   class="NOTE"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/note.gif"
                       hspace="5"
                       alt="Note"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Между круглой скобкой и символом <span
                         class="QUOTE">&quot;&lt;&quot;</span> или
                        <span
                         class="QUOTE">&quot;&gt;&quot;</span>, не
                        должно быть пробелов, в противном случае это
                        вызовет сообщение об ошибке.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </dd>
            </dl>
          </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo &gt;(true)</strong></tt>
<tt
 class="COMPUTEROUTPUT">/dev/fd/63</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo &lt;(true)</strong></tt>
<tt
 class="COMPUTEROUTPUT">/dev/fd/63</tt>
             
</pre>
          Bash создает канал с двумя <a
           href="#FDREF">файловыми дескрипторами</a>, <tt
           class="FILENAME">--fIn</tt> и <tt
           class="FILENAME">fOut--</tt>. <tt
           class="FILENAME">stdin</tt> команды <a
           href="#TRUEREF">true</a> присоединяется к <tt
           class="FILENAME">fOut</tt> (dup2(fOut, 0)), затем Bash
          передает <tt
           class="FILENAME">/dev/fd/fIn</tt> в качестве аргумента
          команде <strong
           class="COMMAND">echo</strong>. В системах, где отсутствуют
          файлы <tt
           class="FILENAME">/dev/fd/&lt;n&gt;</tt>, Bash может
          использовать временные файлы. (Спасибо S.C.)<br>
          <br>
<pre
 class="PROGRAMLISTING">
cat &lt;(ls -l)
# То же самое, что и     ls -l | cat

sort -k 9 &lt;(ls -l /bin) &lt;(ls -l /usr/bin) &lt;(ls -l /usr/X11R6/bin)
# Список файлов в трех основных каталогах &#39;bin&#39;, отсортированный по именам файлов.
# Обратите внимание: на вход &#39;sort&#39; поданы три самостоятельные команды.


diff &lt;(command1) &lt;(command2)    # Выдаст различия в выводе команд.

tar cf &gt;(bzip2 -c &gt; file.tar.bz2) $directory_name
# Вызовет &quot;tar cf /dev/fd/?? $directory_name&quot; и затем &quot;bzip2 -c &gt; file.tar.bz2&quot;.
#
# Из-за особенностей, присущих некоторым системам, связанным с /dev/fd/&lt;n&gt;,
# канал между командами не обязательно должен быть именованным.
#
# Это можно сделать и так.
#
bzip2 -c &lt; pipe &gt; file.tar.bz2&amp;
tar cf pipe $directory_name
rm pipe
#        или
exec 3&gt;&amp;1
tar cf /dev/fd/4 $directory_name 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | bzip2 -c &gt; file.tar.bz2 3&gt;&amp;-
exec 3&gt;&amp;-


# Спасибо S.C.
</pre>
          <br>
          <br>

          <p>Ниже приводится еще один очень интересный пример
          использования подстановки процессов.</p>
<pre
 class="PROGRAMLISTING">
# Фрагмент сценария из дистрибутива SuSE:

while read  des what mask iface; do
# Некоторые команды ...
done &lt; &lt;(route -n)


# Чтобы проверить это, попробуем вставить команду, выполняющую какие либо действия.
while read  des what mask iface; do
  echo $des $what $mask $iface
done &lt; &lt;(route -n)

# Вывод на экран:
# Kernel IP routing table
# Destination Gateway Genmask Flags Metric Ref Use Iface
# 127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo


# Как указывает S.C. -- более простой для понимания эквивалент:
route -n |
  while read des what mask iface; do   # Переменные берут значения с устройства вывода конвейера (канала).
    echo $des $what $mask $iface
  done  #  На экран выводится то же самое, что и выше.
        #  Однако, Ulrich Gayer отметил, что ...
        #+ этот вариант запускает цикл while в подоболочке,
        #+ и поэтому переменные не видны за пределами цикла, после закрытия канала.
</pre>
          <br>
          <br>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="FUNCTIONS"></a>Глава 22. Функции</h1>

          <p><a
           name="FUNCTIONREF"></a></p>

          <p>Подобно <span
           class="QUOTE">&quot;настоящим&quot;</span> языкам
          программирования, Bash тоже имеет функции, хотя и в несколько
          ограниченном варианте. Функция -- это подпрограмма, <a
           href="#CODEBLOCKREF">блок кода</a> который реализует набор
          операций, своего рода <span
           class="QUOTE">&quot;черный ящик&quot;</span>,
          предназначенный для выполнения конкретной задачи. Функции
          могут использоваться везде, где имеются участки
          повторяющегося кода.</p>

          <p><strong
           class="COMMAND">function</strong> <tt
           class="REPLACEABLE"><em>function_name</em></tt> {<br>
           <tt
           class="REPLACEABLE"><em>command</em></tt>...<br>
           }<br>
          </p>
          или 

          <p><tt
           class="REPLACEABLE"><em>function_name</em></tt> () {<br>
           <tt
           class="REPLACEABLE"><em>command</em></tt>...<br>
           }<br>
          </p>
          <br>
          <br>

          <p>Вторая форма записи ближе к сердцу C-программистам (она же
          более переносимая).</p>

          <p>Как и в языке C, скобка, открывающая тело функции, может
          помещаться на следующей строке.</p>

          <p><tt
           class="REPLACEABLE"><em>function_name</em></tt> ()<br>
           {<br>
           <tt
           class="REPLACEABLE"><em>command</em></tt>...<br>
           }<br>
          </p>
          <br>
          <br>

          <p>Вызов функции осуществляется простым указанием ее имени в
          тексте сценария.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX59"></a>

            <p><strong>Пример 22-1. Простая функция</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

funky ()
{
  echo &quot;Это обычная функция.&quot;
} # Функция должна быть объявлена раньше, чем ее можно будет использовать.

  # Вызов функции.

funky

exit 0
</pre>
          </div>

          <p>Функция должна быть объявлена раньше, чем ее можно будет
          использовать. К сожалению, в Bash нет возможности <span
           class="QUOTE">&quot;опережающего объявления&quot;</span>
          функции, как например в C.</p>
<pre
 class="PROGRAMLISTING">
f1
# Эта строка вызовет сообщение об ошибке, поскольку функция &quot;f1&quot; еще не определена.

declare -f f1      # Это не поможет.
f1                 # По прежнему -- сообщение об ошибке.

# Однако...


f1 ()
{
  echo &quot;Вызов функции \&quot;f2\&quot; из функции \&quot;f1\&quot;.&quot;
  f2
}

f2 ()
{
  echo &quot;Функция \&quot;f2\&quot;.&quot;
}

f1  #  Функция &quot;f2&quot;, фактически, не вызывается выше этой строки,
    #+ хотя ссылка на нее встречается выше, до ее объявления.
    #  Это допускается.

    # Спасибо S.C.
</pre>
          <br>
          <br>

          <p>Допускается даже создание вложенных функций, хотя пользы
          от этого немного.</p>
<pre
 class="PROGRAMLISTING">
f1 ()
{

  f2 () # вложенная
  {
    echo &quot;Функция \&quot;f2\&quot;, вложенная в \&quot;f1\&quot;.&quot;
  }

}

f2  #  Вызывает сообщение об ошибке.
    #  Даже &quot;declare -f f2&quot; не поможет.

echo

f1  #  Ничего не происходит, простой вызов &quot;f1&quot;, не означает автоматический вызов &quot;f2&quot;.
f2  #  Теперь все нормально, вызов &quot;f2&quot; не приводит к появлению ошибки,
    #+ поскольку функция &quot;f2&quot; была определена в процессе вызова &quot;f1&quot;.

    # Спасибо S.C.
</pre>
          <br>
          <br>

          <p>Объявление функции может размещаться в самых неожиданных
          местах.</p>
<pre
 class="PROGRAMLISTING">
ls -l | foo() { echo &quot;foo&quot;; }  # Допустимо, но бесполезно.



if [ &quot;$USER&quot; = bozo ]
then
  bozo_greet ()   # Объявление функции размещено в условном операторе.
  {
    echo &quot;Привет, Bozo!&quot;
  }
fi

bozo_greet        # Работает только у пользователя bozo, другие получат сообщение об ошибке.



# Нечто подобное можно использовать с определеной пользой для себя.
NO_EXIT=1   # Will enable function definition below.

[[ $NO_EXIT -eq 1 ]] &amp;&amp; exit() { true; }     # Определение функции в последовательности &quot;И-список&quot;.
# Если $NO_EXIT равна 1, то объявляется &quot;exit ()&quot;.
# Тем самым, функция &quot;exit&quot; подменяет встроенную команду &quot;exit&quot;.

exit  # Вызывается функция &quot;exit ()&quot;, а не встроенная команда &quot;exit&quot;.

# Спасибо S.C.
</pre>
          <br>
          <br>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="COMPLEXFUNCT"></a>22.1. Сложные функции и сложности
            с функциями</h2>

            <p>Функции могут принимать входные аргументы и возвращать
            <a
             href="#EXITSTATUSREF">код завершения</a>.</p>
<pre
 class="PROGRAMLISTING">
function_name $arg1 $arg2
</pre>

            <p>Доступ к входным аргументам, в функциях, производится
            посредством <a
             href="#POSPARAMREF">позиционных параметров</a>, т.е. <tt
             class="VARNAME">$1</tt>, <tt
             class="VARNAME">$2</tt> и так далее.</p>

            <div
             class="EXAMPLE">
              <a
               name="EX60"></a>

              <p><strong>Пример 22-2. Функция с
              аргументами</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Функции и аргументы

DEFAULT=default                             # Значение аргумента по-умолчанию.

func2 () {
   if [ -z &quot;$1&quot; ]                           # Длина аргумента #1 равна нулю?
   then
     echo &quot;-Аргумент #1 имеет нулевую длину.-&quot;  # Или аргумент не был передан функции.
   else
     echo &quot;-Аргумент #1: \&quot;$1\&quot;.-&quot;
   fi

   variable=${1-$DEFAULT}                   #  Что делает
   echo &quot;variable = $variable&quot;              #+ показанная подстановка параметра?
                                            #  ---------------------------
                                            #  Она различает отсутствующий аргумент
                                            #+ от &quot;пустого&quot; аргумента.

   if [ &quot;$2&quot; ]
   then
     echo &quot;-Аргумент #2: \&quot;$2\&quot;.-&quot;
   fi

   return 0
}

echo

echo &quot;Вызов функции без аргументов.&quot;
func2
echo


echo &quot;Вызов функции с \&quot;пустым\&quot; аргументом.&quot;
func2 &quot;&quot;
echo

echo &quot;Вызов функции с неинициализированным аргументом.&quot;
func2 &quot;$uninitialized_param&quot;
echo

echo &quot;Вызов функции с одним аргументом.&quot;
func2 first
echo

echo &quot;Вызов функции с двумя аргументами.&quot;
func2 first second
echo

echo &quot;Вызов функции с аргументами \&quot;\&quot; \&quot;second\&quot;.&quot;
func2 &quot;&quot; second       # Первый параметр &quot;пустой&quot;
echo                  # и второй параметр -- ASCII-строка.

exit 0
</pre>
            </div>

            <div
             class="IMPORTANT">
              <table
               class="IMPORTANT"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/important.gif"
                   hspace="5"
                   alt="Important"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <a
                     href="#SHIFTREF">shift</a> вполне применима и к
                    аргументам функций (см. <a
                     href="#MULTIPLICATION">Пример 33-10</a>).</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>В отличие от других языков программирования, в
                    сценариях на языке командной оболочке, в функции
                    передаются аргументы по значению. <a
                     name="AEN12558"
                     href="#FTN.AEN12558"><span
                     class="footnote">[50]</span></a> Если имена
                    переменных (которые фактически являются
                    указателями) передаются функции в виде аргументов,
                    то они интерпретируются как обычные строки символов
                    и не могут быть разыменованы. <span
                     class="emphasis"><em
                     class="EMPHASIS">Функции интерпретируют свои
                    аргументы буквально.</em></span></p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="EXITRETURN1"></a>Exit и Return</strong></p>

              <dl>
                <dt><strong
                 class="COMMAND">код завершения</strong></dt>

                <dd>
                  <p>Функции возвращают значение в виде <em
                   class="FIRSTTERM">кода завершения</em>. Код
                  завершения может быть задан явно, с помощью команды
                  <strong
                   class="COMMAND">return</strong>, в противном случае
                  будет возвращен код завершения последней команды в
                  функции (<span
                   class="RETURNVALUE">0</span> -- в случае успеха,
                  иначе -- ненулевой код ошибки). Код завершения в
                  сценарии может быть получен через переменную <a
                   href="#XSTATVARREF">$?</a>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">return</strong></dt>

                <dd>
                  <p>Завершает исполнение функции. Команда <strong
                   class="COMMAND">return</strong> <a
                   name="AEN12587"
                   href="#FTN.AEN12587"><span
                   class="footnote">[51]</span></a> может иметь
                  необязательный аргумент типа <span
                   class="emphasis"><em
                   class="EMPHASIS">integer</em></span>, который
                  возвращается в вызывающий сценарий как <span
                   class="QUOTE">&quot;код завершения&quot;</span>
                  функции, это значение так же записывается в
                  переменную <a
                   href="#XSTATVARREF">$?</a>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="MAX"></a>

                    <p><strong>Пример 22-3. Наибольшее из двух
                    чисел</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# max.sh: Наибольшее из двух целых чисел.

E_PARAM_ERR=-198    # Если функции передано меньше двух параметров.
EQUAL=-199          # Возвращаемое значение, если числа равны.

max2 ()             # Возвращает наибольшее из двух чисел.
{                   # Внимание: сравниваемые числа должны быть меньше 257.
if [ -z &quot;$2&quot; ]
then
  return $E_PARAM_ERR
fi

if [ &quot;$1&quot; -eq &quot;$2&quot; ]
then
  return $EQUAL
else
  if [ &quot;$1&quot; -gt &quot;$2&quot; ]
  then
    return $1
  else
    return $2
  fi
fi
}

max2 33 34
return_val=$?

if [ &quot;$return_val&quot; -eq $E_PARAM_ERR ]
then
  echo &quot;Функции должно быть передано два аргумента.&quot;
elif [ &quot;$return_val&quot; -eq $EQUAL ]
  then
    echo &quot;Числа равны.&quot;
else
    echo &quot;Наибольшее из двух чисел: $return_val.&quot;
fi


exit 0

#  Упражнение:
#  ---------------
#  Сделайте этот сценарий интерактивным,
#+ т.е. заставьте сценарий запрашивать числа для сравнения у пользователя (два числа).
</pre>
                  </div>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Для случаев, когда функция должна
                          возвращать строку или массив, используйте
                          специальные переменные.</p>
<pre
 class="PROGRAMLISTING">
count_lines_in_etc_passwd()
{
  [[ -r /etc/passwd ]] &amp;&amp; REPLY=$(echo $(wc -l &lt; /etc/passwd))
  # Если файл /etc/passwd доступен на чтение, то в переменную REPLY заносится число строк.
  # Возвращаются как количество строк, так и код завершения.
}

if count_lines_in_etc_passwd
then
  echo &quot;В файле /etc/passwd найдено $REPLY строк.&quot;
else
  echo &quot;Невозможно подсчитать число строк в файле /etc/passwd.&quot;
fi

# Спасибо S.C.
</pre>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX61"></a>

                    <p><strong>Пример 22-4. Преобразование чисел в
                    римскую форму записи</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Преобразование чисел из арабской формы записи в римскую
# Диапазон: 0 - 200

# Расширение диапазона представляемых чисел и улучшение сценария
# оставляю вам, в качестве упражнения.

# Порядок использования: roman number-to-convert

LIMIT=200
E_ARG_ERR=65
E_OUT_OF_RANGE=66

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` number-to-convert&quot;
  exit $E_ARG_ERR
fi

num=$1
if [ &quot;$num&quot; -gt $LIMIT ]
then
  echo &quot;Выход за границы диапазона!&quot;
  exit $E_OUT_OF_RANGE
fi

to_roman ()   # Функция должна быть объявлена до того как она будет вызвана.
{
number=$1
factor=$2
rchar=$3
let &quot;remainder = number - factor&quot;
while [ &quot;$remainder&quot; -ge 0 ]
do
  echo -n $rchar
  let &quot;number -= factor&quot;
  let &quot;remainder = number - factor&quot;
done

return $number
       # Упражнение:
       # --------
       # Объясните -- как работает функция.
       # Подсказка: деление последовательным вычитанием.
}


to_roman $num 100 C
num=$?
to_roman $num 90 LXXXX
num=$?
to_roman $num 50 L
num=$?
to_roman $num 40 XL
num=$?
to_roman $num 10 X
num=$?
to_roman $num 9 IX
num=$?
to_roman $num 5 V
num=$?
to_roman $num 4 IV
num=$?
to_roman $num 1 I

echo

exit 0
</pre>
                  </div>

                  <p>См. также <a
                   href="#ISALPHA">Пример 10-28</a>.</p>

                  <div
                   class="IMPORTANT">
                    <table
                     class="IMPORTANT"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/important.gif"
                         hspace="5"
                         alt="Important"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Наибольшее положительное целое число,
                          которое может вернуть функция -- 255. Команда
                          <strong
                           class="COMMAND">return</strong> очень тесно
                          связана с понятием <a
                           href="#EXITSTATUSREF">код завершения</a>,
                          что объясняет это специфическое ограничение.
                          К счастью существуют <a
                           href="#RVT">различные способы</a>
                          преодоления этого ограничения.</p>

                          <div
                           class="EXAMPLE">
                            <a
                             name="RETURNTEST"></a>

                            <p><strong>Пример 22-5. Проверка
                            возможности возврата функциями больших
                            значений</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# return-test.sh

# Наибольшее целое число, которое может вернуть функция, не может превышать 256.

return_test ()         # Просто возвращает то, что ей передали.
{
  return $1
}

return_test 27         # o.k.
echo $?                # Возвращено число 27.

return_test 255        # o.k.
echo $?                # Возвращено число 255.

return_test 257        # Ошибка!
echo $?                # Возвращено число 1.

return_test -151896    # Как бы то ни было, но для больших отрицательных чисел проходит!
echo $?                # Возвращено число -151896.

exit 0
</pre>
                          </div>

                          <p>Как видно из примера, функции могут
                          возвращать большие отрицательные значения
                          (имеются ввиду -- большие по своему
                          абсолютному значению, прим. перев.).
                          Используя эту особенность, можно обыграть
                          возможность получения от функций большие
                          положительные значения.</p>

                          <p>Еще один способ -- использовать глобальные
                          переменные для хранения <span
                           class="QUOTE">&quot;возвращаемого
                          значения&quot;</span>.</p>
<pre
 class="PROGRAMLISTING">
Return_Val=   # Глобальная переменная, которая хранит значение, возвращаемое функцией.

alt_return_test ()
{
  fvar=$1
  Return_Val=$fvar
  return   # Возвратить 0 (успешное завершение).
}

alt_return_test 1
echo $?                                  # 0
echo &quot;Функция вернула число $Return_Val&quot; # 1

alt_return_test 255
echo &quot;Функция вернула число $Return_Val&quot; # 255

alt_return_test 257
echo &quot;Функция вернула число $Return_Val&quot; # 257

alt_return_test 25701
echo &quot;Функция вернула число $Return_Val&quot; #25701
</pre>
                          <br>
                          <br>

                          <div
                           class="EXAMPLE">
                            <a
                             name="MAX2"></a>

                            <p><strong>Пример 22-6. Сравнение двух
                            больших целых чисел</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# max2.sh: Наибольшее из двух БОЛЬШИХ целых чисел.

# Это модификация предыдущего примера &quot;max.sh&quot;,
# которая позволяет выполнять сравнение больших целых чисел.

EQUAL=0             # Если числа равны.
MAXRETVAL=255       # Максимально возможное положительное число, которое может вернуть функция.
E_PARAM_ERR=-99999  # Код ошибки в параметрах.
E_NPARAM_ERR=99999  # &quot;Нормализованный&quot; код ошибки в параметрах.

max2 ()             # Возвращает наибольшее из двух больших целых чисел.
{
if [ -z &quot;$2&quot; ]
then
  return $E_PARAM_ERR
fi

if [ &quot;$1&quot; -eq &quot;$2&quot; ]
then
  return $EQUAL
else
  if [ &quot;$1&quot; -gt &quot;$2&quot; ]
  then
    retval=$1
  else
    retval=$2
  fi
fi

# -------------------------------------------------------------- #
# Следующие строки позволяют &quot;обойти&quot; ограничение
if [ &quot;$retval&quot; -gt &quot;$MAXRETVAL&quot; ]    # Если больше предельного значения,
then                                 # то
  let &quot;retval = (( 0 - $retval ))&quot;   # изменение знака числа.
  # (( 0 - $VALUE )) изменяет знак числа.
fi
# Функции имеют возможность возвращать большие *отрицательные* числа.
# -------------------------------------------------------------- #

return $retval
}

max2 33001 33997
return_val=$?

# -------------------------------------------------------------------------- #
if [ &quot;$return_val&quot; -lt 0 ]                  # Если число отрицательное,
then                                        # то
  let &quot;return_val = (( 0 - $return_val ))&quot;  # опять изменить его знак.
fi                                          # &quot;Абсолютное значение&quot; переменной $return_val.
# -------------------------------------------------------------------------- #


if [ &quot;$return_val&quot; -eq &quot;$E_NPARAM_ERR&quot; ]
then                   # Признак ошибки в параметрах, при выходе из функции так же поменял знак.
  echo &quot;Ошибка: Недостаточно аргументов.&quot;
elif [ &quot;$return_val&quot; -eq &quot;$EQUAL&quot; ]
  then
    echo &quot;Числа равны.&quot;
else
    echo &quot;Наиболшее число: $return_val.&quot;
fi

exit 0
</pre>
                          </div>

                          <p>См. также <a
                           href="#DAYSBETWEEN">Пример A-8</a>.</p>

                          <p><tt
                           class=
                          "USERINPUT"><strong>Упражнение:</strong></tt>
                          Используя только что полученные знания,
                          добавьте в предыдущий пример, <a
                           href="#EX61">преобразования чисел в римскую
                          форму записи</a>, возможность обрабатывать
                          большие числа.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="REDSTDINFUNC1"></a>Перенаправление</strong></p>

              <dl>
                <dt><tt
                 class="REPLACEABLE"><em>Перенаправление ввода для
                функций</em></tt></dt>

                <dd>
                  <p>Функции -- суть есть <a
                   href="#CODEBLOCKREF">блок кода</a>, а это означает,
                  что устройство <tt
                   class="FILENAME">stdin</tt> для функций может быть
                  переопределено (перенаправление stdin) (как в <a
                   href="#EX8">Пример 3-1</a>).</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="REALNAME"></a>

                    <p><strong>Пример 22-7. Настоящее имя
                    пользователя</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# По имени пользователя получить его &quot;настоящее имя&quot; из /etc/passwd.

ARGCOUNT=1  # Ожидается один аргумент.
E_WRONGARGS=65

file=/etc/passwd
pattern=$1

if [ $# -ne &quot;$ARGCOUNT&quot; ]
then
  echo &quot;Порядок использования: `basename $0` USERNAME&quot;
  exit $E_WRONGARGS
fi

file_excerpt ()  # Производит поиск в файле по заданному шаблону, выводит требуемую часть строки.
{
while read line
do
  echo &quot;$line&quot; | grep $1 | awk -F&quot;:&quot; &#39;{ print $5 }&#39;  # Указывет awk использовать &quot;:&quot; как разделитель полей.
done
} &lt;$file  # Подменить stdin для функции.

file_excerpt $pattern

# Да, этот сценарий можно уменьшить до
#       grep PATTERN /etc/passwd | awk -F&quot;:&quot; &#39;{ print $5 }&#39;
# или
#       awk -F: &#39;/PATTERN/ {print $5}&#39;
# или
#       awk -F: &#39;($1 == &quot;username&quot;) { print $5 }&#39;
# Однако, это было бы не так поучительно.

exit 0
</pre>
                  </div>

                  <p>Ниже приводится альтернативный, и возможно менее
                  запутанный, способ перенаправления ввода для функций.
                  Он заключается в использовании перенаправления ввода
                  для блока кода, заключенного в фигурные скобки, в
                  пределах функции.</p>
<pre
 class="PROGRAMLISTING">
# Вместо:
Function ()
{
 ...
 } &lt; file

# Попробуйте так:
Function ()
{
  {
    ...
   } &lt; file
}

# Похожий вариант,

Function ()  # Тоже работает.
{
  {
   echo $*
  } | tr a b
}

Function ()  # Этот вариант не работает.
{
  echo $*
} | tr a b   # Наличие вложенного блока кода -- обязательное условие.


# Спасибо S.C.
</pre>
                  <br>
                  <br>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="LOCALVAR"></a>22.2. Локальные переменные</h2>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="LOCALSREF1"></a>Что такое <span
               class="QUOTE">&quot;локальная&quot;</span>
              переменная?</strong></p>

              <dl>
                <dt>локальные переменные</dt>

                <dd>
                  <p>Переменные, объявленные как <em
                   class="FIRSTTERM">локальные</em>, имеют ограниченную
                  область видимости, и доступны только в пределах <a
                   href="#CODEBLOCKREF">блока</a>, в котором они были
                  объявлены. Для функций это означает, что локальная
                  переменная &quot;видна&quot; только в теле самой
                  функции.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX62"></a>

                    <p><strong>Пример 22-8. Область видимости локальных
                    переменных</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

func ()
{
  local loc_var=23       # Объявление локальной переменной.
  echo
  echo &quot;\&quot;loc_var\&quot; в функции = $loc_var&quot;
  global_var=999         # Эта переменная не была объявлена локальной.
  echo &quot;\&quot;global_var\&quot; в функции = $global_var&quot;
}

func

# Проверим, &quot;видна&quot; ли локальная переменная за пределами функции.

echo
echo &quot;\&quot;loc_var\&quot; за пределами функции = $loc_var&quot;
                                      # &quot;loc_var&quot; за пределами функции =
                                      # Итак, $loc_var не видна в глобальном контексте.
echo &quot;\&quot;global_var\&quot; за пределами функции = $global_var&quot;
                                      # &quot;global_var&quot; за пределами функции = 999
                                      # $global_var имеет глобальную область видимости.
echo                                  

exit 0
</pre>
                  </div>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Переменные, объявляемые в теле функции,
                          считаются необъявленными до тех пор, пока
                          функция не будет вызвана. Это касается <span
                           class="emphasis"><em
                           class="EMPHASIS">всех</em></span>
                          переменных.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

func ()
{
global_var=37    #  Эта переменная будет считаться необъявленной
                 #+ до тех пор, пока функция не будет вызвана.
}                # КОНЕЦ ФУНКЦИИ

echo &quot;global_var = $global_var&quot;  # global_var =
                                 #  Функция &quot;func&quot; еще не была вызвана,
                                 #+ поэтому $global_var пока еще не &quot;видна&quot; здесь.

func
echo &quot;global_var = $global_var&quot;  # global_var = 37
                                 # Переменная была инициализирована в функции.
</pre>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="SECT2">
              <hr>

              <h3
               class="SECT2"><a
               name="LOCVARRECUR"></a>22.2.1. Локальные переменные
              делают возможной рекурсию.</h3>

              <p>Хотя локальные переменные и допускают рекурсию, <a
               name="AEN12669"
               href="#FTN.AEN12669"><span
               class="footnote">[52]</span></a> но она сопряжена с
              большими накладными расходами и не рекомендуется для
              использования в сценариях. <a
               name="AEN12675"
               href="#FTN.AEN12675"><span
               class="footnote">[53]</span></a></p>

              <div
               class="EXAMPLE">
                <a
                 name="EX63"></a>

                <p><strong>Пример 22-9. Использование локальных
                переменных при рекурсии</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#               факториал
#               ---------


# Действительно ли bash допускает рекурсию?
# Да! Но...
# Нужно быть действительно дубинноголовым, чтобы использовать ее в сценариях
# на языке командной оболочки.


MAX_ARG=5
E_WRONG_ARGS=65
E_RANGE_ERR=66


if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` число&quot;
  exit $E_WRONG_ARGS
fi

if [ &quot;$1&quot; -gt $MAX_ARG ]
then
  echo &quot;Выход за верхний предел (максимально возможное число -- 5).&quot;
  # Вернитесь к реальности.
  # Если вам захочется поднять верхнюю границу,
  # то перепишите эту программу на настоящем языке программирования.
  exit $E_RANGE_ERR
fi

fact ()
{
  local number=$1
  # Переменная &quot;number&quot; должна быть объявлена как локальная,
  # иначе результат будет неверный.
  if [ &quot;$number&quot; -eq 0 ]
  then
    factorial=1    # Факториал числа 0 = 1.
  else
    let &quot;decrnum = number - 1&quot;
    fact $decrnum  # Рекурсивный вызов функции.
    let &quot;factorial = $number * $?&quot;
  fi

  return $factorial
}

fact $1
echo &quot;Факториал числа $1 = $?.&quot;

exit 0
</pre>
              </div>

              <p>Еще один пример использования рекурсии вы найдете в <a
               href="#PRIMES">Пример A-18</a>. Не забывайте, что
              рекурсия весьма ресурсоемкое удовольствие, к тому же она
              выполняется слишком медленно, поэтому не следует
              использовать ее в сценариях.</p>
            </div>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="ALIASES"></a>Глава 23. Псевдонимы</h1>

          <p><a
           name="ALIASREF"></a></p>

          <p><span
           class="emphasis"><em
           class="EMPHASIS">Псевдонимы</em></span> в Bash -- это ни что
          иное, как &quot;горячие клавиши&quot;, средство, позволяющее
          избежать набора длинных строк в командной строке. Если, к
          примеру, в файл <a
           href="#FILESREF1"><tt
           class="FILENAME">~/.bashrc</tt></a> вставить строку <strong
           class="COMMAND">alias lm=&quot;ls -l | more&quot;</strong>,
          то потом вы сможете экономить свои силы и время, набирая
          команду <tt
           class="USERINPUT"><strong>lm</strong></tt>, вместо более
          длинной <strong
           class="COMMAND">ls -l | more</strong>. Установив <strong
           class="COMMAND">alias rm=&quot;rm -i&quot;</strong>
          (интерактивный режим удаления файлов), вы сможете избежать
          многих неприятностей, потому что сократится вероятность
          удаления важных файлов по неосторожности.</p>

          <p>Псевдонимы в сценариях могут иметь весьма ограниченную
          область применения. Было бы здорово, если бы псевдонимы имели
          функциональность, присущую макроопределениям в языке C, но, к
          сожалению, Bash не может &quot;разворачивать&quot; аргументы
          в теле псевдонима. <a
           name="AEN12698"
           href="#FTN.AEN12698"><span
           class="footnote">[54]</span></a> Кроме того, попытка
          обратиться к псевдониму, созданному внутри <span
           class="QUOTE">&quot;составных конструкций&quot;</span>,
          таких как <a
           href="#IFTHEN">if/then</a>, циклы и функции, будет приводить
          к появлению ошибок. Практически всегда, действия, возлагаемые
          на псевдоним, более эффективно могут быть выполнены с помощью
          <a
           href="#FUNCTIONREF">функций</a>.</p>

          <div
           class="EXAMPLE">
            <a
             name="AL"></a>

            <p><strong>Пример 23-1. Псевдонимы в сценарии</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

shopt -s expand_aliases
# Эта опция должна быть включена, иначе сценарий не сможет &quot;разворачивать&quot; псевдонимы.

alias ll=&quot;ls -l&quot;
# В определении псевдонима можно использовать как одиночные (&#39;), так и двойные (&quot;) кавычки.

echo &quot;Попытка обращения к псевдониму \&quot;ll\&quot;:&quot;
ll /usr/X11R6/bin/mk*   #* Работает.

echo

directory=/usr/X11R6/bin/
prefix=mk*  # Определить -- не будет ли проблем с шаблонами.
echo &quot;Переменные \&quot;directory\&quot; + \&quot;prefix\&quot; = $directory$prefix&quot;
echo

alias lll=&quot;ls -l $directory$prefix&quot;

echo &quot;Попытка обращения к псевдониму \&quot;lll\&quot;:&quot;
lll         # Список всех файлов в /usr/X11R6/bin, чьи имена начинаются с mk.
# Псевдонимы могут работать с шаблонами.




TRUE=1

echo

if [ TRUE ]
then
  alias rr=&quot;ls -l&quot;
  echo &quot;Попытка обращения к псевдониму \&quot;rr\&quot;, созданному внутри if/then:&quot;
  rr /usr/X11R6/bin/mk*   #* В результате -- сообщение об ошибке!
  # К псевдонимам, созданным внутри составных инструкций, нельзя обратиться.
  echo &quot;Однако, ранее созданный псевдоним остается работоспособным:&quot;
  ll /usr/X11R6/bin/mk*
fi

echo

count=0
while [ $count -lt 3 ]
do
  alias rrr=&quot;ls -l&quot;
  echo &quot;Попытка обращения к псевдониму \&quot;rrr\&quot;, созданному внутри цикла \&quot;while\&quot;:&quot;
  rrr /usr/X11R6/bin/mk*   #* Так же возникает ошибка.
                           #  alias.sh: line 57: rrr: command not found
  let count+=1
done

echo; echo

alias xyz=&#39;cat $0&#39;   # Сценарий печатает себя самого.
                     # Обратите внимание на &quot;строгие&quot; кавычки.
xyz
#  Похоже работает,
#+ хотя документация Bash утверждает, что такой псевдоним не должен работать.
#
#  Steve Jacobson отметил, что
#+ параметр &quot;$0&quot; интерпретируется непосредственно, во время объявления псевдонима.

exit 0
</pre>
          </div>

          <p>Команда <strong
           class="COMMAND">unalias</strong> удаляет псевдоним,
          объявленный ранее .</p>

          <div
           class="EXAMPLE">
            <a
             name="UNAL"></a>

            <p><strong>Пример 23-2. unalias: Объявление и удаление
            псевдонимов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

shopt -s expand_aliases  # Разрешить &quot;разворачивание&quot; псевдонимов.

alias llm=&#39;ls -al | more&#39;
llm

echo

unalias llm              # Удалить псевдоним.
llm
# Сообщение об ошибке, т.к. команда &#39;llm&#39; больше не распознается.

exit 0
</pre>
          </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>./unalias.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 6
drwxrwxr-x    2 bozo     bozo         3072 Feb  6 14:04 .
drwxr-xr-x   40 bozo     bozo         2048 Feb  6 14:04 ..
-rwxr-xr-x    1 bozo     bozo          199 Feb  6 14:04 unalias.sh

./unalias.sh: llm: command not found</tt>
</pre>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="LIST-CONS"></a>Глава 24. Списки команд</h1>

          <p><a
           name="LISTCONSREF"></a></p>

          <p>Средством обработки последовательности из нескольких
          команд служат списки: <span
           class="QUOTE">&quot;И-списки&quot;</span> и <span
           class="QUOTE">&quot;ИЛИ-списки&quot;</span>. Они эффективно
          могут заменить сложную последовательность вложенных <strong
           class="COMMAND">if</strong>/<strong
           class="COMMAND">then</strong> или даже <strong
           class="COMMAND">case</strong>.</p>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="LCONS1"></a>Объединение команд в
            цепочки</strong></p>

            <dl>
              <dt>И-список</dt>

              <dd>
<pre
 class="PROGRAMLISTING">
command-1 &amp;&amp; command-2 &amp;&amp; command-3 &amp;&amp; ... command-n
</pre>
                Каждая последующая команда, в таком списке, выполняется
                только тогда, когда предыдущая команда вернула код
                завершения <span
                 class="RETURNVALUE">true</span> (ноль). Если
                какая-либо из команд возвращает <span
                 class="RETURNVALUE">false</span> (не ноль), то
                исполнение списка команд в этом месте завершается, т.е.
                следующие далее команды не выполняются.<br>
                <br>

                <div
                 class="EXAMPLE">
                  <a
                   name="EX64"></a>

                  <p><strong>Пример 24-1. Проверка аргументов командной
                  строки с помощью <span
                   class=
                  "QUOTE">&quot;И-списка&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# &quot;И-список&quot;

if [ ! -z &quot;$1&quot; ] &amp;&amp; echo &quot;Аргумент #1 = $1&quot; &amp;&amp; [ ! -z &quot;$2&quot; ] &amp;&amp; echo &quot;Аргумент #2 = $2&quot;
then
  echo &quot;Сценарию передано не менее 2 аргументов.&quot;
  # Все команды в цепочке возвращают true.
else
  echo &quot;Сценарию передано менее 2 аргументов.&quot;
  # Одна из команд в списке вернула false.
fi
# Обратите внимание: &quot;if [ ! -z $1 ]&quot; тоже работает, но, казалось бы эквивалентный вариант
#  if [ -n $1 ] -- нет. Однако, если добавить кавычки
#  if [ -n &quot;$1&quot; ] то все работает.  Будьте внимательны!
# Проверяемые переменные лучше всегда заключать в кавычки.


# То же самое, только без списка команд.
if [ ! -z &quot;$1&quot; ]
then
  echo &quot;Аргумент #1 = $1&quot;
fi
if [ ! -z &quot;$2&quot; ]
then
  echo &quot;Аргумент #2 = $2&quot;
  echo &quot;Сценарию передано не менее 2 аргументов.&quot;
else
  echo &quot;Сценарию передано менее 2 аргументов.&quot;
fi
# Получилось менее элегантно и длиннее, чем с использованием &quot;И-списка&quot;.


exit 0
</pre>
                </div>

                <div
                 class="EXAMPLE">
                  <a
                   name="ANDLIST2"></a>

                  <p><strong>Пример 24-2. Еще один пример проверки
                  аргументов с помощью <span
                   class=
                  "QUOTE">&quot;И-списков&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

ARGS=1        # Ожидаемое число аргументов.
E_BADARGS=65  # Код завершения, если число аргументов меньше ожидаемого.

test $# -ne $ARGS &amp;&amp; echo &quot;Порядок использования: `basename $0` $ARGS аргумент(а)(ов)&quot; &amp;&amp; exit $E_BADARGS
# Если проверка первого условия возвращает true (неверное число аргументов),
# то исполняется остальная часть строки, и сценарий завершается.

# Строка ниже выполняется только тогда, когда проверка выше не проходит.
# обратите внимание на условие &quot;-ne&quot; -- &quot;не равно&quot; (прим. перев.)
echo &quot;Сценарию передано корректное число аргументов.&quot;

exit 0

# Проверьте код завершения сценария командой &quot;echo $?&quot;.
</pre>
                </div>

                <p><a
                 name="ANDDEFAULT"></a></p>

                <p>Конечно же, с помощью <span
                 class="emphasis"><em
                 class="EMPHASIS">И-списка</em></span> можно
                присваивать переменным значения по-умолчанию.</p>
<pre
 class="PROGRAMLISTING">
arg1=$@       # В $arg1 записать аргументы командной строки.

[ -z &quot;$arg1&quot; ] &amp;&amp; arg1=DEFAULT
              # Записать DEFAULT, если аргументы командной строки отсутствуют.
</pre>
                <br>
                <br>
              </dd>

              <dt>ИЛИ-список</dt>

              <dd>
<pre
 class="PROGRAMLISTING">
command-1 || command-2 || command-3 || ... command-n
</pre>
                Каждая последующая команда, в таком списке, выполняется
                только тогда, когда предыдущая команда вернула код
                завершения <span
                 class="RETURNVALUE">false</span> (не ноль). Если
                какая-либо из команд возвращает <span
                 class="RETURNVALUE">true</span> (ноль), то исполнение
                списка команд в этом месте завершается, т.е. следующие
                далее команды не выполняются. Очевидно, что <span
                 class="QUOTE">&quot;ИЛИ-списки&quot;</span> имеют
                смысл обратный, по отношению к <span
                 class="QUOTE">&quot;И-спискам&quot;</span><br>
                <br>

                <div
                 class="EXAMPLE">
                  <a
                   name="EX65"></a>

                  <p><strong>Пример 24-3. Комбинирование <span
                   class="QUOTE">&quot;ИЛИ-списков&quot;</span> и <span
                   class=
                  "QUOTE">&quot;И-списков&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#  delete.sh, утилита удаления файлов.
#  Порядок использования: delete имя_файла

E_BADARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` имя_файла&quot;
  exit $E_BADARGS  # Если не задано имя файла.
else
  file=$1          # Запомнить имя файла.
fi


[ ! -f &quot;$file&quot; ] &amp;&amp; echo &quot;Файл \&quot;$file\&quot; не найден. \
Робкий отказ удаления несуществующего файла.&quot;
# И-СПИСОК, выдать сообщение об ошибке, если файл не существует.
# Обратите внимание: выводимое сообщение продолжается во второй строке,
# благодаря экранированию символа перевода строки.

[ ! -f &quot;$file&quot; ] || (rm -f $file; echo &quot;Файл \&quot;$file\&quot; удален.&quot;)
# ИЛИ-СПИСОК, удаляет существующий файл.

# Обратите внимание на логические условия.
# И-СПИСОК отрабатывает по true, ИЛИ-СПИСОК -- по false.

exit 0
</pre>
                </div>
              </dd>
            </dl>
          </div>

          <div
           class="IMPORTANT">
            <table
             class="IMPORTANT"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/important.gif"
                 hspace="5"
                 alt="Important"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Списки возвращают <a
                   href="#EXITSTATUSREF">код завершения</a> последней
                  выполненной команды.</p>
                </td>
              </tr>
            </table>
          </div>

          <p>Комбинируя <span
           class="QUOTE">&quot;И&quot;</span> и <span
           class="QUOTE">&quot;ИЛИ&quot;</span> списки, легко
          &quot;перемудрить&quot; с логическими условиями, поэтому, в
          таких случаях может потребоваться детальная отладка.</p>
<pre
 class="PROGRAMLISTING">
false &amp;&amp; true || echo false         # false

# Тот же результат дает
( false &amp;&amp; true ) || echo false     # false
# Но не эта комбинация
false &amp;&amp; ( true || echo false )     # (нет вывода на экран)

#  Обратите внимание на группировку и порядок вычисления условий -- слева-направо,
#+ поскольку логические операции &quot;&amp;&amp;&quot; и &quot;||&quot; имеют равный приоритет.

#  Если вы не уверены в своих действиях, то лучше избегать таких сложных конструкций.

#  Спасибо S.C.
</pre>
          <br>
          <br>

          <p>См. <a
           href="#DAYSBETWEEN">Пример A-8</a> и <a
           href="#BROKENLINK">Пример 7-4</a>, иллюстрирующие
          использование <tt
           class="USERINPUT"><strong>И/ИЛИ-списков</strong></tt> для
          проверки переменных.</p>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="ARRAYS"></a>Глава 25. Массивы</h1>

          <p><a
           name="ARRAYREF"></a></p>

          <p>Новейшие версии Bash поддерживают одномерные массивы.
          Инициализация элементов массива может быть произведена в
          виде: <tt
           class="USERINPUT"><strong>variable[xx]</strong></tt>. Можно
          явно объявить массив в сценарии, с помощью директивы declare:
          <tt
           class="USERINPUT"><strong>declare -a variable</strong></tt>.
          Обращаться к отдельным элементам массива можно с помощью <em
           class="FIRSTTERM">фигурных скобок</em>, т.е.: <tt
           class="USERINPUT"><strong>${variable[xx]}</strong></tt>.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX66"></a>

            <p><strong>Пример 25-1. Простой массив</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash


area[11]=23
area[13]=37
area[51]=UFOs

# Массивы не требуют, чтобы последовательность элементов в массиве была непрерывной.

# Некоторые элементы массива могут оставаться неинициализированными.
# &quot;Дыркм&quot; в массиве не являются ошибкой.


echo -n &quot;area[11] = &quot;
echo ${area[11]}    #  необходимы {фигурные скобки}

echo -n &quot;area[13] = &quot;
echo ${area[13]}

echo &quot;содержимое area[51] = ${area[51]}.&quot;

# Обращение к неинициализированным элементам дает пустую строку.
echo -n &quot;area[43] = &quot;
echo ${area[43]}
echo &quot;(элемент area[43] -- неинициализирован)&quot;

echo

# Сумма двух элементов массива, записанная в третий элемент
area[5]=`expr ${area[11]} + ${area[13]}`
echo &quot;area[5] = area[11] + area[13]&quot;
echo -n &quot;area[5] = &quot;
echo ${area[5]}

area[6]=`expr ${area[11]} + ${area[51]}`
echo &quot;area[6] = area[11] + area[51]&quot;
echo -n &quot;area[6] = &quot;
echo ${area[6]}
# Эта попытка закончится неудачей, поскольку сложение целого числа со строкой не допускается.

echo; echo; echo

# -----------------------------------------------------------------
# Другой массив, &quot;area2&quot;.
# И другой способ инициализации массива...
# array_name=( XXX YYY ZZZ ... )

area2=( ноль один два три четыре )

echo -n &quot;area2[0] = &quot;
echo ${area2[0]}
# Ага, индексация начинается с нуля (первый элемент массива имеет индекс [0], а не [1]).

echo -n &quot;area2[1] = &quot;
echo ${area2[1]}    # [1] -- второй элемент массива.
# -----------------------------------------------------------------

echo; echo; echo

# -----------------------------------------------
# Еще один массив, &quot;area3&quot;.
# И еще один способ инициализации...
# array_name=([xx]=XXX [yy]=YYY ...)

area3=([17]=семнадцать [21]=двадцать_один)

echo -n &quot;area3[17] = &quot;
echo ${area3[17]}

echo -n &quot;area3[21] = &quot;
echo ${area3[21]}
# -----------------------------------------------

exit 0
</pre>
          </div>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Bash позволяет оперировать переменными, как
                  массивами, даже если они не были явно объявлены
                  таковыми.</p>
<pre
 class="PROGRAMLISTING">
string=abcABC123ABCabc
echo ${string[@]}               # abcABC123ABCabc
echo ${string[*]}               # abcABC123ABCabc
echo ${string[0]}               # abcABC123ABCabc
echo ${string[1]}               # Ничего не выводится!
                                # Почему?
echo ${#string[@]}              # 1
                                # Количество элементов в массиве.

# Спасибо Michael Zick за этот пример.
</pre>
                  Эти примеры еще раз подтверждают <a
                   href="#BVUNTYPED">отсутствие контроля типов в
                  Bash</a>. <br>
                  <br>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="EXAMPLE">
            <a
             name="POEM"></a>

            <p><strong>Пример 25-2. Форматирование
            стихотворения</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# poem.sh

# Строки из стихотворения (одна строфа).
Line[1]=&quot;Мой дядя самых честных правил,&quot;
Line[2]=&quot;Когда не в шутку занемог;&quot;
Line[3]=&quot;Он уважать себя заставил,&quot;
Line[4]=&quot;И лучше выдумать не мог.&quot;
Line[5]=&quot;Его пример другим наука...&quot;

# Атрибуты.
Attrib[1]=&quot; А.С. Пушкин&quot;
Attrib[2]=&quot;\&quot;Евгений Онегин\&quot;&quot;

for index in 1 2 3 4 5    # Пять строк.
do
  printf &quot;     %s\n&quot; &quot;${Line[index]}&quot;
done

for index in 1 2          # Две строки дополнительных атрибутов.
do
  printf &quot;          %s\n&quot; &quot;${Attrib[index]}&quot;
done

exit 0
</pre>
          </div>

          <p>При работе с отдельными элементами массива можно
          использовать специфический синтаксис, даже стандартные
          команды и операторы Bash адаптированы для работы с
          массивами.</p>
<pre
 class="PROGRAMLISTING">
array=( ноль один два три четыре пять )

echo ${array[0]}       #  ноль
echo ${array:0}        #  ноль
                       #  Подстановка параметра -- первого элемента.
echo ${array:1}        #  оль
                       #  Подстановка параметра -- первого элемента,
                       #+ начиная с позиции #1 (со 2-го символа).

echo ${#array}         #  4
                       #  Длина первого элемента массива.



array2=( [0]=&quot;первый элемент&quot; [1]=&quot;второй элемент&quot; [3]=&quot;четвертый элемент&quot; )

echo ${array2[0]}      # первый элемент
echo ${array2[1]}      # второй элемент
echo ${array2[2]}      #
                       # Элемент неинициализирован, поэтому на экран ничего не выводится.
echo ${array2[3]}      # четвертый элемент
</pre>
          <br>
          <br>

          <p>При работе с массивами, некоторые <a
           href="#BUILTINREF">встроенные команды</a> Bash имеют
          несколько иной смысл. Например, <a
           href="#UNSETREF">unset</a> -- удаляет отдельные элементы
          массива, или даже массив целиком.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX67"></a>

            <p><strong>Пример 25-3. Некоторые специфичные особенности
            массивов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

declare -a colors
# Допускается объявление массива без указания его размера.

echo &quot;Введите ваши любимые цвета (разделяя их пробелами).&quot;

read -a colors    # Введите хотя бы 3 цвета для демонстрации некоторых свойств массивов.
#  Специфический ключ команды &#39;read&#39;,
#+ позволяющий вводить несколько элементов массива.

echo

element_count=${#colors[@]}

# Получение количества элементов в массиве.
#     element_count=${#colors[*]} -- дает тот же результат.
#
#  Переменная &quot;@&quot; позволяет &quot;разбивать&quot; строку в кавычках на отдельные слова
#+ (выделяются слова, разделенные пробелами).

index=0

while [ &quot;$index&quot; -lt &quot;$element_count&quot; ]
do    # Список всех элементов в массиве.
  echo ${colors[$index]}
  let &quot;index = $index + 1&quot;
done
# Каждый элемент массива выводится в отдельной строке.
# Если этого не требуется, то используйте  echo -n &quot;${colors[$index]} &quot;
#
# Эквивалентный цикл &quot;for&quot;:
#   for i in &quot;${colors[@]}&quot;
#   do
#     echo &quot;$i&quot;
#   done
# (Спасибо S.C.)

echo

# Еще один, более элегантный, способ вывода списка всех элементов массива.
  echo ${colors[@]}          # ${colors[*]} дает тот же результат.

echo

# Команда &quot;unset&quot; удаляет элементы из массива, или даже массив целиком.
unset colors[1]              # Удаление 2-го элемента массива.
                             # Тот же эффект дает команда   colors[1]=
echo  ${colors[@]}           # Список всех элементов массива -- 2-й элемент отсутствует.

unset colors                 # Удаление всего массива.
                             #  Тот же эффект имеют команды unset colors[*]
                             #+ и unset colors[@].
echo; echo -n &quot;Массив цветов опустошен.&quot;
echo ${colors[@]}            # Список элементов массива пуст.

exit 0
</pre>
          </div>

          <p>Как видно из предыдущего примера, обращение к <strong
           class="COMMAND">${array_name[@]}</strong> или <strong
           class="COMMAND">${array_name[*]}</strong> относится ко <span
           class="emphasis"><em
           class="EMPHASIS">всем</em></span> элементам массива. Чтобы
          получить количество элементов массива, можно обратиться к
          <strong
           class="COMMAND">${#array_name[@]}</strong> или к <strong
           class="COMMAND">${#array_name[*]}</strong>. <strong
           class="COMMAND">${#array_name}</strong> -- это длина
          (количество символов) первого элемента массива, т.е. <strong
           class="COMMAND">${array_name[0]}</strong>.</p>

          <div
           class="EXAMPLE">
            <a
             name="EMPTYARRAY"></a>

            <p><strong>Пример 25-4. Пустые массивы и пустые
            элементы</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# empty-array.sh

#  Выражаю свою благодарность Stephane Chazelas за этот пример,
#+ и Michael Zick за его доработку.


# Пустой массив -- это не то же самое, что массив с пустыми элементами.

array0=( первый второй третий )
array1=( &#39;&#39; )   # &quot;array1&quot; имеет один пустой элемент.
array2=( )      # Массив &quot;array2&quot; не имеет ни одного элемента, т.е. пуст.

echo
ListArray()
{
echo
echo &quot;Элементы массива array0:  ${array0[@]}&quot;
echo &quot;Элементы массива array1:  ${array1[@]}&quot;
echo &quot;Элементы массива array2:  ${array2[@]}&quot;
echo
echo &quot;Длина первого элемента массива array0 = ${#array0}&quot;
echo &quot;Длина первого элемента массива array1 = ${#array1}&quot;
echo &quot;Длина первого элемента массива array2 = ${#array2}&quot;
echo
echo &quot;Число элементов в массиве array0 = ${#array0[*]}&quot;  # 3
echo &quot;Число элементов в массиве array1 = ${#array1[*]}&quot;  # 1  (сюрприз!)
echo &quot;Число элементов в массиве array2 = ${#array2[*]}&quot;  # 0
}

# ===================================================================

ListArray

# Попробуем добавить новые элементы в массивы

# Добавление новых элементов в массивы.
array0=( &quot;${array0[@]}&quot; &quot;новый1&quot; )
array1=( &quot;${array1[@]}&quot; &quot;новый1&quot; )
array2=( &quot;${array2[@]}&quot; &quot;новый1&quot; )

ListArray

# или
array0[${#array0[*]}]=&quot;новый2&quot;
array1[${#array1[*]}]=&quot;новый2&quot;
array2[${#array2[*]}]=&quot;новый2&quot;

ListArray

# Теперь представим каждый массив как &#39;стек&#39; (&#39;stack&#39;)
# Команды выше, можно считать командами &#39;push&#39; -- добавление нового значения на вершину стека
# &#39;Глубина&#39; стека:
height=${#array2[@]}
echo
echo &quot;Глубина стека array2 = $height&quot;

# Команда &#39;pop&#39; -- выталкивание элемента стека, находящегося на вершине:
unset array2[${#array2[@]}-1]   # Индексация массивов начинается с нуля
height=${#array2[@]}
echo
echo &quot;POP&quot;
echo &quot;Глубина стека array2, после выталкивания = $height&quot;

ListArray

# Вывести только 2-й и 3-й элементы массива array0
from=1          # Индексация массивов начинается с нуля
to=2              #
declare -a array3=( ${array0[@]:1:2} )
echo
echo &quot;Элементы массива array3:  ${array3[@]}&quot;

# Замена элементов по шаблону
declare -a array4=( ${array0[@]/второй/2-й} )
echo
echo &quot;Элементы массива array4:  ${array4[@]}&quot;

# Замена строк по шаблону
declare -a array5=( ${array0[@]//новый?/старый} )
echo
echo &quot;Элементы массива array5:  ${array5[@]}&quot;

# Надо лишь привыкнуть к такой записи...
declare -a array6=( ${array0[@]#*новый} )
echo # Это может вас несколько удивить
echo &quot;Элементы массива array6:  ${array6[@]}&quot;

declare -a array7=( ${array0[@]#новый1} )
echo # Теперь это вас уже не должно удивлять
echo &quot;Элементы массива array7:  ${array7[@]}&quot;

# Выглядить очень похоже на предыдущий вариант...
declare -a array8=( ${array0[@]/новый1/} )
echo
echo &quot;Элементы массива array8:  ${array8[@]}&quot;

#  Итак, что вы можете сказать обо всем этом?

#  Строковые операции выполняются последовательно, над каждым элементом
#+ в массиве var[@].
#  Таким образом, BASH поддерживает векторные операции
#  Если в результате операции получается пустая строка, то
#+ элемент массива &quot;исчезает&quot;.

#  Вопрос: это относится к строкам в &quot;строгих&quot; или &quot;мягких&quot; кавычках?

zap=&#39;новый*&#39;
declare -a array9=( ${array0[@]/$zap/} )
echo
echo &quot;Элементы массива array9:  ${array9[@]}&quot;

# &quot;...А с платформы говорят: &quot;Это город Ленинград!&quot;...&quot;
declare -a array10=( ${array0[@]#$zap} )
echo
echo &quot;Элементы массива array10:  ${array10[@]}&quot;

# Сравните массивы array7 и array10
# Сравните массивы array8 и array9

# Ответ: в &quot;мягких&quot; кавычках.

exit 0
</pre>
          </div>

          <p>Разница между <strong
           class="COMMAND">${array_name[@]}</strong> и <strong
           class="COMMAND">${array_name[*]}</strong> такая же, как
          между <a
           href="#APPREF">$@ и $*</a>. Эти свойства массивов широко
          применяются на практике.</p>
<pre
 class="PROGRAMLISTING">
# Копирование массивов.
array2=( &quot;${array1[@]}&quot; )
# или
array2=&quot;${array1[@]}&quot;

# Добавить элемент.
array=( &quot;${array[@]}&quot; &quot;новый элемент&quot; )
# или
array[${#array[*]}]=&quot;новый элемент&quot;

# Спасибо S.C.
</pre>
          <br>
          <br>

          <div
           class="TIP">
            <table
             class="TIP"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/tip.gif"
                 hspace="5"
                 alt="Tip"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Операция <a
                   href="#COMMANDSUBREF">подстановки команд</a> --
                  <strong
                   class="COMMAND">array=( element1 element2 ...
                  elementN )</strong>, позволяет загружать содержимое
                  текстовых файлов в массивы.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

filename=sample_file

#            cat sample_file
#
#            1 a b c
#            2 d e fg


declare -a array1

array1=( `cat &quot;$filename&quot; | tr &#39;\n&#39; &#39; &#39;`)  # Загрузка содержимого файла
                                           # $filename в массив array1.
#         Вывод на stdout.
#                         с заменой символов перевода строки на пробелы.

echo ${array1[@]}            # список элементов массива.
#                              1 a b c 2 d e fg
#
#  Каждое &quot;слово&quot;, в текстовом файле, отделяемое от других пробелами
#+ заносится в отдельный элемент массива.

element_count=${#array1[*]}
echo $element_count          # 8
</pre>
                  <br>
                  <br>
                </td>
              </tr>
            </table>
          </div>

          <div
           class="EXAMPLE">
            <a
             name="COPYARRAY"></a>

            <p><strong>Пример 25-5. Копирование и конкатенация
            массивов</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
# CopyArray.sh
#
# Автор: Michael Zick.
# Используется с его разрешения.

#  &quot;Принять из массива с заданным именем записать в массив с заданным именем&quot;
#+ или &quot;собственный Оператор Присваивания&quot;.


CpArray_Mac() {

# Оператор Присваивания

    echo -n &#39;eval &#39;
    echo -n &quot;$2&quot;                    # Имя массива-результата
    echo -n &#39;=( ${&#39;
    echo -n &quot;$1&quot;                    # Имя исходного массива
    echo -n &#39;[@]} )&#39;

# Все это могло бы быть объединено в одну команду.
# Это лишь вопрос стиля.
}

declare -f CopyArray                # &quot;Указатель&quot; на функцию
CopyArray=CpArray_Mac               # Оператор Присваивания

Hype()
{

# Исходный массив с именем в $1.
# (Слить с массивом, содержащим &quot;-- Настоящий Рок-н-Ролл&quot;.)
# Вернуть результат в массиве с именем $2.

    local -a TMP
    local -a hype=( -- Настоящий Рок-н-Ролл )

    $($CopyArray $1 TMP)
    TMP=( ${TMP[@]} ${hype[@]} )
    $($CopyArray TMP $2)
}

declare -a before=( Advanced Bash Scripting )
declare -a after

echo &quot;Массив before = ${before[@]}&quot;

Hype before after

echo &quot;Массив after  = ${after[@]}&quot;

# Еще?

echo &quot;Что такое ${after[@]:4:2}?&quot;

declare -a modest=( ${after[@]:2:1} ${after[@]:3:3} )
#                    ---- выделение подстроки ----

echo &quot;Массив Modest = ${modest[@]}&quot;

# А что в массиве &#39;before&#39; ?

echo &quot;Массив Before = ${before[@]}&quot;

exit 0
</pre>
          </div>

          <p>--</p>

          <p>Массивы допускают перенос хорошо известных алгоритмов в
          сценарии на языке командной оболочки. Хорошо ли это -- решать
          вам.</p>

          <div
           class="EXAMPLE">
            <a
             name="BUBBLE"></a>

            <p><strong>Пример 25-6. Старая, добрая: <span
             class="emphasis"><em
             class="EMPHASIS">&quot;Пузырьковая&quot;
            сортировка</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# bubble.sh: &quot;Пузырьковая&quot; сортировка.

#  На каждом проходе по сортируемому массиву,
#+ сравниваются два смежных элемента, и, если необходимо, они меняются местами.
#  В конце первого прохода, самый &quot;тяжелый&quot; элемент &quot;опускается&quot; в конец массива.
#  В конце второго прохода, следующий по &quot;тяжести&quot; элемент занимает второе место снизу.
#  И так далее.
#  Каждый последующий проход требует на одно сравнение меньше предыдущего.
#  Поэтому вы должны заметить ускорение работы сценария на последних проходах.


exchange()
{
  # Поменять местами два элемента массива.
  local temp=${Countries[$1]} #  Временная переменная
  Countries[$1]=${Countries[$2]}
  Countries[$2]=$temp

  return
}

declare -a Countries  #  Объявление массива,
                      #+ необязательно, поскольку он явно инициализируется ниже.

#  Допустимо ли выполнять инициализацию массива в нескольки строках?
#  ДА!

Countries=(Нидерланды Украина Заир Турция Россия Йемен Сирия \
Бразилия Аргентина Никарагуа Япония Мексика Венесуэла Греция Англия \
Израиль Перу Канада Оман Дания Уэльс Франция Кения \
Занаду Катар Лихтенштейн Венгрия)

# &quot;Занаду&quot; -- это мифическое государство, где, согласно Coleridge,
#+ Kubla Khan построил величественный дворец.


clear                      # Очистка экрана.

echo &quot;0: ${Countries[*]}&quot;  # Список элементов несортированного массива.

number_of_elements=${#Countries[@]}
let &quot;comparisons = $number_of_elements - 1&quot;

count=1 # Номер прохода.

while [ &quot;$comparisons&quot; -gt 0 ]          # Начало внешнего цикла
do

  index=0  # Сбросить индекс перед началом каждого прохода.

  while [ &quot;$index&quot; -lt &quot;$comparisons&quot; ] # Начало внутреннего цикла
  do
    if [ ${Countries[$index]} \&gt; ${Countries[`expr $index + 1`]} ]
    #  Если элементы стоят не по порядку...
    #  Оператор \&gt; выполняет сравнение ASCII-строк
    #+ внутри одиночных квадратных скобок.

    #  if [[ ${Countries[$index]} &gt; ${Countries[`expr $index + 1`]} ]]
    #+ дает тот же результат.
    then
      exchange $index `expr $index + 1`  # Поменять местами.
    fi
    let &quot;index += 1&quot;
  done # Конец внутреннего цикла


let &quot;comparisons -= 1&quot; #  Поскольку самый &quot;тяжелый&quot; элемент уже &quot;опустился&quot; на дно,
                       #+ то на каждом последующем проходе нужно выполнять на одно сравнение меньше.

echo
echo &quot;$count: ${Countries[@]}&quot;  # Вывести содержимое массива после каждого прохода.
echo
let &quot;count += 1&quot;                # Увеличить счетчик проходов.

done                            # Конец внешнего цикла

exit 0
</pre>
          </div>

          <p>--</p>

          <p>Можно ли вложить один массив в другой?</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вложенный массив.

# Автор: Michael Zick.

AnArray=( $(ls --inode --ignore-backups --almost-all \
        --directory --full-time --color=none --time=status \
        --sort=time -l ${PWD} ) )  # Команды и опции.

# Пробелы важны . . .

SubArray=( ${AnArray[@]:11:1}  ${AnArray[@]:6:5} )
# Массив имеет два элемента, каждый из которых, в свою очередь, является массивом.

echo &quot;Текущий каталог и дата последнего изменения:&quot;
echo &quot;${SubArray[@]}&quot;

exit 0
</pre>
          <br>
          <br>

          <p>--</p>

          <p>Вложенные массивы, в комбинации с <a
           href="#VARREFNEW">косвенными ссылками</a>, предоставляют в
          распоряжение программиста ряд замечательных возможностей</p>

          <div
           class="EXAMPLE">
            <a
             name="EMBARR"></a>

            <p><strong>Пример 25-7. Вложенные массивы и косвенные
            ссылки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# embedded-arrays.sh
# Вложенные массивы и косвенные ссылки.

# Автор: Dennis Leeuw.
# Используется с его разрешения.
# Дополнен автором документа.


ARRAY1=(
        VAR1_1=value11
        VAR1_2=value12
        VAR1_3=value13
)

ARRAY2=(
        VARIABLE=&quot;test&quot;
        STRING=&quot;VAR1=value1 VAR2=value2 VAR3=value3&quot;
        ARRAY21=${ARRAY1[*]}
)       # Вложение массива ARRAY1 в массив ARRAY2.

function print () {
        OLD_IFS=&quot;$IFS&quot;
        IFS=$&#39;\n&#39;       #  Вывод каждого элемента массива
                        #+ в отдельной строке.
        TEST1=&quot;ARRAY2[*]&quot;
        local ${!TEST1} # Посмотрите, что произойдет, если убрать эту строку.
        #  Косвенная ссылка.
        #  Позволяет получить доступ к компонентам $TEST1
        #+ в этой функции.


        #  Посмотрим, что получилось.
        echo
        echo &quot;\$TEST1 = $TEST1&quot;       #  Просто имя переменной.
        echo; echo
        echo &quot;{\$TEST1} = ${!TEST1}&quot;  #  Вывод на экран содержимого переменной.
                                      #  Это то, что дает
                                      #+ косвенная ссылка.
        echo
        echo &quot;-------------------------------------------&quot;; echo
        echo


        # Вывод переменной
        echo &quot;Переменная VARIABLE: $VARIABLE&quot;

        # Вывод элементов строки
        IFS=&quot;$OLD_IFS&quot;
        TEST2=&quot;STRING[*]&quot;
        local ${!TEST2}      # Косвенная ссылка (то же, что и выше).
        echo &quot;Элемент VAR2: $VAR2 из строки STRING&quot;

        # Вывод элемента массива
        TEST2=&quot;ARRAY21[*]&quot;
        local ${!TEST2}      # Косвенная ссылка.
        echo &quot;Элемент VAR1_1: $VAR1_1 из массива ARRAY21&quot;
}

print
echo

exit 0
</pre>
          </div>

          <p>--</p>

          <p>С помощью массивов, на языке командной оболочки, вполне
          возможно реализовать алгоритм <span
           class="emphasis"><em
           class="EMPHASIS">Решета Эратосфена</em></span>. Конечно же
          -- это очень ресурсоемкая задача. В виде сценария она будет
          работать мучительно долго, так что лучше всего реализовать ее
          на каком либо другом, компилирующем, языке программирования,
          таком как C.</p>

          <div
           class="EXAMPLE">
            <a
             name="EX68"></a>

            <p><strong>Пример 25-8. Пример реализации алгоритма <span
             class="emphasis"><em
             class="EMPHASIS">Решето
            Эратосфена</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# sieve.sh

# Решето Эратосфена
# Очень старый алгоритм поиска простых чисел.

# Этот сценарий выполняется во много раз медленнее
# чем аналогичная программа на C.

LOWER_LIMIT=1       # Начиная с 1.
UPPER_LIMIT=1000    # До 1000.
# (Вы можете установить верхний предел и выше...  если вам есть чем себя занять.)

PRIME=1
NON_PRIME=0

declare -a Primes
# Primes[] -- массив.


initialize ()
{
# Инициализация массива.

i=$LOWER_LIMIT
until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
do
  Primes[i]=$PRIME
  let &quot;i += 1&quot;
done
# Все числа в заданном диапазоне считать простыми,
# пока не доказано обратное.
}

print_primes ()
{
# Вывод индексов элементов массива Primes[], которые признаны простыми.

i=$LOWER_LIMIT

until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
do

  if [ &quot;${Primes[i]}&quot; -eq &quot;$PRIME&quot; ]
  then
    printf &quot;%8d&quot; $i
    # 8 пробелов перед числом придают удобочитаемый табличный вывод на экран.
  fi

  let &quot;i += 1&quot;

done

}

sift () # Отсеивание составных чисел.
{

let i=$LOWER_LIMIT+1
# Нам известно, что 1 -- это простое число, поэтому начнем с 2.

until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
do

if [ &quot;${Primes[i]}&quot; -eq &quot;$PRIME&quot; ]
# Не следует проверять вторично числа, которые уже признаны составными.
then

  t=$i

  while [ &quot;$t&quot; -le &quot;$UPPER_LIMIT&quot; ]
  do
    let &quot;t += $i &quot;
    Primes[t]=$NON_PRIME
    # Все числа, которые делятся на $t без остатка, пометить как составные.
  done

fi

  let &quot;i += 1&quot;
done


}


# Вызов функций.
initialize
sift
print_primes
# Это называется структурным программированием.

echo

exit 0



# ----------------------------------------------- #
# Код, приведенный ниже, не исполняется из-за команды exit, стоящей выше.

# Улучшенная версия, предложенная Stephane Chazelas,
# работает несколько быстрее.

# Должен вызываться с аргументом командной строки, определяющем верхний предел.

UPPER_LIMIT=$1                  # Из командной строки.
let SPLIT=UPPER_LIMIT/2         # Рассматривать делители только до середины диапазона.

Primes=( &#39;&#39; $(seq $UPPER_LIMIT) )

i=1
until (( ( i += 1 ) &gt; SPLIT ))  # Числа из верхней половины диапазона могут не рассматриваться.
do
  if [[ -n $Primes[i] ]]
  then
    t=$i
    until (( ( t += i ) &gt; UPPER_LIMIT ))
    do
      Primes[t]=
    done
  fi
done
echo ${Primes[*]}

exit 0
</pre>
          </div>

          <p>Сравните этот сценарий с генератором простых чисел, не
          использующим массивов, <a
           href="#PRIMES">Пример A-18</a>.</p>

          <p>--</p>

          <p>Массивы позволяют эмулировать некоторые структуры данных,
          поддержка которых в Bash не предусмотрена.</p>

          <div
           class="EXAMPLE">
            <a
             name="STACKEX"></a>

            <p><strong>Пример 25-9. Эмуляция структуры &quot;СТЕК&quot;
            (&quot;первый вошел -- последний вышел&quot;)</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# stack.sh: Эмуляция структуры &quot;СТЕК&quot; (&quot;первый вошел -- последний вышел&quot;)

#  Подобно стеку процессора, этот &quot;стек&quot; сохраняет и возвращает данные по принципу
#+ &quot;первый вошел -- последний вышел&quot;.

BP=100            # Базовый указатель на массив-стек.
                  # Дно стека -- 100-й элемент.

SP=$BP            # Указатель вершины стека.
                  # Изначально -- стек пуст.

Data=             #  Содержимое вершины стека.
                  #  Следует использовать дополнительную переменную,
                  #+ из-за ограничений на диапазон возвращаемых функциями значений.

declare -a stack


push()            # Поместить элемент на вершину стека.
{
if [ -z &quot;$1&quot; ]    # А вообще, есть что помещать на стек?
then
  return
fi

let &quot;SP -= 1&quot;     # Переместить указатель стека.
stack[$SP]=$1

return
}

pop()                    # Снять элемент с вершины стека.
{
Data=                    # Очистить переменную.

if [ &quot;$SP&quot; -eq &quot;$BP&quot; ]   # Стек пуст?
then
  return
fi                       #  Это предохраняет от выхода SP за границу стека -- 100,

Data=${stack[$SP]}
let &quot;SP += 1&quot;            # Переместить указатель стека.
return
}

status_report()          # Вывод вспомогательной информации.
{
echo &quot;-------------------------------------&quot;
echo &quot;ОТЧЕТ&quot;
echo &quot;Указатель стека SP = $SP&quot;
echo &quot;Со стека был снят элемент \&quot;&quot;$Data&quot;\&quot;&quot;
echo &quot;-------------------------------------&quot;
echo
}


# =======================================================
# А теперь позабавимся.

echo

# Попробуем вытолкнуть что-нибудь из пустого стека.
pop
status_report

echo

push garbage
pop
status_report     # Втолкнуть garbage, вытолкнуть garbage.

value1=23; push $value1
value2=skidoo; push $value2
value3=FINAL; push $value3

pop              # FINAL
status_report
pop              # skidoo
status_report
pop              # 23
status_report    # Первый вошел -- последний вышел!

#  Обратите внимание как изменяется указатель стека на каждом вызове функций push и pop.

echo
# =======================================================


# Упражнения:
# -----------

# 1)  Измените функцию &quot;push()&quot; таким образом,
#   + чтобы она позволяла помещать на стек несколько значений за один вызов.

# 2)  Измените функцию &quot;pop()&quot; таким образом,
#   + чтобы она позволяла снимать со стека несколько значений за один вызов.

# 3)  Попробуйте написать простейший калькулятор, выполняющий 4 арифметических действия?
#   + используя этот пример.

exit 0
</pre>
          </div>

          <p>--</p>

          <p>Иногда, манипуляции с <span
           class="QUOTE">&quot;индексами&quot;</span> массивов могут
          потребовать введения переменных для хранения промежуточных
          результатов. В таких случаях вам предоставляется лишний повод
          подумать о реализации проекта на более мощном языке
          программирования, например Perl или C.</p>

          <div
           class="EXAMPLE">
            <a
             name="QFUNCTION"></a>

            <p><strong>Пример 25-10. <span
             class="emphasis"><em
             class="EMPHASIS">Исследование математических
            последовательностей</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Пресловутая &quot;Q-последовательность&quot; Дугласа Хольфштадтера *Douglas Hofstadter):

# Q(1) = Q(2) = 1
# Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), для n&gt;2

# Это &quot;хаотическая&quot; последовательность целых чисел с непредсказуемым поведением.
# Первые 20 членов последовательности:
# 1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12

# См. книгу Дугласа Хольфштадтера, &quot;Goedel, Escher, Bach: An Eternal Golden Braid&quot;,
# p. 137, ff.


LIMIT=100     # Найти первые 100 членов последовательности
LINEWIDTH=20  # Число членов последовательности, выводимых на экран в одной строке

Q[1]=1        # Первые два члена последовательности равны 1.
Q[2]=1

echo
echo &quot;Q-последовательность [первые $LIMIT членов]:&quot;
echo -n &quot;${Q[1]} &quot;             # Вывести первые два члена последовательности.
echo -n &quot;${Q[2]} &quot;

for ((n=3; n &lt;= $LIMIT; n++))  # C-подобное оформление цикла.
do   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  для n&gt;2
# Это выражение необходимо разбить на отдельные действия,
# поскольку Bash не очень хорошо поддерживает сложные арифметические действия над элементами массивов.

  let &quot;n1 = $n - 1&quot;        # n-1
  let &quot;n2 = $n - 2&quot;        # n-2

  t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]
  t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]

  T0=${Q[t0]}              # Q[n - Q[n-1]]
  T1=${Q[t1]}              # Q[n - Q[n-2]]

Q[n]=`expr $T0 + $T1`      # Q[n - Q[n-1]] + Q[n - Q[n-2]]
echo -n &quot;${Q[n]} &quot;

if [ `expr $n % $LINEWIDTH` -eq 0 ]    # Если выведено очередные 20 членов в строке.
then   # то
  echo # перейти на новую строку.
fi

done

echo

exit 0

# Этот сценарий реализует итеративный алгоритм поиска членов Q-последовательности.
# Рекурсивную реализацию, как более интуитивно понятную, оставляю вам, в качестве упражнения.
# Внимание: рекурсивный поиск членов последовательности будет занимать *очень* продолжительное время.
</pre>
          </div>

          <p>--</p>

          <p>Bash поддерживает только одномерные массивы, но, путем
          небольших ухищрений, можно эмулировать многомерные
          массивы.</p>

          <div
           class="EXAMPLE">
            <a
             name="TWODIM"></a>

            <p><strong>Пример 25-11. Эмуляция массива с двумя
            измерениями</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Эмуляция двумерного массива.

# Второе измерение представлено как последовательность строк.

Rows=5
Columns=5

declare -a alpha     # char alpha [Rows] [Columns];
                     # Необязательное объявление массива.

load_alpha ()
{
local rc=0
local index


for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y
do
  local row=`expr $rc / $Columns`
  local column=`expr $rc % $Rows`
  let &quot;index = $row * $Rows + $column&quot;
  alpha[$index]=$i   # alpha[$row][$column]
  let &quot;rc += 1&quot;
done

# Более простой вариант
#   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )
# но при таком объявлении второе измерение массива завуалировано.
}

print_alpha ()
{
local row=0
local index

echo

while [ &quot;$row&quot; -lt &quot;$Rows&quot; ]   # Вывод содержимого массива построчно
do

  local column=0

  while [ &quot;$column&quot; -lt &quot;$Columns&quot; ]
  do
    let &quot;index = $row * $Rows + $column&quot;
    echo -n &quot;${alpha[index]} &quot;  # alpha[$row][$column]
    let &quot;column += 1&quot;
  done

  let &quot;row += 1&quot;
  echo

done

# Более простой эквивалент:
#   echo ${alpha[*]} | xargs -n $Columns

echo
}

filter ()     # Отфильтровывание отрицательных индексов.
{

echo -n &quot;  &quot;

if [[ &quot;$1&quot; -ge 0 &amp;&amp;  &quot;$1&quot; -lt &quot;$Rows&quot; &amp;&amp; &quot;$2&quot; -ge 0 &amp;&amp; &quot;$2&quot; -lt &quot;$Columns&quot; ]]
then
    let &quot;index = $1 * $Rows + $2&quot;
    echo -n &quot; ${alpha[index]}&quot;  # alpha[$row][$column]
fi

}

rotate ()  # Поворот массива на 45 градусов
{
local row
local column

for (( row = Rows; row &gt; -Rows; row-- ))  # В обратном порядке.
do

  for (( column = 0; column &lt; Columns; column++ ))
  do

    if [ &quot;$row&quot; -ge 0 ]
    then
      let &quot;t1 = $column - $row&quot;
      let &quot;t2 = $column&quot;
    else
      let &quot;t1 = $column&quot;
      let &quot;t2 = $column + $row&quot;
    fi

    filter $t1 $t2   # Отфильтровать отрицательный индекс.
  done

  echo; echo

done

# Поворот массива выполнен на основе примеров (стр. 143-146)
# из книги &quot;Advanced C Programming on the IBM PC&quot;, автор Herbert Mayer
# (см. библиографию).

}


#-----------------------------------------------------#
load_alpha     # Инициализация массива.
print_alpha    # Вывод на экран.
rotate         # Повернуть на 45 градусов против часовой стрелки.
#-----------------------------------------------------#


# Упражнения:
# -----------
# 1)  Сделайте инициализацию и вывод массива на экран
#   + более простым и элегантным способом.
#
# 2)  Объясните принцип работы функции rotate().

exit 0
</pre>
          </div>

          <p>По существу, двумерный массив эквивалентен одномерному, с
          тем лишь различием, что для индексации отдельных элементов
          используются два индекса -- <span
           class="QUOTE">&quot;строка&quot;</span> и <span
           class="QUOTE">&quot;столбец&quot;</span>.</p>

          <p>Более сложный пример эмуляции двумерного массива вы
          найдете в <a
           href="#LIFESLOW">Пример A-11</a>.</p>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="FILES"></a>Глава 26. Файлы</h1>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="FILESREF1"></a>сценарии начальной
            загрузки</strong></p>

            <dl>
              <dd>
                <p>Эти файлы содержат объявления псевдонимов и <a
                 href="#ENVREF">переменных окружения</a>, которые
                становятся доступны Bash после загрузки и инициализации
                системы.</p>
              </dd>

              <dt><tt
               class="FILENAME">/etc/profile</tt></dt>

              <dd>
                <p>Настройки системы по-умолчанию, главным образом
                настраивается окружение командной оболочки (все
                Bourne-подобные оболочки, не только Bash <a
                 name="AEN12906"
                 href="#FTN.AEN12906"><span
                 class="footnote">[55]</span></a>)</p>
              </dd>

              <dt><tt
               class="FILENAME">/etc/bashrc</tt></dt>

              <dd>
                <p>функции и <a
                 href="#ALIASREF">псевдонимы</a> Bash</p>
              </dd>

              <dt><tt
               class="FILENAME"><tt
               class="VARNAME">$HOME</tt>/.bash_profile</tt></dt>

              <dd>
                <p>пользовательские настройки окружения Bash, находится
                в домашнем каталоге у каждого пользователя (локальная
                копия файла <tt
                 class="FILENAME">/etc/profile</tt>)</p>
              </dd>

              <dt><tt
               class="FILENAME"><tt
               class="VARNAME">$HOME</tt>/.bashrc</tt></dt>

              <dd>
                <p>пользовательский файл инициализации Bash, находится
                в домашнем каталоге у каждого пользователя (локальная
                копия файла <tt
                 class="FILENAME">/etc/bashrc</tt>). См. <a
                 href="#SAMPLE-BASHRC">Приложение G</a>пример файла <tt
                 class="FILENAME">.bashrc</tt>.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="LOGOUTFILEREF1"></a>Сценарий выхода из системы
            (logout)</strong></p>

            <dl>
              <dt><tt
               class="FILENAME"><tt
               class="VARNAME">$HOME</tt>/.bash_logout</tt></dt>

              <dd>
                <p>Этот сценарий отрабатывает, когда пользователь
                выходит из системы.</p>
              </dd>
            </dl>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="DEVPROC"></a>Глава 27. /dev и /proc</h1>

          <p><a
           name="DEVPROCREF"></a></p>

          <p>Как правило, Linux или UNIX система имеет два каталога
          специального назначения: <tt
           class="FILENAME">/dev</tt> и <tt
           class="FILENAME">/proc</tt>.</p>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="DEVREF1"></a>27.1. <tt
             class="FILENAME">/dev</tt></h2>

            <p>Каталог <tt
             class="FILENAME">/dev</tt> содержит файлы физических <span
             class="emphasis"><em
             class="EMPHASIS">устройств</em></span>, которые могут
            входить в состав аппаратного обеспечения компьютера. <a
             name="AEN12955"
             href="#FTN.AEN12955"><span
             class="footnote">[56]</span></a> Каждому из разделов не
            жестком диске соответствует свой файл-устройство в каталоге
            <tt
             class="FILENAME">/dev</tt>, информация о которых может
            быть получена простой командой <a
             href="#DFREF">df</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>df</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Filesystem           1k-blocks      Used Available Use%
 Mounted on
 /dev/hda6               495876    222748    247527  48% /
 /dev/hda1                50755      3887     44248   9% /boot
 /dev/hda8               367013     13262    334803   4% /home
 /dev/hda5              1714416   1123624    503704  70% /usr</tt>
             
</pre>
            <br>
            <br>

            <p><a
             name="LOOPBACKREF"></a>Кроме того, каталог <tt
             class="FILENAME">/dev</tt> содержит <span
             class="emphasis"><em
             class="EMPHASIS">loopback</em></span>-устройства
            (&quot;петлевые&quot; устройства), например <tt
             class="FILENAME">/dev/loop0</tt>. С помощью такого
            устройства можно представить обычный файл как блочное
            устройство ввода/вывода. <a
             name="AEN12973"
             href="#FTN.AEN12973"><span
             class="footnote">[57]</span></a> Это позволяет монтировать
            целые файловые системы, находящиеся в отдельных больших
            файлах. См. <a
             href="#CREATEFS">Пример 13-6</a> и <a
             href="#ISOMOUNTREF">Пример 13-5</a>.</p>

            <p>Отдельные псевдоустройства в <tt
             class="FILENAME">/dev</tt> имеют особое назначение, к
            таким устройствам можно отнести <a
             href="#ZEROSREF"><tt
             class="FILENAME">/dev/null</tt></a>, <a
             href="#ZEROSREF1"><tt
             class="FILENAME">/dev/zero</tt></a> и <a
             href="#URANDOMREF"><tt
             class="FILENAME">/dev/urandom</tt></a>.</p>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="PROCREF1"></a>27.2. <tt
             class="FILENAME">/proc</tt></h2>

            <p>Фактически, каталог <tt
             class="FILENAME">/proc</tt> -- это виртуальная файловая
            система. Файлы, в каталоге <tt
             class="FILENAME">/proc</tt>, содержат информацию о
            процессах, о состоянии и конфигурации ядра и системы.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /proc/devices</strong></tt>
<tt
 class="COMPUTEROUTPUT">Character devices:
   1 mem
   2 pty
   3 ttyp
   4 ttyS
   5 cua
   7 vcs
  10 misc
  14 sound
  29 fb
  36 netlink
 128 ptm
 136 pts
 162 raw
 254 pcmcia

 Block devices:
   1 ramdisk
   2 fd
   3 ide0
   9 md</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /proc/interrupts</strong></tt>
 <tt
 class="COMPUTEROUTPUT">          CPU0
   0:      84505          XT-PIC  timer
   1:       3375          XT-PIC  keyboard
   2:          0          XT-PIC  cascade
   5:          1          XT-PIC  soundblaster
   8:          1          XT-PIC  rtc
  12:       4231          XT-PIC  PS/2 Mouse
  14:     109373          XT-PIC  ide0
 NMI:          0
 ERR:          0</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /proc/partitions</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">major minor  #blocks  name     rio rmerge rsect ruse wio wmerge wsect wuse running use aveq

    3     0    3007872 hda 4472 22260 114520 94240 3551 18703 50384 549710 0 111550 644030
    3     1      52416 hda1 27 395 844 960 4 2 14 180 0 800 1140
    3     2          1 hda2 0 0 0 0 0 0 0 0 0 0 0
    3     4     165280 hda4 10 0 20 210 0 0 0 0 0 210 210
    ...</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /proc/loadavg</strong></tt>
<tt
 class="COMPUTEROUTPUT">0.13 0.42 0.27 2/44 1119</tt>
        
</pre>
            <br>
            <br>

            <p>Сценарии командной оболочки могут извлекать необходимую
            информацию из соответствующих файлов в каталоге <tt
             class="FILENAME">/proc</tt>. <a
             name="AEN13009"
             href="#FTN.AEN13009"><span
             class="footnote">[58]</span></a></p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>cat /proc/filesystems | grep iso9660</strong></tt>
 <tt
 class="COMPUTEROUTPUT">       iso9660</tt>

             
</pre>
            <br>
            <br>
<pre
 class="PROGRAMLISTING">
kernel_version=$( awk &#39;{ print $3 }&#39; /proc/version )
</pre>
            <br>
            <br>
<pre
 class="PROGRAMLISTING">
CPU=$( awk &#39;/model name/ {print $4}&#39; &lt; /proc/cpuinfo )

if [ $CPU = Pentium ]
then
  выполнить_ряд_специфичных_команд
  ...
else
  выполнить_ряд_других_специфичных_команд
  ...
fi
</pre>
            <br>
            <br>

            <p>В каталоге <tt
             class="FILENAME">/proc</tt> вы наверняка заметите большое
            количество подкаталогов, с не совсем обычными именами,
            состоящими только из цифр. Каждый из них соответствует
            исполняющемуся процессу, а имя каталога -- это <a
             href="#PPIDREF">ID (идентификатор) процесса</a>. Внутри
            каждого такого подкаталога находится ряд файлов, в которых
            содержится полезная информация о соответствующих процессах.
            Файлы <tt
             class="FILENAME">stat</tt> и <tt
             class="FILENAME">status</tt> хранят статистику работы
            процесса, <tt
             class="FILENAME">cmdline</tt> -- команда, которой был
            запущен процесс, <tt
             class="FILENAME">exe</tt> -- символическая ссылка на
            исполняемый файл программы. Здесь же вы найдете ряд других
            файлов, но, с точки зрения написания сценариев, они не так
            интересны, как эти четыре.</p>

            <div
             class="EXAMPLE">
              <a
               name="PIDID"></a>

              <p><strong>Пример 27-1. Поиск файла программы по
              идентификатору процесса</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# pid-identifier.sh: Возвращает полный путь к исполняемому файлу программы по идентификатору процесса (pid).

ARGNO=1  # Число, ожидаемых из командной строки, аргументов.
E_WRONGARGS=65
E_BADPID=66
E_NOSUCHPROCESS=67
E_NOPERMISSION=68
PROCFILE=exe

if [ $# -ne $ARGNO ]
then
  echo &quot;Порядок использования: `basename $0` PID-процесса&quot; &gt;&amp;2  # Сообщение об ошибке на &gt;stderr.
  exit $E_WRONGARGS
fi

ps ax

pidno=$( ps ax | grep $1 | awk &#39;{ print $1 }&#39; | grep $1 )
# Проверка наличия процесса с заданным pid в списке, выданном командой  &quot;ps&quot;, поле #1.
# Затем следует убедиться, что этот процесс не был запущен этим сценарием (&#39;ps&#39;).
# Это делает последний &quot;grep $1&quot;.
if [ -z &quot;$pidno&quot; ]  # Если после фильтрации получается пустая строка,
then                # то это означает, что в системе нет процесса с заданым pid.
  echo &quot;Нет такого процесса.&quot;
  exit $E_NOSUCHPROCESS
fi

# Альтернативный вариант:
#   if ! ps $1 &gt; /dev/null 2&gt;&amp;1
#   then                # в системе нет процесса с заданым pid.
#     echo &quot;Нет такого процесса.&quot;
#     exit $E_NOSUCHPROCESS
#    fi


if [ ! -r &quot;/proc/$1/$PROCFILE&quot; ]  # Проверить право на чтение.
then
  echo &quot;Процесс $1 найден, однако...&quot;
  echo &quot;у вас нет права на чтение файла /proc/$1/$PROCFILE.&quot;
  exit $E_NOPERMISSION  # Обычный пользователь не имеет прав
                        # на доступ к некоторым файлам в каталоге /proc.
fi

# Последние две проверки могут быть заменены на:
#    if ! kill -0 $1 &gt; /dev/null 2&gt;&amp;1 # &#39;0&#39; -- это не сигнал, но
                                      # команда все равно проверит наличие
                                      # процесса-получателя.
#    then echo &quot;Процесс с данным PID не найден, либо вы не являетесь его владельцем&quot; &gt;&amp;2
#    exit $E_BADPID
#    fi



exe_file=$( ls -l /proc/$1 | grep &quot;exe&quot; | awk &#39;{ print $11 }&#39; )
# Или      exe_file=$( ls -l /proc/$1/exe | awk &#39;{print $11}&#39; )
#
# /proc/pid-number/exe -- это символическая ссылка
# на исполняемый файл работающей программы.

if [ -e &quot;$exe_file&quot; ]  # Если файл /proc/pid-number/exe существует...
then                 # то существует и соответствующий процесс.
  echo &quot;Исполняемый файл процесса #$1: $exe_file.&quot;
else
  echo &quot;Нет такого процесса.&quot;
fi


# В большинстве случаев, этот, довольно сложный сценарий, может быть заменен командой
# ps ax | grep $1 | awk &#39;{ print $5 }&#39;
# В большинстве, но не всегда...
# поскольку пятое поле листинга,выдаваемого командой &#39;ps&#39;, это argv[0] процесса,
# а не путь к исполняемому файлу.
#
# Однако, оба следующих варианта должны работать безотказно.
#       find /proc/$1/exe -printf &#39;%l\n&#39;
#       lsof -aFn -p $1 -d txt | sed -ne &#39;s/^n//p&#39;

# Автор последнего комментария: Stephane Chazelas.

exit 0

<a href="abs7.html">Advanced Bash-Scripting Guide - Часть 7</a>
  </body>
</html>

