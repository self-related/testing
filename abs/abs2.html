<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <meta
     name="generator"
     content=
    "HTML Tidy for Linux/x86 (vers 1st July 2002), see www.w3.org">

    <title>Advanced Bash-Scripting Guide - Часть 2</title>
    <meta
     http-equiv="Content-Type"
     content="text/html; charset=koi8-r">
    <meta
     name="GENERATOR"
     content="Modular DocBook HTML Stylesheet Version 1.7">
  </head>
        <h1
         class="TITLE"><a
         name="AEN2"></a>Advanced Bash-Scripting Guide - Часть 2</h1>
  <body
   class="BOOK"
   bgcolor="#FFFFFF"
   text="#000000"
   link="#0000FF"
   vlink="#840084"
   alink="#0000FF">
      <div
       class="TOC">

              <dt>8. <a
               href="#OPERATIONS">Операции и смежные темы</a></dt>

              <dd>
                <dl>
                  <dt>8.1. <a
                   href="#OPS">Операторы</a></dt>

                  <dt>8.2. <a
                   href="#NUMERICAL-CONSTANTS">Числовые
                  константы</a></dt>
                </dl>
              </dd>
            </dl>
          </dd>

          <dt>Часть 3. <a
           href="#PART3">Углубленный материал</a></dt>

          <dd>
            <dl>
              <dt>9. <a
               href="#VARIABLES2">К вопросу о переменных</a></dt>

              <dd>
                <dl>
                  <dt>9.1. <a
                   href="#INTERNALVARIABLES">Внутренние
                  переменные</a></dt>

                  <dt>9.2. <a
                   href="#STRING-MANIPULATION">Работа со
                  строками</a></dt>

                  <dt>9.3. <a
                   href="#PARAMETER-SUBSTITUTION">Подстановка
                  параметров</a></dt>

                  <dt>9.4. <a
                   href="#DECLAREREF">Объявление переменных: <strong
                   class="COMMAND">declare</strong> и <strong
                   class="COMMAND">typeset</strong></a></dt>

                  <dt>9.5. <a
                   href="#IVR">Косвенные ссылки на переменные</a></dt>

                  <dt>9.6. <a
                   href="#RANDOMVAR">$RANDOM: генерация псевдослучайных
                  целых чисел</a></dt>






				  
<pre
 class="SCREEN">
             <tt
 class=
"COMPUTEROUTPUT">-rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd</tt>
             
</pre>
                  Файл с установленным флагом <tt
                   class="REPLACEABLE"><em>suid</em></tt> отображается
                  с включенным флагом <span
                   class="emphasis"><em
                   class="EMPHASIS">s</em></span> в поле прав
                  доступа.<br>
                  <br>
                </dd>

                <dt><span
                 class="TOKEN">-k</span></dt>

                <dd>
                  <p>флаг <tt
                   class="REPLACEABLE"><em>sticky bit</em></tt> (бит
                  фиксации) установлен</p>

                  <p>Общеизвестно, что флаг <span
                   class="QUOTE">&quot;sticky bit&quot;</span> -- это
                  специальный тип прав доступа к файлам. Программы с
                  установленным флагом <span
                   class="QUOTE">&quot;sticky bit&quot;</span> остаются
                  в системном кэше после своего завершения, обеспечивая
                  тем самым более быстрый запуск программы. <a
                   name="AEN2508"
                   href="#FTN.AEN2508"><span
                   class="footnote">[17]</span></a> Если флаг
                  установлен для каталога, то это приводит к
                  ограничению прав на запись. Установленный флаг
                  &quot;sticky bit&quot; отображается в виде символа
                  <span
                   class="emphasis"><em
                   class="EMPHASIS">t</em></span> в поле прав
                  доступа.</p>
<pre
 class="SCREEN">
             <tt
 class=
"COMPUTEROUTPUT">drwxrwxrwt    7 root         1024 May 19 21:26 tmp/</tt>
             
</pre>
                  Если пользователь не является владельцем каталога, с
                  установленным &quot;sticky bit&quot;, но имеет право
                  на запись в каталог, то он может удалять только те
                  файлы в каталоге, владельцем которых он является. Это
                  предотвращает удаление и перезапись &quot;чужих&quot;
                  файлов в общедоступных каталогах, таких как <tt
                   class="FILENAME">/tmp</tt>.<br>
                  <br>
                </dd>

                <dt><span
                 class="TOKEN">-O</span></dt>

                <dd>
                  <p>вы являетесь владельцем файла</p>
                </dd>

                <dt><span
                 class="TOKEN">-G</span></dt>

                <dd>
                  <p>вы принадлежите к той же группе, что и файл</p>
                </dd>

                <dt><span
                 class="TOKEN">-N</span></dt>

                <dd>
                  <p>файл был модифицирован с момента последнего
                  чтения</p>
                </dd>

                <dt><span
                 class="TOKEN">f1 -nt f2</span></dt>

                <dd>
                  <p>файл <tt
                   class="REPLACEABLE"><em>f1</em></tt> более новый,
                  чем <tt
                   class="REPLACEABLE"><em>f2</em></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">f1 -ot f2</span></dt>

                <dd>
                  <p>файл <tt
                   class="REPLACEABLE"><em>f1</em></tt> более старый,
                  чем <tt
                   class="REPLACEABLE"><em>f2</em></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">f1 -ef f2</span></dt>

                <dd>
                  <p>файлы <tt
                   class="REPLACEABLE"><em>f1</em></tt> и <tt
                   class="REPLACEABLE"><em>f2</em></tt> являются
                  &quot;жесткими&quot; ссылками на один и тот же
                  файл</p>
                </dd>

                <dt><span
                 class="TOKEN">!</span></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;НЕ&quot;</span> -- логическое
                  отрицание (инверсия) результатов всех вышеприведенных
                  проверок (возвращается true если условие
                  отсутствует).</p>
                </dd>
              </dl>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="BROKENLINK"></a>

              <p><strong>Пример 7-4. Проверка &quot;битых&quot;
              ссылок</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# broken-link.sh
# Автор Lee Bigelow &lt;ligelowbee@yahoo.com&gt;
# Используется с его разрешения.

#Сценарий поиска &quot;битых&quot; ссылок и их вывод в &quot;окавыченном&quot; виде
#таким образом они могут передаваться утилите xargs для дальнейшей обработки :)
#например. broken-link.sh /somedir /someotherdir|xargs rm
#
#На всякий случай приведу лучший метод:
#
#find &quot;somedir&quot; -type l -print0|\
#xargs -r0 file|\
#grep &quot;broken symbolic&quot;|
#sed -e &#39;s/^\|: *broken symbolic.*$/&quot;/g&#39;
#
#но это не чисто BASH-евский метод, а теперь сам сценарий.
#Внимание! будьте осторожны с файловой системой /proc и циклическими ссылками!
##############################################################


#Если скрипт не получает входных аргументов,
#то каталогом поиска является текущая директория
#В противном случае, каталог поиска задается из командной строки
####################
[ $# -eq 0 ] &amp;&amp; directorys=`pwd` || directorys=$@

#Функция linkchk проверяет каталог поиска
#на наличие в нем ссылок на несуществующие файлы, и выводит их имена.
#Если анализируемый файл является каталогом,
#то он передается функции linkcheck рекурсивно.
##########
linkchk () {
    for element in $1/*; do
    [ -h &quot;$element&quot; -a ! -e &quot;$element&quot; ] &amp;&amp; echo \&quot;$element\&quot;
    [ -d &quot;$element&quot; ] &amp;&amp; linkchk $element
    # Само собой, &#39;-h&#39; проверяет символические ссылки, &#39;-d&#39; -- каталоги.
    done
}

#Вызов функции linkchk для каждого аргумента командной строки,
#если он является каталогом.  Иначе выводится сообщение об ошибке
#и информация о порядке пользования скриптом.
################
for directory in $directorys; do
    if [ -d $directory ]
        then linkchk $directory
        else
            echo &quot;$directory не является каталогом&quot;
            echo &quot;Порядок использования: $0 dir1 dir2 ...&quot;
    fi
done

exit 0
</pre>
            </div>

            <p><a
             href="#COOKIES">Пример 28-1</a>, <a
             href="#BINGREP">Пример 10-7</a>, <a
             href="#FILEINFO">Пример 10-3</a>, <a
             href="#RAMDISK">Пример 28-3</a> и <a
             href="#MAILFORMAT">Пример A-2</a> так же иллюстрируют
            операции проверки файлов.</p>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="COMPARISON-OPS"></a>7.3. Операции сравнения</h2>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="ICOMPARISON1"></a>сравнение целых
              чисел</strong></p>

              <dl>
                <dt><span
                 class="TOKEN">-eq</span></dt>

                <dd>
                  <p><a
                   name="EQUALREF"></a></p>

                  <p>равно</p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; -eq
                  &quot;$b&quot; ]</strong></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">-ne</span></dt>

                <dd>
                  <p>не равно</p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; -ne
                  &quot;$b&quot; ]</strong></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">-gt</span></dt>

                <dd>
                  <p>больше</p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; -gt
                  &quot;$b&quot; ]</strong></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">-ge</span></dt>

                <dd>
                  <p>больше или равно</p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; -ge
                  &quot;$b&quot; ]</strong></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">-lt</span></dt>

                <dd>
                  <p>меньше</p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; -lt
                  &quot;$b&quot; ]</strong></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">-le</span></dt>

                <dd>
                  <p>меньше или равно</p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; -le
                  &quot;$b&quot; ]</strong></tt></p>
                </dd>

                <dt><a
                 name="INTLT"></a><span
                 class="TOKEN">&lt;</span></dt>

                <dd>
                  <p>меньше (внутри <a
                   href="#DBLPARENS">двойных круглых скобок</a> )</p>

                  <p><tt
                   class="USERINPUT"><strong>((&quot;$a&quot; &lt;
                  &quot;$b&quot;))</strong></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">&lt;=</span></dt>

                <dd>
                  <p>меньше или равно (внутри двойных круглых
                  скобок)</p>

                  <p><tt
                   class="USERINPUT"><strong>((&quot;$a&quot; &lt;=
                  &quot;$b&quot;))</strong></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">&gt;</span></dt>

                <dd>
                  <p>больше (внутри двойных круглых скобок)</p>

                  <p><tt
                   class="USERINPUT"><strong>((&quot;$a&quot; &gt;
                  &quot;$b&quot;))</strong></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">&gt;=</span></dt>

                <dd>
                  <p>больше или равно (внутри двойных круглых
                  скобок)</p>

                  <p><tt
                   class="USERINPUT"><strong>((&quot;$a&quot; &gt;=
                  &quot;$b&quot;))</strong></tt></p>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="SCOMPARISON1"></a>сравнение строк</strong></p>

              <dl>
                <dt><span
                 class="TOKEN">=</span></dt>

                <dd>
                  <p><a
                   name="EQUALSIGNREF"></a></p>

                  <p>равно</p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; =
                  &quot;$b&quot; ]</strong></tt></p>
                </dd>

                <dt><span
                 class="TOKEN">==</span></dt>

                <dd>
                  <p>равно</p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; ==
                  &quot;$b&quot; ]</strong></tt></p>

                  <p>Синоним оператора <span
                   class="TOKEN">=</span>.</p>
<pre
 class="PROGRAMLISTING">
[[ $a == z* ]]    # истина, если $a начинается с символа &quot;z&quot; (сравнение по шаблону)
[[ $a == &quot;z*&quot; ]]  # истина, если $a равна z*

[ $a == z* ]      # имеют место подстановка имен файлов и разбиение на слова
[ &quot;$a&quot; == &quot;z*&quot; ]  # истина, если $a равна z*

# Спасибо S.C.
</pre>
                  <br>
                  <br>
                </dd>

                <dt><span
                 class="TOKEN">!=</span></dt>

                <dd>
                  <p>не равно</p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; !=
                  &quot;$b&quot; ]</strong></tt></p>

                  <p>Этот оператор используется при поиске по шаблону
                  внутри <a
                   href="#DBLBRACKETS">[[ ... ]]</a>.</p>
                </dd>

                <dt><a
                 name="LTREF"></a><span
                 class="TOKEN">&lt;</span></dt>

                <dd>
                  <p>меньше, в смысле величины ASCII-кодов</p>

                  <p><tt
                   class="USERINPUT"><strong>if [[ &quot;$a&quot; &lt;
                  &quot;$b&quot; ]]</strong></tt></p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; \&lt;
                  &quot;$b&quot; ]</strong></tt></p>

                  <p>Обратите внимание! Символ <span
                   class="QUOTE">&quot;&lt;&quot;</span> необходимо
                  экранировать внутри <tt
                   class="USERINPUT"><strong>[ ]</strong></tt>.</p>
                </dd>

                <dt><a
                 name="GTREF"></a><span
                 class="TOKEN">&gt;</span></dt>

                <dd>
                  <p>больше, в смысле величины ASCII-кодов</p>

                  <p><tt
                   class="USERINPUT"><strong>if [[ &quot;$a&quot; &gt;
                  &quot;$b&quot; ]]</strong></tt></p>

                  <p><tt
                   class="USERINPUT"><strong>if [ &quot;$a&quot; \&gt;
                  &quot;$b&quot; ]</strong></tt></p>

                  <p>Обратите внимание! Символ <span
                   class="QUOTE">&quot;&gt;&quot;</span> необходимо
                  экранировать внутри <tt
                   class="USERINPUT"><strong>[ ]</strong></tt>.</p>

                  <p>См. <a
                   href="#BUBBLE">Пример 25-6</a> относительно
                  применения этого оператора сравнения.</p>
                </dd>

                <dt><span
                 class="TOKEN">-z</span></dt>

                <dd>
                  <p>строка <span
                   class="QUOTE">&quot;пустая&quot;</span>, т.е. имеет
                  нулевую длину</p>
                </dd>

                <dt><span
                 class="TOKEN">-n</span></dt>

                <dd>
                  <p>строка не <span
                   class="QUOTE">&quot;пустая&quot;</span>.</p>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Оператор <tt
                           class="USERINPUT"><strong>-n</strong></tt>
                          требует, чтобы строка была заключена в
                          кавычки внутри квадратных скобок. Как
                          правило, проверка строк, не заключенных в
                          кавычки, оператором <tt
                           class="USERINPUT"><strong>!
                          -z</strong></tt>, или просто указание строки
                          без кавычек внутри квадратных скобок (см. <a
                           href="#STRTEST">Пример 7-6</a>), проходит
                          нормально, однако это небезопасная, с точки
                          зрения отказоустойчивости, практика. <span
                           class="emphasis"><em
                           class="EMPHASIS">Всегда</em></span>
                          заключайте проверяемую строку в кавычки. <a
                           name="AEN2722"
                           href="#FTN.AEN2722"><span
                           class="footnote">[18]</span></a></p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="EX13"></a>

              <p><strong>Пример 7-5. Операции сравнения</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

a=4
b=5

#  Здесь переменные &quot;a&quot; и &quot;b&quot; могут быть как целыми числами, так и строками.
#  Здесь наблюдается некоторое размывание границ
#+ между целочисленными и строковыми переменными,
#+ поскольку переменные в Bash не имеют типов.

#  Bash выполняет целочисленные операции над теми переменными,
#+ которые содержат только цифры
#  Будьте внимательны!

echo

if [ &quot;$a&quot; -ne &quot;$b&quot; ]
then
  echo &quot;$a не равно $b&quot;
  echo &quot;(целочисленное сравнение)&quot;
fi

echo

if [ &quot;$a&quot; != &quot;$b&quot; ]
then
  echo &quot;$a не равно $b.&quot;
  echo &quot;(сравнение строк)&quot;
  #     &quot;4&quot;  != &quot;5&quot;
  # ASCII 52 != ASCII 53
fi

# Оба варианта, &quot;-ne&quot; и &quot;!=&quot;, работают правильно.

echo

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="STRTEST"></a>

              <p><strong>Пример 7-6. Проверка -- является ли строка
              <span
               class="emphasis"><em
               class="EMPHASIS">пустой</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# str-test.sh: Проверка пустых строк и строк, не заключенных в кавычки,

# Используется конструкция   if [ ... ]


# Если строка не инициализирована, то она не имеет никакого определенного значения.
# Такое состояние называется &quot;null&quot; (пустая) (это не то же самое, что ноль).

if [ -n $string1 ]    # $string1 не была объявлена или инициализирована.
then
  echo &quot;Строка \&quot;string1\&quot; не пустая.&quot;
else
  echo &quot;Строка \&quot;string1\&quot; пустая.&quot;
fi
# Неверный результат.
# Выводится сообщение о том, что $string1 не пустая,
#+не смотря на то, что она не была инициализирована.


echo


# Попробуем еще раз.

if [ -n &quot;$string1&quot; ]  # На этот раз, переменная $string1 заключена в кавычки.
then
  echo &quot;Строка \&quot;string1\&quot; не пустая.&quot;
else
  echo &quot;Строка \&quot;string1\&quot; пустая.&quot;
fi      # Внутри квадратных скобок заключайте строки в кавычки!


echo


if [ $string1 ]       # Опустим оператор -n.
then
  echo &quot;Строка \&quot;string1\&quot; не пустая.&quot;
else
  echo &quot;Строка \&quot;string1\&quot; пустая.&quot;
fi
# Все работает прекрасно.
# Квадратные скобки -- [ ], без посторонней помощи определяют, что строка пустая.
# Тем не менее, хорошим тоном считается заключать строки в кавычки (&quot;$string1&quot;).
#
# Как указывает Stephane Chazelas,
#    if [ $string 1 ]   один аргумент &quot;]&quot;
#    if [ &quot;$string 1&quot; ]  два аргумента, пустая &quot;$string1&quot; и &quot;]&quot;



echo



string1=initialized

if [ $string1 ]       # Опять, попробуем строку без ничего.
then
  echo &quot;Строка \&quot;string1\&quot; не пустая.&quot;
else
  echo &quot;Строка \&quot;string1\&quot; пустая.&quot;
fi
# И снова получим верный результат.
# И опять-таки, лучше поместить строку в кавычки (&quot;$string1&quot;), поскольку...


string1=&quot;a = b&quot;

if [ $string1 ]       # И снова, попробуем строку без ничего..
then
  echo &quot;Строка \&quot;string1\&quot; не пустая.&quot;
else
  echo &quot;Строка \&quot;string1\&quot; пустая.&quot;
fi
# Строка без кавычек дает неверный результат!

exit 0
# Спвсибо Florian Wisser, за предупреждение.
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="EX14"></a>

              <p><strong>Пример 7-7. zmost</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#Просмотр gz-файлов с помощью утилиты &#39;most&#39;

NOARGS=65
NOTFOUND=66
NOTGZIP=67

if [ $# -eq 0 ] # то же, что и:  if [ -z &quot;$1&quot; ]
# $1 должен существовать, но может быть пустым:  zmost &quot;&quot; arg2 arg3
then
  echo &quot;Порядок использования: `basename $0` filename&quot; &gt;&amp;2
  # Сообщение об ошибке на stderr.
  exit $NOARGS
  # Код возврата 65 (код ошибки).
fi

filename=$1

if [ ! -f &quot;$filename&quot; ]   # Кавычки необходимы на тот случай, если имя файла содержит пробелы.
then
  echo &quot;Файл $filename не найден!&quot; &gt;&amp;2
  # Сообщение об ошибке на stderr.
  exit $NOTFOUND
fi

if [ ${filename##*.} != &quot;gz&quot; ]
# Квадратные скобки нужны для выполнения подстановки значения переменной
then
  echo &quot;Файл $1 не является gz-файлом!&quot;
  exit $NOTGZIP
fi

zcat $1 | most

# Используется утилита &#39;most&#39; (очень похожа на &#39;less&#39;).
# Последние версии &#39;most&#39; могут просматривать сжатые файлы.
# Можно вставить &#39;more&#39; или &#39;less&#39;, если пожелаете.


exit $?   # Сценарий возвращает код возврата, полученный по конвейеру.
# На самом деле команда &quot;exit $?&quot; не является обязательной,
# так как работа скрипта завершится здесь в любом случае,
</pre>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="CCOMPARISON1"></a>построение сложных условий
              проверки</strong></p>

              <dl>
                <dt><span
                 class="TOKEN">-a</span></dt>

                <dd>
                  <p>логическое И (and)</p>

                  <p><tt
                   class="REPLACEABLE"><em>exp1 -a exp2</em></tt>
                  возвращает true, если <span
                   class="emphasis"><em
                   class="EMPHASIS">оба</em></span> выражения, и exp1,
                  и exp2 истинны.</p>
                </dd>

                <dt><span
                 class="TOKEN">-o</span></dt>

                <dd>
                  <p>логическое ИЛИ (or)</p>

                  <p><tt
                   class="REPLACEABLE"><em>exp1 -o exp2</em></tt>
                  возвращает true, если хотябы одно из выражений, exp1
                  <span
                   class="emphasis"><em
                   class="EMPHASIS">или</em></span> exp2 истинно.</p>
                </dd>
              </dl>
            </div>

            <p>Они похожи на операторы Bash <strong
             class="COMMAND">&amp;&amp;</strong> и <strong
             class="COMMAND">||</strong>, употребляемые в <a
             href="#DBLBRACKETS">двойных квадратных скобках</a>.</p>
<pre
 class="PROGRAMLISTING">
[[ condition1 &amp;&amp; condition2 ]]
</pre>
            Операторы <strong
             class="COMMAND">-o</strong> и <strong
             class="COMMAND">-a</strong> употребляются совместно с
            командой <strong
             class="COMMAND">test</strong> или внутри одинарных
            квадратных скобок. 
<pre
 class="PROGRAMLISTING">
if [ &quot;$exp1&quot; -a &quot;$exp2&quot; ]
</pre>
            <br>
            <br>

            <p>Чтобы увидеть эти операторы в действии, смотрите <a
             href="#ANDOR">Пример 8-3</a> и <a
             href="#TWODIM">Пример 25-11</a>.</p>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="NESTEDIFTHEN"></a>7.4. Вложенные условные операторы
            if/then</h2>

            <p>Операторы проверки условий <strong
             class="COMMAND">if/then</strong> могут быть вложенными
            друг в друга. Конечный результат будет таким же как если бы
            результаты всех проверок были объединены оператором <strong
             class="COMMAND">&amp;&amp;</strong>.</p>
<pre
 class="PROGRAMLISTING">
if [ condition1 ]
then
  if [ condition2 ]
  then
    do-something  # Только если оба условия &quot;condition1&quot; и &quot;condition2&quot; истинны.
  fi
fi
</pre>
            <br>
            <br>

            <p>См. <a
             href="#EX79">Пример 34-4</a> -- пример использования
            вложенных операторов <tt
             class="REPLACEABLE"><em>if/then</em></tt>.</p>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="TESTTEST"></a>7.5. Проверка степени усвоения
            материала</h2>

            <p>Для запуска X-сервера может быть использован файл <tt
             class="FILENAME">xinitrc</tt>. Этот файл содержит
            некоторое число операторов <span
             class="emphasis"><em
             class="EMPHASIS">if/then</em></span>. Ниже приводится
            отрывок из этого файла.</p>
<pre
 class="PROGRAMLISTING">
if [ -f $HOME/.Xclients ]; then
  exec $HOME/.Xclients
elif [ -f /etc/X11/xinit/Xclients ]; then
  exec /etc/X11/xinit/Xclients
else
     # failsafe settings.  Although we should never get here
     # (we provide fallbacks in Xclients as well) it can&#39;t hurt.
     xclock -geometry 100x100-5+5 &amp;
     xterm -geometry 80x50-50+150 &amp;
     if [ -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html ]; then
             netscape /usr/share/doc/HTML/index.html &amp;
     fi
fi
</pre>
            <br>
            <br>

            <p>Объясните действия условных операторов в вышеприведенном
            отрывке, затем просмотрите файл <tt
             class="FILENAME">/etc/X11/xinit/xinitrc</tt> и
            проанализируйте его. Возможно вам придется обратиться к
            разделам, посвященным <a
             href="#GREPREF">grep</a>, <a
             href="#SEDREF">sed</a> и <a
             href="#REGEXREF">регулярным выражениям</a>.</p>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="OPERATIONS"></a>Глава 8. Операции и смежные темы</h1>

          <div
           class="SECT1">
            <h2
             class="SECT1"><a
             name="OPS"></a>8.1. Операторы</h2>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="ASNOP1"></a>присваивание</strong></p>

              <dl>
                <dt><tt
                 class="REPLACEABLE"><em>variable
                assignment</em></tt></dt>

                <dd>
                  <p>Инициализация переменной или изменение ее
                  значения</p>
                </dd>

                <dt>=</dt>

                <dd>
                  <p>Универсальный оператор присваивания, пригоден как
                  для сравнения целых чисел, так и для сравнения
                  строк.</p>
<pre
 class="PROGRAMLISTING">
var=27
category=minerals  # Пробелы до и после оператора &quot;=&quot; -- недопустимы.
</pre>
                  <br>
                  <br>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Пусть вас не смущает, что оператор
                          присваивания (<span
                           class="QUOTE">&quot;=&quot;</span>), по
                          своему внешнему виду, совпадает с оператором
                          сравнения (<a
                           href="#EQUALSIGNREF">=</a>).</p>
<pre
 class="PROGRAMLISTING">
#    Здесь знак &quot;=&quot;  выступает в качестве оператора сравнения

if [ &quot;$string1&quot; = &quot;$string2&quot; ]
# if [ &quot;X$string1&quot; = &quot;X$string2&quot; ] более отказоустойчивый вариант,
# предохраняет от &quot;сваливания&quot; по ошибке в случае, когда одна из переменных пуста.
# (добавленные символы &quot;X&quot; компенсируют друг друга.)
then
   command
fi
</pre>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="AROPS1"></a>арифметические операторы</strong></p>

              <dl>
                <dt><span
                 class="TOKEN">+</span></dt>

                <dd>
                  <p>сложение</p>
                </dd>

                <dt><span
                 class="TOKEN">-</span></dt>

                <dd>
                  <p>вычитание</p>
                </dd>

                <dt><span
                 class="TOKEN">*</span></dt>

                <dd>
                  <p>умножение</p>
                </dd>

                <dt><span
                 class="TOKEN">/</span></dt>

                <dd>
                  <p>деление</p>
                </dd>

                <dt><a
                 name="EXPONENTIATIONREF"></a><span
                 class="TOKEN">**</span></dt>

                <dd>
                  <p>возведение в степень</p>
<pre
 class="PROGRAMLISTING">
# В Bash, начиная с версии 2.02, был введен оператор возведения в степень -- &quot;**&quot;.

let &quot;z=5**3&quot;
echo &quot;z = $z&quot;   # z = 125
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="MODULOREF"></a><span
                 class="TOKEN">%</span></dt>

                <dd>
                  <p>модуль (деление по модулю), возвращает остаток от
                  деления</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo `expr 5 % 3`</strong></tt>
<tt
 class="COMPUTEROUTPUT">2</tt>
             
</pre>
                  <br>
                  <br>

                  <p>Этот оператор может применяться в алгоритмах
                  генерации псевдослучайных чисел в заданном диапазоне
                  (см. <a
                   href="#EX21">Пример 9-23</a> и <a
                   href="#RANDOMTEST">Пример 9-25</a>), для
                  форматирования вывода на экран (см. <a
                   href="#QFUNCTION">Пример 25-10</a> и <a
                   href="#COLLATZ">Пример A-7</a>), и даже для
                  генерации простых чисел (см. <a
                   href="#PRIMES">Пример A-18</a>). На удивление часто
                  операцию деления по модулю можно встретить в
                  различных численных алгоритмах.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="GCD"></a>

                    <p><strong>Пример 8-1. Наибольший общий
                    делитель</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# gcd.sh: поиск наибольшего общего делителя
#         по алгоритму Эвклида

#  Под &quot;наибольшим общим делителем&quot; (нод) двух целых чисел
#+ понимается наибольшее целое число, которое делит оба делимых без остатка.

#  Алгоритм Эвклида выполняет последовательное деление.
#  В каждом цикле,
#+ делимое  &lt;---  делитель
#+ делитель &lt;---  остаток
#+ до тех пор, пока остаток не станет равным нулю (остаток = 0).
#+ The gcd = dividend, on the final pass.
#
#  Замечательное описание алгоритма Эвклида можно найти
#  на сайте Jim Loy, http://www.jimloy.com/number/euclids.htm.


# ------------------------------------------------------
# Проверка входных параметров
ARGS=2
E_BADARGS=65

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` первое-число второе-число&quot;
  exit $E_BADARGS
fi
# ------------------------------------------------------


gcd ()
{

                                 #  Начальное присваивание.
  dividend=$1                    #  В сущности, не имеет значения
  divisor=$2                     #+ какой из них больше.
                                 #  Почему?

  remainder=1                    #  Если переменные неинициализировать,
                                 #+ то работа сценария будет прервана по ошибке
                                 #+ в первом же цикле.

  until [ &quot;$remainder&quot; -eq 0 ]
  do
    let &quot;remainder = $dividend % $divisor&quot;
    dividend=$divisor            # Повторить цикл с новыми исходными данными
    divisor=$remainder
  done                           # алгоритм Эвклида

}                                # последнее $dividend и есть нод.


gcd $1 $2

echo; echo &quot;НОД чисел $1 и $2 = $dividend&quot;; echo


# Упражнение :
# --------
#  Вставьте дополнительную проверку входных аргументов,
#+ и предусмотрите завершение работы сценария с сообщением об ошибке, если
#+ входные аргументы не являются целыми числами.

exit 0
</pre>
                  </div>
                </dd>

                <dt><span
                 class="TOKEN">+=</span></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;плюс-равно&quot;</span>
                  (увеличивает значение переменной на заданное
                  число)</p>

                  <p><tt
                   class="USERINPUT"><strong>let &quot;var +=
                  5&quot;</strong></tt> значение переменной <tt
                   class="VARNAME">var</tt> будет увеличено на <tt
                   class="LITERAL">5</tt>.</p>
                </dd>

                <dt><span
                 class="TOKEN">-=</span></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;минус-равно&quot;</span>
                  (уменьшение значения переменной на заданное
                  число)</p>
                </dd>

                <dt><span
                 class="TOKEN">*=</span></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;умножить-равно&quot;</span>
                  (умножить значение переменной на заданное число,
                  результат записать в переменную)</p>

                  <p><tt
                   class="USERINPUT"><strong>let &quot;var *=
                  4&quot;</strong></tt> значение переменной <tt
                   class="VARNAME">var</tt> будет увеличено в <tt
                   class="LITERAL">4</tt> раза.</p>
                </dd>

                <dt><span
                 class="TOKEN">/=</span></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;слэш-равно&quot;</span>
                  (уменьшение значения переменной в заданное число
                  раз)</p>
                </dd>

                <dt><span
                 class="TOKEN">%=</span></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;процент-равно&quot;</span>
                  (найти остаток от деления значения переменной на
                  заданное число, результат записать в переменную)</p>

                  <p><span
                   class="emphasis"><em
                   class="EMPHASIS">Арифметические операторы очень
                  часто используются совместно с командами <a
                   href="#EXPRREF">expr</a> и <a
                   href="#LETREF">let</a>.</em></span></p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="ARITHOPS"></a>

                    <p><strong>Пример 8-2. Арифметические
                    операции</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# От 1 до 6 пятью различными способами.

n=1; echo -n &quot;$n &quot;

let &quot;n = $n + 1&quot;   # let &quot;n = n + 1&quot;   тоже допустимо
echo -n &quot;$n &quot;

: $((n = $n + 1))
# оператор &quot;:&quot; обязателен, поскольку в противном случае, Bash будет
#+ интерпретировать выражение &quot;$((n = $n + 1))&quot; как команду.
echo -n &quot;$n &quot;

n=$(($n + 1))
echo -n &quot;$n &quot;

: $[ n = $n + 1 ]
# оператор &quot;:&quot; обязателен, поскольку в противном случае, Bash будет
#+ интерпретировать выражение &quot;$[ n = $n + 1 ]&quot; как команду.
# Не вызывает ошибки даже если &quot;n&quot; содержит строку.
echo -n &quot;$n &quot;

n=$[ $n + 1 ]
#  Не вызывает ошибки даже если &quot;n&quot; содержит строку.
#* Старайтесь избегать употребления такой конструкции,
#+ поскольку она уже давно устарела и не переносима.
echo -n &quot;$n &quot;; echo

# Спасибо Stephane Chazelas.

exit 0
</pre>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Целые числа в Bash фактически являются знаковыми
                    <span
                     class="emphasis"><em
                     class="EMPHASIS">длинными</em></span> целыми
                    (32-бит), с диапазоном изменений от -2147483648 до
                    2147483647. Если в результате какой либо операции
                    эти пределы будут превышены, то результат получится
                    ошибочным.</p>
<pre
 class="PROGRAMLISTING">
a=2147483646
echo &quot;a = $a&quot;      # a = 2147483646
let &quot;a+=1&quot;         # Увеличить &quot;a&quot; на 1.
echo &quot;a = $a&quot;      # a = 2147483647
let &quot;a+=1&quot;         # увеличить &quot;a&quot; еще раз, с выходом за границы диапазона.
echo &quot;a = $a&quot;      # a = -2147483648
                   #      ОШИБКА! (выход за границы диапазона)
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Bash ничего не знает о существовании чисел с
                    плавающей запятой. Такие числа, из-за наличия
                    символа десятичной точки, он воспринимает как
                    строки.</p>
<pre
 class="PROGRAMLISTING">
a=1.5

let &quot;b = $a + 1.3&quot;  # Ошибка.
# t2.sh: let: b = 1.5 + 1.3: syntax error in expression (error token is &quot;.5 + 1.3&quot;)

echo &quot;b = $b&quot;       # b=1
</pre>
                    Для работы с числами с плавающей запятой в
                    сценариях можно использовать утилиту-калькулятор <a
                     href="#BCREF">bc</a>.<br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="FORMALPARA">
              <p><strong>битовые операции.</strong> Битовые операции
              очень редко используются в сценариях командного
              интерпретатора. Их главное назначение, на мой взгляд,
              установка и проверка некоторых значений, читаемых из
              портов ввода-вывода и сокетов. <span
               class="QUOTE">&quot;Битовые операции&quot;</span>
              гораздо более уместны в компилирующих языках
              программирования, таких как C и C++.</p>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="BITWSOPS1"></a>битовые операции</strong></p>

              <dl>
                <dt><span
                 class="TOKEN">&lt;&lt;</span></dt>

                <dd>
                  <p>сдвигает на 1 бит влево (умножение на <tt
                   class="LITERAL">2</tt>)</p>
                </dd>

                <dt><span
                 class="TOKEN">&lt;&lt;=</span></dt>

                <dd>
                  <p><span
                   class=
                  "QUOTE">&quot;сдвиг-влево-равно&quot;</span></p>

                  <p><tt
                   class="USERINPUT"><strong>let &quot;var &lt;&lt;=
                  2&quot;</strong></tt> значение переменной <tt
                   class="VARNAME">var</tt> сдвигается влево на 2 бита
                  (умножается на <tt
                   class="LITERAL">4</tt>)</p>
                </dd>

                <dt><span
                 class="TOKEN">&gt;&gt;</span></dt>

                <dd>
                  <p>сдвиг вправо на 1 бит (деление на <tt
                   class="LITERAL">2</tt>)</p>
                </dd>

                <dt><span
                 class="TOKEN">&gt;&gt;=</span></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;сдвиг-вправо-равно&quot;</span>
                  (имеет смысл обратный <span
                   class="TOKEN">&lt;&lt;=</span>)</p>
                </dd>

                <dt><span
                 class="TOKEN">&amp;</span></dt>

                <dd>
                  <p>по-битовое И (AND)</p>
                </dd>

                <dt><span
                 class="TOKEN">&amp;=</span></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;по-битовое
                  И-равно&quot;</span></p>
                </dd>

                <dt><span
                 class="TOKEN">|</span></dt>

                <dd>
                  <p>по-битовое ИЛИ (OR)</p>
                </dd>

                <dt><span
                 class="TOKEN">|=</span></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;по-битовое
                  ИЛИ-равно&quot;</span></p>
                </dd>

                <dt><span
                 class="TOKEN">~</span></dt>

                <dd>
                  <p>по-битовая инверсия</p>
                </dd>

                <dt><span
                 class="TOKEN">!</span></dt>

                <dd>
                  <p>По-битовое отрицание</p>
                </dd>

                <dt><span
                 class="TOKEN">^</span></dt>

                <dd>
                  <p>по-битовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)</p>
                </dd>

                <dt><span
                 class="TOKEN">^=</span></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;по-битовое
                  ИСКЛЮЧАЮЩЕЕ-ИЛИ-равно&quot;</span></p>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="LOGOPS1"></a>логические операции</strong></p>

              <dl>
                <dt><span
                 class="TOKEN">&amp;&amp;</span></dt>

                <dd>
                  <p>логическое И (and)</p>
<pre
 class="PROGRAMLISTING">
if [ $condition1 ] &amp;&amp; [ $condition2 ]
# То же самое, что:  if [ $condition1 -a $condition2 ]
# Возвращает true если оба операнда condition1 и condition2 истинны...

if [[ $condition1 &amp;&amp; $condition2 ]]    # То же верно
# Обратите внимание: оператор &amp;&amp; не должен использоваться внутри [ ... ].
</pre>
                  <br>
                  <br>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>оператор <span
                           class="TOKEN">&amp;&amp;</span>, в
                          зависимости от контекста, может так же
                          использоваться в <a
                           href="#LISTCONSREF">И-списках</a> для
                          построения составных команд.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><a
                 name="ORREF"></a><span
                 class="TOKEN">||</span></dt>

                <dd>
                  <p>логическое ИЛИ (or)</p>
<pre
 class="PROGRAMLISTING">
if [ $condition1 ] || [ $condition2 ]
# То же самое, что:  if [ $condition1 -o $condition2 ]
# Возвращает true если хотя бы один из операндов истинен...

if [[ $condition1 || $condition2 ]]    # Also works.
# Обратите внимание: оператор || не должен использоваться внутри [ ... ].
</pre>
                  <br>
                  <br>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Bash производит проверку <a
                           href="#EXITSTATUSREF">кода возврата</a>
                          КАЖДОГО из операндов в логических
                          выражениях.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="ANDOR"></a>

                    <p><strong>Пример 8-3. Построение сложных условий,
                    использующих &amp;&amp; и ||</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

a=24
b=47

if [ &quot;$a&quot; -eq 24 ] &amp;&amp; [ &quot;$b&quot; -eq 47 ]
then
  echo &quot;Первая проверка прошла успешно.&quot;
else
  echo &quot;Первая проверка не прошла.&quot;
fi

# ОКА:  if [ &quot;$a&quot; -eq 24 &amp;&amp; &quot;$b&quot; -eq 47 ]
#          пытается выполнить  &#39; [ &quot;$a&quot; -eq 24 &#39;
#          и терпит неудачу наткнувшись на &#39;]&#39;.
#
#    if [[ $a -eq 24 &amp;&amp; $b -eq 24 ]]   это правильный вариант
#    (в строке 17 оператор &quot;&amp;&amp;&quot; имеет иной смысл, нежели в строке 6.)
#    Спасибо Stephane Chazelas.


if [ &quot;$a&quot; -eq 98 ] || [ &quot;$b&quot; -eq 47 ]
then
  echo &quot;Вторая проверка прошла успешно.&quot;
else
  echo &quot;Вторая проверка не прошла.&quot;
fi


#  Опции -a и -o предоставляют
#+ альтернативный механизм проверки условий.
#  Спасибо Patrick Callahan.


if [ &quot;$a&quot; -eq 24 -a &quot;$b&quot; -eq 47 ]
then
  echo &quot;Третья проверка прошла успешно.&quot;
else
  echo &quot;Третья проверка не прошла.&quot;
fi


if [ &quot;$a&quot; -eq 98 -o &quot;$b&quot; -eq 47 ]
then
  echo &quot;Четвертая проверка прошла успешно.&quot;
else
  echo &quot;Четвертая проверка не прошла.&quot;
fi


a=rhino
b=crocodile
if [ &quot;$a&quot; = rhino ] &amp;&amp; [ &quot;$b&quot; = crocodile ]
then
  echo &quot;Пятая проверка прошла успешно.&quot;
else
  echo &quot;Пятая проверка не прошла.&quot;
fi

exit 0
</pre>
                  </div>

                  <p>Операторы <span
                   class="TOKEN">&amp;&amp;</span> и <span
                   class="TOKEN">||</span> могут использоваться и в
                  арифметических вычислениях.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo $(( 1 &amp;&amp; 2 )) $((3 &amp;&amp; 0)) $((4 || 0)) $((0 || 0))</strong></tt>
<tt
 class="COMPUTEROUTPUT">1 0 1 0</tt>
             
</pre>
                  <br>
                  <br>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="MISCOP1"></a>прочие операции</strong></p>

              <dl>
                <dt><a
                 name="COMMAOP"></a><span
                 class="TOKEN">,</span></dt>

                <dd>
                  <p>запятая</p>

                  <p>С помощью оператора <strong
                   class="COMMAND">запятая</strong> можно связать
                  несколько арифметических в одну последовательность.
                  При разборе таких последовательностей, командный
                  интерпретатор вычисляет все выражения (которые могут
                  иметь побочные эффекты) в последовательности и
                  возвращает результат последнего.</p>
<pre
 class="PROGRAMLISTING">
let &quot;t1 = ((5 + 3, 7 - 1, 15 - 4))&quot;
echo &quot;t1 = $t1&quot;               # t1 = 11

let &quot;t2 = ((a = 9, 15 / 3))&quot;  #  Выполняется присваивание &quot;a&quot; = 9,
                              #+ а затем вычисляется &quot;t2&quot;.
echo &quot;t2 = $t2    a = $a&quot;     # t2 = 5    a = 9
</pre>
                  <br>
                  <br>

                  <p>Оператор запятая чаще всего находит применение в
                  <a
                   href="#FORLOOPREF1">циклах for</a>. См. <a
                   href="#FORLOOPC">Пример 10-12</a>.</p>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="NUMERICAL-CONSTANTS"></a>8.2. Числовые
            константы</h2>

            <p><a
             name="NUMCONSTANTS"></a>Интерпретатор командной оболочки
            воспринимает числа как десятичные, в противном случае числу
            должен предшествовать специальный префикс, либо число
            должно быть записано в особой нотации. Числа, начинающиеся
            с символа <tt
             class="REPLACEABLE"><em>0</em></tt>, считаются <tt
             class="REPLACEABLE"><em>восьмеричными</em></tt>. если
            числу предшествует префикс <tt
             class="REPLACEABLE"><em>0x</em></tt>, то число считается
            <tt
             class="REPLACEABLE"><em>шестнадцатиричным</em></tt>.
            Число, в записи которого присутствует символ <tt
             class="REPLACEABLE"><em>#</em></tt>, расценивается как
            запись числа с указанием основы счисления в виде <tt
             class="REPLACEABLE"><em>ОСНОВА#ЧИСЛО</em></tt>.</p>

            <div
             class="EXAMPLE">
              <a
               name="NUMBERS"></a>

              <p><strong>Пример 8-4. Различные представления числовых
              констант</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# numbers.sh: Различные представления числовых констант.

# Десятичное: по-умолчанию
let &quot;dec = 32&quot;
echo &quot;десятичное число = $dec&quot;             # 32
# Вобщем-то ничего необычного.


# Восьмеричное: числа начинаются с &#39;0&#39; (нуля)
let &quot;oct = 032&quot;
echo &quot;восьмеричное число = $oct&quot;           # 26
# Результат печатается в десятичном виде.
# --------- ------ -- -------

# Шестнадцатиричное: числа начинаются с &#39;0x&#39; или &#39;0X&#39;
let &quot;hex = 0x32&quot;
echo &quot;шестнадцатиричное число = $hex&quot;      # 50
# Результат печатается в десятичном виде.

# Другие основы счисления: ОСНОВА#ЧИСЛО
# ОСНОВА должна быть между 2 и 64.
# для записи ЧИСЛА должен использоваться соответствующий ОСНОВЕ диапазон символов,
# см. ниже.

let &quot;bin = 2#111100111001101&quot;
echo &quot;двоичное число = $bin&quot;               # 31181

let &quot;b32 = 32#77&quot;
echo &quot;32-ричное число = $b32&quot;              # 231

let &quot;b64 = 64#@_&quot;
echo &quot;64-ричное число = $b64&quot;              # 4094
#
#  Нотация ОСНОВА#ЧИСЛО может использоваться на ограниченном
#+ диапазоне основ счисления (от 2 до 64)
#  10 цифр + 26 символов в нижнем регистре + 26 символов в верхнем регистре + @ + _

echo

echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))
                                         # 1295 170 44822 3375


#  Важное замечание:
#  --------------
#  Использование символов, для записи числа, выходящих за диапазо,
#+ соответствующий ОСНОВЕ счисления
#+ будет приводить к появлению сообщений об ошибках.

let &quot;bad_oct = 081&quot;
# numbers.sh: let: oct = 081: value too great for base (error token is &quot;081&quot;)
#                  Для записи восьмеричных чисел допускается использовать
#+                 только цифры в диапазоне 0 - 7.

exit 0       # Спасибо Rich Bartell и Stephane Chazelas, за разъяснения.
</pre>
            </div>
          </div>
        </div>
      </div>

      <div
       class="PART">
        <a
         name="PART3"></a>

        <div
         class="TITLEPAGE">
          <h1
           class="TITLE">Часть 3. Углубленный материал</h1>

          <div
           class="TOC">
            <dl>
              <dt><strong>Содержание</strong></dt>

              <dt>9. <a
               href="#VARIABLES2">К вопросу о переменных</a></dt>

              <dd>
                <dl>
                  <dt>9.1. <a
                   href="#INTERNALVARIABLES">Внутренние
                  переменные</a></dt>

                  <dt>9.2. <a
                   href="#STRING-MANIPULATION">Работа со
                  строками</a></dt>

                  <dd>
                    <dl>
                      <dt>9.2.1. <a
                       href="#AWKSTRINGMANIP">Использование awk при
                      работе со строками</a></dt>

                      <dt>9.2.2. <a
                       href="#STRFDISC">Дальнейшее обсуждение</a></dt>
                    </dl>
                  </dd>

                  <dt>9.3. <a
                   href="#PARAMETER-SUBSTITUTION">Подстановка
                  параметров</a></dt>

                  <dt>9.4. <a
                   href="#DECLAREREF">Объявление переменных: <strong
                   class="COMMAND">declare</strong> и <strong
                   class="COMMAND">typeset</strong></a></dt>

                  <dt>9.5. <a
                   href="#IVR">Косвенные ссылки на переменные</a></dt>

                  <dt>9.6. <a
                   href="#RANDOMVAR">$RANDOM: генерация псевдослучайных
                  целых чисел</a></dt>

                  <dt>9.7. <a
                   href="#DBLPARENS">Двойные круглые скобки</a></dt>
                </dl>
              </dd>

              <dt>10. <a
               href="#LOOPS">Циклы и ветвления</a></dt>

              <dd>
                <dl>
                  <dt>10.1. <a
                   href="#LOOPS1">Циклы</a></dt>

                  <dt>10.2. <a
                   href="#NESTEDLOOPS">Вложенные циклы</a></dt>

                  <dt>10.3. <a
                   href="#LOOPCONTROL">Управление ходом выполнения
                  цикла</a></dt>

                  <dt>10.4. <a
                   href="#TESTBRANCH">Операторы выбора</a></dt>
                </dl>
              </dd>

              <dt>11. <a
               href="#INTERNAL">Внутренние команды</a></dt>

              <dd>
                <dl>
                  <dt>11.1. <a
                   href="#AEN6110">Команды управления
                  заданиями</a></dt>
                </dl>
              </dd>

              <dt>12. <a
               href="#EXTERNAL">Внешние команды, программы и
              утилиты</a></dt>

              <dd>
                <dl>
                  <dt>12.1. <a
                   href="#BASIC">Базовые команды</a></dt>

                  <dt>12.2. <a
                   href="#MOREADV">Более сложные команды</a></dt>

                  <dt>12.3. <a
                   href="#TIMEDATE">Команды для работы с датой и
                  временем</a></dt>

                  <dt>12.4. <a
                   href="#TEXTPROC">Команды обработки текста</a></dt>

                  <dt>12.5. <a
                   href="#FILEARCHIV">Команды для работы с файлами и
                  архивами</a></dt>

                  <dt>12.6. <a
                   href="#COMMUNICATIONS">Команды для работы с
                  сетью</a></dt>

                  <dt>12.7. <a
                   href="#TERMINALCCMDS">Команды управления
                  терминалом</a></dt>

                  <dt>12.8. <a
                   href="#MATHC">Команды выполнения математических
                  операций</a></dt>

                  <dt>12.9. <a
                   href="#EXTMISC">Прочие команды</a></dt>
                </dl>
              </dd>

              <dt>13. <a
               href="#SYSTEM">Команды системного
              администрирования</a></dt>

              <dt>14. <a
               href="#COMMANDSUB">Подстановка команд</a></dt>

              <dt>15. <a
               href="#ARITHEXP">Арифметические подстановки</a></dt>

              <dt>16. <a
               href="#IO-REDIRECTION">Перенаправление
              ввода/вывода</a></dt>

              <dd>
                <dl>
                  <dt>16.1. <a
                   href="#AEN11702">С помощью команды <strong
                   class="COMMAND">exec</strong></a></dt>

                  <dt>16.2. <a
                   href="#REDIRCB">Перенаправление для блоков
                  кода</a></dt>

                  <dt>16.3. <a
                   href="#REDIRAPPS">Область применения</a></dt>
                </dl>
              </dd>

              <dt>17. <a
               href="#HERE-DOCS">Встроенные документы</a></dt>
            </dl>
          </div>
        </div>

        <div
         class="CHAPTER">
          <hr>

          <h1><a
           name="VARIABLES2"></a>Глава 9. К вопросу о переменных</h1>

          <p>Правильное использование переменных может придать
          сценариям дополнительную мощь и гибкость, а для этого
          необходимо изучить все тонкости и нюансы.</p>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="INTERNALVARIABLES"></a>9.1. Внутренние
            переменные</h2>

            <div
             class="VARIABLELIST">
              <dl>
                <dt><tt
                 class="REPLACEABLE"><em><a
                 href="#BUILTINREF">Встроенные</a>
                переменные</em></tt></dt>

                <dt><tt
                 class="VARNAME">$BASH</tt></dt>

                <dd>
                  <p>путь к исполняемому файлу <span
                   class="emphasis"><em
                   class="EMPHASIS">Bash</em></span></p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $BASH</strong></tt>
<tt
 class="COMPUTEROUTPUT">/bin/bash</tt>
</pre>
                  <br>
                  <br>
                </dd>

                <dt><tt
                 class="VARNAME">$BASH_VERSINFO[n]</tt></dt>

                <dd>
                  <p>это <a
                   href="#ARRAYREF">массив</a>, состоящий из 6
                  элементов, и содержащий информацию о версии Bash.
                  Очень похожа на переменную <tt
                   class="VARNAME">$BASH_VERSION</tt>, описываемую
                  ниже.</p>
<pre
 class="PROGRAMLISTING">
# Информация о версии Bash:

for n in 0 1 2 3 4 5
do
  echo &quot;BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}&quot;
done

# BASH_VERSINFO[0] = 2                      # Major version no.
# BASH_VERSINFO[1] = 05                     # Minor version no.
# BASH_VERSINFO[2] = 8                      # Patch level.
# BASH_VERSINFO[3] = 1                      # Build version.
# BASH_VERSINFO[4] = release                # Release status.
# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # Architecture
                                            # (same as $MACHTYPE).
</pre>
                  <br>
                  <br>
                </dd>

                <dt><tt
                 class="VARNAME">$BASH_VERSION</tt></dt>

                <dd>
                  <p>версия Bash, установленного в системе</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $BASH_VERSION</strong></tt>
<tt
 class="COMPUTEROUTPUT">2.04.12(1)-release</tt>
             
</pre>
                  <br>
                  <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">tcsh%</tt> <tt
 class="USERINPUT"><strong>echo $BASH_VERSION</strong></tt>
<tt
 class="COMPUTEROUTPUT">BASH_VERSION: Undefined variable.</tt>
             
</pre>
                  <br>
                  <br>

                  <p>Проверка переменной $BASH_VERSION -- неплохой
                  метод проверки типа командной оболочки, под которой
                  исполняется скрипт. Переменная <a
                   href="#SHELLVARREF">$SHELL</a> не всегда дает
                  правильный ответ.</p>
                </dd>

                <dt><a
                 name="DIRSTACKREF"></a><tt
                 class="VARNAME">$DIRSTACK</tt></dt>

                <dd>
                  <p>содержимое вершины стека каталогов (который
                  управляется командами <a
                   href="#PUSHDREF">pushd</a> и <a
                   href="#POPDREF">popd</a>)</p>

                  <p>Эта переменная соответствует команде <a
                   href="#DIRSD">dirs</a>, за исключением того, что
                  <strong
                   class="COMMAND">dirs</strong> показывает полное
                  содержимое всего стека каталогов.</p>
                </dd>

                <dt><tt
                 class="VARNAME">$EDITOR</tt></dt>

                <dd>
                  <p>заданный по-умолчанию редактор, вызываемый
                  скриптом, обычно <strong
                   class="COMMAND">vi</strong> или <strong
                   class="COMMAND">emacs</strong>.</p>
                </dd>

                <dt><a
                 name="EUIDREF"></a><tt
                 class="VARNAME">$EUID</tt></dt>

                <dd>
                  <p><span
                   class="QUOTE">&quot;эффективный&quot;</span>
                  идентификационный номер пользователя (Effective User
                  ID)</p>

                  <p>Идентификационный номер пользователя, права
                  которого были получены, возможно с помощью команды <a
                   href="#SUREF">su</a>.</p>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Значение переменной <tt
                           class="VARNAME">$EUID</tt> необязательно
                          должно совпадать с содержимым переменной <a
                           href="#UIDREF">$UID</a>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><tt
                 class="VARNAME">$FUNCNAME</tt></dt>

                <dd>
                  <p>имя текущей функции</p>
<pre
 class="PROGRAMLISTING">
xyz23 ()
{
  echo &quot;Исполняется функция $FUNCNAME.&quot;  # Исполняется функция xyz23.
}

xyz23

echo &quot;FUNCNAME = $FUNCNAME&quot;        # FUNCNAME =
                                   # Пустое (Null) значение за пределеми функций.
</pre>
                  <br>
                  <br>
                </dd>

                <dt><tt
                 class="VARNAME">$GLOBIGNORE</tt></dt>

                <dd>
                  <p>Перечень шаблонных символов, которые будут
                  проигнорированы при выполнении <a
                   href="#GLOBBINGREF">подстановки имен файлов
                  (globbing)</a> .</p>
                </dd>

                <dt><a
                 name="GROUPSREF"></a><tt
                 class="VARNAME">$GROUPS</tt></dt>

                <dd>
                  <p>группы, к которым принадлежит текущий
                  пользователь</p>

                  <p>Это список групп (массив) идентификационных
                  номеров групп для текущего пользователя, как эо
                  записано в <tt
                   class="FILENAME">/etc/passwd</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">root#</tt> <tt
 class="USERINPUT"><strong>echo $GROUPS</strong></tt>
<tt
 class="COMPUTEROUTPUT">0</tt>


<tt
 class="PROMPT">root#</tt> <tt
 class="USERINPUT"><strong>echo ${GROUPS[1]}</strong></tt>
<tt
 class="COMPUTEROUTPUT">1</tt>


<tt
 class="PROMPT">root#</tt> <tt
 class="USERINPUT"><strong>echo ${GROUPS[5]}</strong></tt>
<tt
 class="COMPUTEROUTPUT">6</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="HOMEDIRREF"></a><tt
                 class="VARNAME">$HOME</tt></dt>

                <dd>
                  <p>домашний каталог пользователя, как правило это <tt
                   class="FILENAME">/home/username</tt> (см. <a
                   href="#EX6">Пример 9-13</a>)</p>
                </dd>

                <dt><a
                 name="HOSTNAMEREF"></a><tt
                 class="VARNAME">$HOSTNAME</tt></dt>

                <dd>
                  <p>Сетевое имя хоста устанавливается командой <a
                   href="#HNAMEREF">hostname</a> во время исполнения
                  инициализирующих сценариев на загрузке системы.
                  Внутренняя переменная <tt
                   class="VARNAME">$HOSTNAME</tt> Bash получает свое
                  значение посредством вызова функции <tt
                   class="FUNCTION">gethostname()</tt>. См. так же <a
                   href="#EX6">Пример 9-13</a>.</p>
                </dd>

                <dt><tt
                 class="VARNAME">$HOSTTYPE</tt></dt>

                <dd>
                  <p>тип машины</p>

                  <p>Подобно <a
                   href="#MACHTYPEREF">$MACHTYPE</a>, идентифицирует
                  аппаратную архитектуру.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $HOSTTYPE</strong></tt>
<tt
 class="COMPUTEROUTPUT">i686</tt>
</pre>
                </dd>

                <dt><a
                 name="IFSREF"></a><tt
                 class="VARNAME">$IFS</tt></dt>

                <dd>
                  <p>разделитель полей во вводимой строке (IFS -- Input
                  Field Separator)</p>

                  <p>По-умолчанию -- <a
                   href="#WHITESPACEREF">пробельный символ</a> (пробел,
                  табуляция и перевод строки), но может быть изменен,
                  например, для разбора строк, в которых отдельные поля
                  разделены запятыми. Обратите внимание: при
                  составлении содержимого переменной <a
                   href="#APPREF">$*</a>, Bash использует первый символ
                  из <tt
                   class="VARNAME">$IFS</tt> для разделения аргументов.
                  См. <a
                   href="#WEIRDVARS">Пример 5-1</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $IFS | cat -vte</strong></tt>
<tt
 class="COMPUTEROUTPUT">$</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>bash -c &#39;set w x y z; IFS=&quot;:-;&quot;; echo &quot;$*&quot;&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">w:x:y:z</tt>
             
</pre>
                  <br>
                  <br>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>При всем при том следует помнить, что при
                          использовании <tt
                           class="VARNAME">$IFS</tt> пробельные символы
                          обрабатываются несколько иначе, чем все
                          остальные.</p>

                          <div
                           class="EXAMPLE">
                            <a
                             name="IFSH"></a>

                            <p><strong>Пример 9-1. $IFS и пробельные
                            символы</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# При использовании $IFS, пробельные символы обрабатываются иначе, чем все остальные.

output_args_one_per_line()
{
  for arg
  do echo &quot;[$arg]&quot;
  done
}

echo; echo &quot;IFS=\&quot; \&quot;&quot;
echo &quot;-------&quot;

IFS=&quot; &quot;
var=&quot; a  b c   &quot;
output_args_one_per_line $var  # output_args_one_per_line `echo &quot; a  b c   &quot;`
#
# [a]
# [b]
# [c]


echo; echo &quot;IFS=:&quot;
echo &quot;-----&quot;

IFS=:
var=&quot;:a::b:c:::&quot;               # То же самое, только пробелы зменены символом &quot;:&quot;.
output_args_one_per_line $var
#
# []
# [a]
# []
# [b]
# [c]
# []
# []
# []

# То же самое происходит и с разделителем полей &quot;FS&quot; в awk.

# Спасибо Stephane Chazelas.

echo

exit 0
</pre>
                          </div>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <p>(Спасибо S. C., за разъяснения и примеры.)</p>
                </dd>

                <dt><tt
                 class="VARNAME">$LC_COLLATE</tt></dt>

                <dd>
                  <p>Чаще всего устанавливается в <tt
                   class="FILENAME">.bashrc</tt> или <tt
                   class="FILENAME">/etc/profile</tt>, эта переменная
                  задает порядок сортировки символов, в операциях
                  подстановки имен файлов и в поиске по шаблону. При
                  неверной настройке переменной <tt
                   class="VARNAME">LC_COLLATE</tt> можно получить
                  весьма неожиданные результаты.</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Начиная с версии 2.05, Bash, в операциях
                          подстановки имен файлов, не делает различий
                          между символами верхнего и нижнего регистров,
                          в диапазонах символов в квадратных скобках.
                          Например,, <strong
                           class="COMMAND">ls [A-M]*</strong> выведет
                          как <tt
                           class="FILENAME">File1.txt</tt>, так и <tt
                           class="FILENAME">file1.txt</tt>. Возврат к
                          общепринятому стандарту поведения шаблонов в
                          квадратных скобках выполняется установкой
                          переменной <tt
                           class="VARNAME">LC_COLLATE</tt> в значение
                          <tt
                           class="OPTION">C</tt> командой <tt
                           class="USERINPUT"><strong>export
                          LC_COLLATE=C</strong></tt> в файле <tt
                           class="FILENAME">/etc/profile</tt> и/или <tt
                           class="FILENAME">~/.bashrc</tt>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><tt
                 class="VARNAME">$LC_CTYPE</tt></dt>

                <dd>
                  <p>Эта внутренняя переменная определяет кодировку
                  символов. Используется в операциях <a
                   href="#GLOBBINGREF">подстановки</a> и поиске по
                  шаблону.</p>
                </dd>

                <dt><tt
                 class="VARNAME">$LINENO</tt></dt>

                <dd>
                  <p>Номер строки исполняемого сценария. Эта переменная
                  имеет смысл только внутри исполняемого сценария и
                  чаще всего применяется в отладочных целях.</p>
<pre
 class="PROGRAMLISTING">
# *** BEGIN DEBUG BLOCK ***
last_cmd_arg=$_  # Запомнить.

echo &quot;Строка $LINENO: переменная \&quot;v1\&quot; = $v1&quot;
echo &quot;Последний аргумент командной строки = $last_cmd_arg&quot;
# *** END DEBUG BLOCK ***
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="MACHTYPEREF"></a><tt
                 class="VARNAME">$MACHTYPE</tt></dt>

                <dd>
                  <p>аппаратная архитектура</p>

                  <p>Идентификатор аппаратной архитектуры.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $MACHTYPE</strong></tt>
<tt
 class="COMPUTEROUTPUT">i686</tt>
</pre>
                </dd>

                <dt><a
                 name="OLDPWD"></a><tt
                 class="VARNAME">$OLDPWD</tt></dt>

                <dd>
                  <p>прежний рабочий каталог (<span
                   class=
                  "QUOTE">&quot;OLD-Print-Working-Directory&quot;</span>)</p>
                </dd>

                <dt><tt
                 class="VARNAME">$OSTYPE</tt></dt>

                <dd>
                  <p>тип операционной системы</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $OSTYPE</strong></tt>
<tt
 class="COMPUTEROUTPUT">linux</tt>
</pre>
                </dd>

                <dt><a
                 name="PATHREF"></a><tt
                 class="VARNAME">$PATH</tt></dt>

                <dd>
                  <p>путь поиска, как правило включает в себя каталоги
                  <tt
                   class="FILENAME">/usr/bin/</tt>, <tt
                   class="FILENAME">/usr/X11R6/bin/</tt>, <tt
                   class="FILENAME">/usr/local/bin</tt>, и т.д.</p>

                  <p>Когда командный интерпретатор получает команду, то
                  он автоматически пытается отыскать соответствующий
                  исполняемый файл в указанном списке каталогов (в
                  переменной $PATH). Каталоги, в указанном списке,
                  должны отделяться друг от друга двоеточиями. Обычно,
                  переменная <tt
                   class="VARNAME">$PATH</tt> инициализируется в <tt
                   class="FILENAME">/etc/profile</tt> и/или в <tt
                   class="FILENAME">~/.bashrc</tt> (см. <a
                   href="#FILES">Глава 26</a>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">echo $PATH</strong>
<tt
 class=
"COMPUTEROUTPUT">/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</tt>
</pre>
                  <br>
                  <br>

                  <p>Инструкция <tt
                   class=
                  "USERINPUT"><strong>PATH=${PATH}:/opt/bin</strong></tt>
                  добавляет каталог <tt
                   class="FILENAME">/opt/bin</tt> в конец текущего пути
                  поиска. Иногда может оказаться целесообразным, внутри
                  сценария, временно добавить какой-либо каталог к пути
                  поиска. По завершении работы скрипта, эти изменения
                  будут утеряны (вспомните о том, что невозможно
                  изменить переменные окружения вызывающего
                  процесса).</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Текущий <span
                           class="QUOTE">&quot;рабочий
                          каталог&quot;</span>, <tt
                           class="FILENAME">./</tt>, обычно не
                          включается в <tt
                           class="VARNAME">$PATH</tt> из соображений
                          безопасности.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><tt
                 class="VARNAME">$PIPESTATUS</tt></dt>

                <dd>
                  <p>Код возврата <a
                   href="#PIPEREF">канала (конвейера)</a>. Интересно,
                  что это не то же самое, что <a
                   href="#EXITSTATUSREF">код возврата</a> последней
                  исполненной команды.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $PIPESTATUS</strong></tt>
<tt
 class="COMPUTEROUTPUT">0</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -al | bogus_command</strong></tt>
<tt
 class="COMPUTEROUTPUT">bash: bogus_command: command not found</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $PIPESTATUS</strong></tt>
<tt
 class="COMPUTEROUTPUT">141</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -al | bogus_command</strong></tt>
<tt
 class="COMPUTEROUTPUT">bash: bogus_command: command not found</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $?</strong></tt>
<tt
 class="COMPUTEROUTPUT">127</tt>
             
</pre>
                  <br>
                  <br>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Переменная <tt
                           class="VARNAME">$PIPESTATUS</tt> может
                          давать неверные значения при вызове из
                          командной строки.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">tcsh%</tt> <tt
 class="USERINPUT"><strong>bash</strong></tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>who | grep nobody | sort</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ${PIPESTATUS[*]}</strong></tt>
<tt
 class="COMPUTEROUTPUT">0</tt>
             
</pre>
                          <br>
                          <br>

                          <p>Если поместить эти строки в сценарий и
                          исполнить его, то будут выведены верные
                          значения <tt
                           class="COMPUTEROUTPUT">0 1 0</tt>.</p>

                          <p>Спасибо Wayne Pollock за замечания и
                          предоставленный пример.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><a
                 name="PPIDREF"></a><tt
                 class="VARNAME">$PPID</tt></dt>

                <dd>
                  <p>Переменная <tt
                   class="VARNAME">$PPID</tt> хранит PID
                  (идентификатор) родительского процесса. <a
                   name="AEN3728"
                   href="#FTN.AEN3728"><span
                   class="footnote">[19]</span></a></p>

                  <p>Сравните с командой <a
                   href="#PIDOFREF">pidof</a>.</p>
                </dd>

                <dt><a
                 name="PS1REF"></a><tt
                 class="VARNAME">$PS1</tt></dt>

                <dd>
                  <p>prompt, приглашение командной строки.</p>
                </dd>

                <dt><tt
                 class="VARNAME">$PS2</tt></dt>

                <dd>
                  <p>Вторичное приглашение командной строки, выводится
                  тогда, когда от пользователя ожидается дополнительный
                  ввод. Отображается как <span
                   class="QUOTE">&quot;&gt;&quot;</span>.</p>
                </dd>

                <dt><tt
                 class="VARNAME">$PS3</tt></dt>

                <dd>
                  <p>Третичное приглашение (prompt), выводится тогда,
                  когда пользователь должен сделать выбор в операторе
                  <a
                   href="#SELECTREF">select</a> (см. <a
                   href="#EX31">Пример 10-29</a>).</p>
                </dd>

                <dt><tt
                 class="VARNAME">$PS4</tt></dt>

                <dd>
                  <p>Приглашение (prompt) четвертого уровня, выводится
                  в начале каждой строки вывода тогда, когда сценарий
                  вызывается с <a
                   href="#OPTIONSREF">ключом</a> <span
                   class="TOKEN">-x</span>. Отображается как <span
                   class="QUOTE">&quot;+&quot;</span>.</p>
                </dd>

                <dt><a
                 name="PWDREF"></a><tt
                 class="VARNAME">$PWD</tt></dt>

                <dd>
                  <p>рабочий (текущий) каталог</p>

                  <p>Аналог встроенной команды <a
                   href="#PWD2REF">pwd</a>.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

E_WRONG_DIRECTORY=73

clear # Очистка экрана.

TargetDirectory=/home/bozo/projects/GreatAmericanNovel

cd $TargetDirectory
echo &quot;Удаление файлов в каталоге $TargetDirectory.&quot;

if [ &quot;$PWD&quot; != &quot;$TargetDirectory&quot; ]
then    # Защита от случайного удаления файлов не в том каталоге.
  echo &quot;Неверный каталог!&quot;
  echo &quot;Переменная $PWD указывает на другой каталог!&quot;
  exit $E_WRONG_DIRECTORY
fi

rm -rf *
rm .[A-Za-z0-9]*    # удалить &quot;скрытые&quot; файлы (начинающиеся с &quot;.&quot;)
# rm -f .[^.]* ..?*   удалить файлы, чьи имена начинаются с нескольких точек.
# (shopt -s dotglob; rm -f *)   тоже работает верно.
# Спасибо S.C. за замечание.

# Имена файлов могут содержать любые символы из диапазона 0-255, за исключением &quot;/&quot;.
# Оставляю вопрос удаления файлов с &quot;необычными&quot; символами для самостоятельного изучения.

# Здесь можно вставить дополнительные действия, по мере необходимости.

echo
echo &quot;Конец.&quot;
echo &quot;Файлы, из каталога $TargetDirectory, удалены.&quot;
echo


exit 0
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="REPLYREF"></a><tt
                 class="VARNAME">$REPLY</tt></dt>

                <dd>
                  <p>переменная по-умолчанию, куда записывается ввод
                  пользователя, выполненный с помощью команды <a
                   href="#READREF">read</a> если явно не задана другая
                  переменная. Так же может использоваться в операторе
                  <a
                   href="#SELECTREF">select</a>, для построения меню
                  выбора.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo
echo -n &quot;Ваше любимое растение? &quot;
read

echo &quot;Ваше любимое растение: $REPLY.&quot;
# REPLY хранит последнее значение, прочитанное командой &quot;read&quot; тогда, и только тогда
#+ когда команде &quot;read&quot; не передается имя переменной.

echo
echo -n &quot;Ваш любимый фрукт? &quot;
read fruit
echo &quot;Ваш любимый фрукт $fruit.&quot;
echo &quot;но...&quot;
echo &quot;Значение переменной \$REPLY осталось равным $REPLY.&quot;
# Переменная $REPLY не была перезаписана потому, что
# следующей команде &quot;read&quot;, в качестве аргумента была передана переменная $fruit

echo

exit 0
</pre>
                  <br>
                  <br>
                </dd>

                <dt><tt
                 class="VARNAME">$SECONDS</tt></dt>

                <dd>
                  <p>Время паботы сценария в секундах.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Автор: Mendel Cooper
# Дополнен переводчиком.
#

TIME_LIMIT=10
INTERVAL=1

echo
echo &quot;Для прерывания работы сценария, ранее чем через $TIME_LIMIT секунд, нажмите Control-C.&quot;
echo

while [ &quot;$SECONDS&quot; -le &quot;$TIME_LIMIT&quot; ]
do
# Оригинальный вариант сценария содержал следующие строки
#  if [ &quot;$SECONDS&quot; -eq 1 ]
#  then
#    units=second
#  else
#    units=seconds
#  fi
#
# Однако, из-за того, что в русском языке для описания множественного числа
# существует большее число вариантов, чем в английском,
# переводчик позволил себе смелость несколько подправить сценарий
# (прошу ногами не бить! ;-) )
# === НАЧАЛО БЛОКА ИЗМЕНЕНИЙ, ВНЕСЕННЫХ ПЕРЕВОДЧИКОМ ===

  let &quot;last_two_sym = $SECONDS - $SECONDS / 100 * 100&quot; # десятки и единицы
  if [ &quot;$last_two_sym&quot; -ge 11 -a &quot;$last_two_sym&quot; -le 19 ]
  then
    units=&quot;секунд&quot;               # для чисел, которые заканчиваются на &quot;...надцать&quot;
  else
    let &quot;last_sym = $last_two_sym - $last_two_sym / 10 * 10&quot;  # единицы
    case &quot;$last_sym&quot; in
      &quot;1&quot; )
        units=&quot;секунду&quot;         # для чисел, заканчивающихся на 1
      ;;
      &quot;2&quot; | &quot;3&quot; | &quot;4&quot; )
        units=&quot;секунды&quot;         # для чисел, заканчивающихся на 2, 3 и 4
      ;;
      * )
        units=&quot;секунд&quot;          # для всех остальных (0, 5, 6, 7, 8, 9)
      ;;
    esac
  fi
# === КОНЕЦ БЛОКА ИЗМЕНЕНИЙ, ВНЕСЕННЫХ ПЕРЕВОДЧИКОМ ===

  echo &quot;Сценарий отработал $SECONDS $units.&quot;
  #  В случае перегруженности системы, скрипт может перескакивать через отдельные
  #+  значения счетчика
  sleep $INTERVAL
done

echo -e &quot;\a&quot;  # Сигнал!

exit 0
</pre>
                  <br>
                  <br>
                </dd>

                <dt><tt
                 class="VARNAME">$SHELLOPTS</tt></dt>

                <dd>
                  <p>список допустимых <a
                   href="#OPTIONSREF">опций</a> интерпретатора shell.
                  Переменная доступна только для чтения.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $SHELLOPTS</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><tt
                 class="VARNAME">$SHLVL</tt></dt>

                <dd>
                  <p>Уровень вложенности shell. Если в командной
                  строке</p>
<pre
 class="SCREEN">
echo $SHLVL
</pre>
                  дает 1, то в сценарии значение этой переменной будет
                  больше на 1, т.е. 2.<br>
                  <br>
                </dd>

                <dt><tt
                 class="VARNAME">$TMOUT</tt></dt>

                <dd>
                  <p>Если переменная окружения <tt
                   class="REPLACEABLE"><em>$TMOUT</em></tt> содержит
                  ненулевое значение, то интерпретатор будет ожидать
                  ввод не более чем заданное число секунд, что, в
                  первичном приглашении (см. описание PS1 выше), может
                  привести к автоматическому завершению сеанса
                  работы.</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>К сожалению это возможно только во время
                          ожидания ввода с консоли или в окне
                          терминала. А как было бы здорово, если бы
                          можно было использовать эту внутреннюю
                          переменную, скажем в комбинации с командой <a
                           href="#READREF">read</a>! Но в данном
                          контексте эта переменная абсолютно не
                          применима и потому фактически бесполезна в
                          сценариях. (Есть сведения о том, что в <span
                           class="emphasis"><em
                           class="EMPHASIS">ksh</em></span> время
                          ожидания ввода командой <strong
                           class="COMMAND">read</strong> можно
                          ограничить.)</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <p>Организация ограничения времени ожидания ввода от
                  пользователя в сценариях возможна, но это требут
                  довольно сложных махинаций. Как один из вариантов,
                  можно предложить организовать прерывание цикла
                  ожидания по сигналу. Но это потребует написание
                  функции обработки сигналов командой trap (см. <a
                   href="#EX76">Пример 29-5</a>).</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="TMDIN"></a>

                    <p><strong>Пример 9-2. Ограничения времени ожидания
                    ввода</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# timed-input.sh

# TMOUT=3            бесполезно в сценариях

TIMELIMIT=3  # Три секунды в данном случае, но может быть установлено и другое значение

PrintAnswer()
{
  if [ &quot;$answer&quot; = TIMEOUT ]
  then
    echo $answer
  else       # Чтобы не спутать разные варианты вывода.
    echo &quot;Ваше любимое растение $answer&quot;
    kill $!  # &quot;Прибить&quot; ненужную больше функцию TimerOn, запущенную в фоновом процессе.
             # $! -- PID последнего процесса, запущенного в фоне.
  fi

}



TimerOn()
{
  sleep $TIMELIMIT &amp;&amp; kill -s 14 $$ &amp;
  # Ждать 3 секунды, после чего выдать sigalarm сценарию.
}

Int14Vector()
{
  answer=&quot;TIMEOUT&quot;
  PrintAnswer
  exit 14
}

trap Int14Vector 14   # переназначить процедуру обработки прерывания от таймера (14)

echo &quot;Ваше любимое растение? &quot;
TimerOn
read answer
PrintAnswer


#  По общему признанию, это не очень хороший способ ограничения времени ожидания,
#+ однако опция &quot;-t&quot;команды &quot;read&quot; упрощает задачу.
#  См. &quot;t-out.sh&quot;, ниже.

#  Если вам нужно что-то более элегантное...
#+ подумайте о написании программы на C или C++,
#+ с использованием соответствующих библиотечных функций, таких как &#39;alarm&#39; и &#39;setitimer&#39;.

exit 0
</pre>
                  </div>

                  <p>В качестве альтернативы можно использовать <a
                   href="#STTYREF">stty</a>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="TIMEOUT"></a>

                    <p><strong>Пример 9-3. Еще один пример ограничения
                    времени ожидания ввода от пользователя</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# timeout.sh

# Автор: Stephane Chazelas,
# дополнен автором документа.

INTERVAL=5                # предел времени ожидания

timedout_read() {
  timeout=$1
  varname=$2
  old_tty_settings=`stty -g`
  stty -icanon min 0 time ${timeout}0
  eval read $varname      # или просто    read $varname
  stty &quot;$old_tty_settings&quot;
  # См. man stty.
}

echo; echo -n &quot;Как Вас зовут? Отвечайте быстрее! &quot;
timedout_read $INTERVAL your_name

# Такой прием может не работать на некоторых типах терминалов.
# Максимальное время ожидания зависит от терминала.
# (чаще всего это 25.5 секунд).

echo

if [ ! -z &quot;$your_name&quot; ]  # Если имя было введено...
then
  echo &quot;Вас зовут $your_name.&quot;
else
  echo &quot;Вы не успели ответить.&quot;
fi

echo

# Алгоритм работы этого сценария отличается от &quot;timed-input.sh&quot;.
# Каждое нажатие на клавишу вызывает сброс счетчика в начальное состояние.

exit 0
</pre>
                  </div>

                  <p>Возможно самый простой способ -- использовать
                  опцию <tt
                   class="OPTION">-t</tt> команды <a
                   href="#READREF">read</a>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="TOUT"></a>

                    <p><strong>Пример 9-4. Ограничение времени ожидания
                    команды read</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# t-out.sh 

TIMELIMIT=4        # 4 секунды

read -t $TIMELIMIT variable &lt;&amp;1

echo

if [ -z &quot;$variable&quot; ]
then
  echo &quot;Время ожидания истекло.&quot;
else
  echo &quot;variable = $variable&quot;
fi  

exit 0
</pre>
                  </div>
                </dd>

                <dt><a
                 name="UIDREF"></a><tt
                 class="VARNAME">$UID</tt></dt>

                <dd>
                  <p>user id number</p>

                  <p>UID (идентификатор) текущего пользователя, в
                  соответствии с <tt
                   class="FILENAME">/etc/passwd</tt></p>

                  <p>Это реальный UID текущего пользователя, даже если
                  он временно приобрел права другого пользователя с
                  помощью <a
                   href="#SUREF">su</a>. Переменная <tt
                   class="VARNAME">$UID</tt> доступна только для
                  чтения.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="AMIROOT"></a>

                    <p><strong>Пример 9-5. Я -- root?</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# am-i-root.sh:   Root я, или не root?

ROOT_UID=0   # $UID root-а всегда равен 0.

if [ &quot;$UID&quot; -eq &quot;$ROOT_UID&quot; ]  # Настоящий &quot;root&quot;?
then
  echo &quot;- root!&quot;
else
  echo &quot;простой пользователь (но мамочка вас тоже любит)!&quot;
fi

exit 0


# ============================================================= #
#  Код, приведенный ниже, никогда не отработает,
#+ поскольку работа сценария уже завершилась выше

# Еще один способ отличить root-а от не root-а:

ROOTUSER_NAME=root

username=`id -nu`              # Или...   username=`whoami`
if [ &quot;$username&quot; = &quot;$ROOTUSER_NAME&quot; ]
then
  echo &quot;Рутти-тутти. - root!&quot;
else
  echo &quot;Вы - лишь обычный юзер.&quot;
fi
</pre>
                  </div>

                  <p>См. также <a
                   href="#EX2">Пример 2-2</a>.</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Переменные <tt
                           class="VARNAME">$ENV</tt>, <tt
                           class="VARNAME">$LOGNAME</tt>, <tt
                           class="VARNAME">$MAIL</tt>, <tt
                           class="VARNAME">$TERM</tt>, <tt
                           class="VARNAME">$USER</tt> и <tt
                           class="VARNAME">$USERNAME</tt>, не являются
                          <a
                           href="#BUILTINREF">встроенными</a>
                          переменными Bash. Тем не менее, они часто
                          инициализируются как <a
                           href="#ENVREF">переменные окружения</a> в
                          одном из <a
                           href="#FILESREF1">стартовых файлов</a> Bash.
                          <a
                           name="SHELLVARREF"></a>Переменная <tt
                           class="VARNAME">$SHELL</tt>, командная
                          оболочка пользователя, может задаваться в <tt
                           class="FILENAME">/etc/passwd</tt> или в
                          сценарии <span
                           class="QUOTE">&quot;init&quot;</span> и она
                          тоже не является встроенной переменной
                          Bash.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">tcsh%</tt> <tt
 class="USERINPUT"><strong>echo $LOGNAME</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>
<tt
 class="PROMPT">tcsh%</tt> <tt
 class="USERINPUT"><strong>echo $SHELL</strong></tt>
<tt
 class="COMPUTEROUTPUT">/bin/tcsh</tt>
<tt
 class="PROMPT">tcsh%</tt> <tt
 class="USERINPUT"><strong>echo $TERM</strong></tt>
<tt
 class="COMPUTEROUTPUT">rxvt</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $LOGNAME</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $SHELL</strong></tt>
<tt
 class="COMPUTEROUTPUT">/bin/tcsh</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $TERM</strong></tt>
<tt
 class="COMPUTEROUTPUT">rxvt</tt>
             
</pre>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong>Позиционные параметры (аргументы)</strong></p>

              <dl>
                <dt><a
                 name="POSPARAMREF"></a><tt
                 class="VARNAME">$0</tt>, <tt
                 class="VARNAME">$1</tt>, <tt
                 class="VARNAME">$2</tt> и т.д.</dt>

                <dd>
                  <p>аргументы передаются... из командной строки в
                  сценарий, функциям или команде <a
                   href="#SETREF">set</a> (см. <a
                   href="#EX17">Пример 4-5</a> и <a
                   href="#EX34">Пример 11-13</a>)</p>
                </dd>

                <dt><tt
                 class="VARNAME">$#</tt></dt>

                <dd>
                  <p>количество аргументов командной строки <a
                   name="AEN4011"
                   href="#FTN.AEN4011"><span
                   class="footnote">[20]</span></a>, или позиционных
                  параметров (см. <a
                   href="#EX4">Пример 33-2</a>)</p>
                </dd>

                <dt><a
                 name="APPREF"></a><tt
                 class="VARNAME">$*</tt></dt>

                <dd>
                  <p>Все аргументы в виде одной строки (слова)</p>
                </dd>

                <dt><tt
                 class="VARNAME">$@</tt></dt>

                <dd>
                  <p>То же самое, что и <span
                   class="TOKEN">$*</span>, но при этом каждый параметр
                  представлен как отдельная строка (слово), т.е.
                  параметры не подвергаются какой либо
                  интерпретации.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="ARGLIST"></a>

                    <p><strong>Пример 9-6. arglist: Вывод списка
                    аргументов с помощью переменных $* и
                    $@</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вызовите сценарий с несколькими аргументами, например: &quot;один два три&quot;.

E_BADARGS=65

if [ ! -n &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` argument1 argument2 и т.д.&quot;
  exit $E_BADARGS
fi

echo

index=1

echo &quot;Список аргументов в переменной \&quot;\$*\&quot;:&quot;
for arg in &quot;$*&quot;  # Работает некорректно, если &quot;$*&quot; не ограничена кавычками.
do
  echo &quot;Аргумент #$index = $arg&quot;
  let &quot;index+=1&quot;
done             # $* воспринимает все аргументы как одну строку.
echo &quot;Полный список аргументов выглядит как одна строка.&quot;

echo

index=1

echo &quot;Список аргументов в переменной \&quot;\$@\&quot;:&quot;
for arg in &quot;$@&quot;
do
  echo &quot;Аргумент #$index = $arg&quot;
  let &quot;index+=1&quot;
done             # $@ воспринимает аргументы как отдельные строки (слова).
echo &quot;Список аргументов выглядит как набор различных строк (слов).&quot;

echo

exit 0
</pre>
                  </div>

                  <p>После команды <strong
                   class="COMMAND">shift</strong> (сдвиг), первый
                  аргумент, в переменной <tt
                   class="VARNAME">$@</tt>, теряется, а остальные
                  сдвигаются на одну позицию &quot;вниз&quot; (или
                  &quot;влево&quot;, если хотите).</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вызовите сценарий в таком виде: ./scriptname 1 2 3 4 5

echo &quot;$@&quot;    # 1 2 3 4 5
shift
echo &quot;$@&quot;    # 2 3 4 5
shift
echo &quot;$@&quot;    # 3 4 5

# Каждая из команд &quot;shift&quot; приводит к потере аргумента $1,
# но остальные аргументы остаются в &quot;$@&quot;.
</pre>
                  <br>
                  <br>

                  <p>Специальная переменная <tt
                   class="VARNAME">$@</tt> может быть использована для
                  выбора типа ввода в сценария. Команда <strong
                   class="COMMAND">cat &quot;$@&quot;</strong>
                  позволяет выполнять ввод как со стандартного
                  устройства ввода <tt
                   class="FILENAME">stdin</tt>, так и из файла, имя
                  которого передается сценарию из командной строки. См.
                  <a
                   href="#ROT13">Пример 12-17</a> и <a
                   href="#CRYPTOQUOTE">Пример 12-18</a>.</p>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Переменные <tt
                           class="VARNAME">$*</tt> и <tt
                           class="VARNAME">$@</tt>, в отдельных
                          случаях, могут содержать противоречивую
                          информацию! Это зависит от содержимого
                          переменной <a
                           href="#IFSREF">$IFS</a>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="INCOMPAT"></a>

                    <p><strong>Пример 9-7. Противоречия в переменных
                    <tt
                     class="VARNAME">$*</tt> и <tt
                     class="VARNAME">$@</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#  Демонстрация противоречивости содержимого внутренних переменных &quot;$*&quot; и &quot;$@&quot;,
#+ которая проявляется при изменении порядка заключения параметров в кавычки.
#  Демонстрация противоречивости, проявляющейся при изменении
#+ содержимого переменной IFS.


set -- &quot;Первый один&quot; &quot;второй&quot; &quot;третий:один&quot; &quot;&quot; &quot;Пятый: :один&quot;
# Установка аргументов $1, $2, и т.д.

echo

echo &#39;IFS по-умолчанию, переменная &quot;$*&quot;&#39;
c=0
for i in &quot;$*&quot;               # в кавычках
do echo &quot;$((c+=1)): [$i]&quot;   # Эта строка остается без изменений во всех циклах.
                            # Вывод аргументов.
done
echo ---

echo &#39;IFS по-умолчанию, переменная $*&#39;
c=0
for i in $*                 # без кавычек
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS по-умолчанию, переменная &quot;$@&quot;&#39;
c=0
for i in &quot;$@&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS по-умолчанию, переменная $@&#39;
c=0
for i in $@
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

IFS=:
echo &#39;IFS=&quot;:&quot;, переменная &quot;$*&quot;&#39;
c=0
for i in &quot;$*&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная $*&#39;
c=0
for i in $*
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

var=$*
echo &#39;IFS=&quot;:&quot;, переменная &quot;$var&quot; (var=$*)&#39;
c=0
for i in &quot;$var&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная $var (var=$*)&#39;
c=0
for i in $var
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

var=&quot;$*&quot;
echo &#39;IFS=&quot;:&quot;, переменная $var (var=&quot;$*&quot;)&#39;
c=0
for i in $var
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная &quot;$var&quot; (var=&quot;$*&quot;)&#39;
c=0
for i in &quot;$var&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная &quot;$@&quot;&#39;
c=0
for i in &quot;$@&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная $@&#39;
c=0
for i in $@
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

var=$@
echo &#39;IFS=&quot;:&quot;, переменная $var (var=$@)&#39;
c=0
for i in $var
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная &quot;$var&quot; (var=$@)&#39;
c=0
for i in &quot;$var&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

var=&quot;$@&quot;
echo &#39;IFS=&quot;:&quot;, переменная &quot;$var&quot; (var=&quot;$@&quot;)&#39;
c=0
for i in &quot;$var&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная $var (var=&quot;$@&quot;)&#39;
c=0
for i in $var
do echo &quot;$((c+=1)): [$i]&quot;
done

echo

# Попробуйте запустить этот сценарий под ksh или zsh -y.

exit 0

# Это сценарий написан Stephane Chazelas,
# Незначительные изменения внесены автором документа.
</pre>
                  </div>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Различия между <strong
                           class="COMMAND">$@</strong> и <strong
                           class="COMMAND">$*</strong> наблюдаются
                          только тогда, когда они помещаются в двойные
                          кавычки.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="IFSEMPTY"></a>

                    <p><strong>Пример 9-8. Содержимое <tt
                     class="VARNAME">$*</tt> и <tt
                     class="VARNAME">$@</tt>, когда переменная <tt
                     class="VARNAME">$IFS</tt> -- пуста</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Если переменная $IFS инициализирована &quot;пустым&quot; значением,
# то &quot;$*&quot; и &quot;$@&quot; содержат аргументы не в том виде, в каком ожидается.

mecho ()       # Вывод аргументов.
{
echo &quot;$1,$2,$3&quot;;
}


IFS=&quot;&quot;         # Инициализация &quot;пустым&quot; значением.
set a b c      # Установка аргументов.

mecho &quot;$*&quot;     # abc,,
mecho $*       # a,b,c

mecho $@       # a,b,c
mecho &quot;$@&quot;     # a,b,c

# Поведение переменных $* и $@, при &quot;пустой&quot; $IFS, зависит
# от версии командной оболочки, Bash или sh.
# Поэтому, было бы неразумным пользоваться этой &quot;фичей&quot; в своих сценариях.


# Спасибо S.C.

exit 0
</pre>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong>Прочие специальные переменные</strong></p>

              <dl>
                <dt><a
                 name="FLPREF"></a><tt
                 class="VARNAME">$-</tt></dt>

                <dd>
                  <p>Список флагов, переданных сценарию (командой <a
                   href="#SETREF">set</a>). См. <a
                   href="#EX34">Пример 11-13</a>.</p>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Эта конструкция изначально была введена в
                          <span
                           class="emphasis"><em
                           class="EMPHASIS">ksh</em></span>, откуда
                          перекочевала в Bash и, похоже, работает в
                          Bash не совсем надежно. Единственное
                          возможное применение -- <a
                           href="#IITEST">проверка - запущен ли
                          сценарий в интерактивном режиме</a>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><tt
                 class="VARNAME">$!</tt></dt>

                <dd>
                  <p>PID последнего, запущенного в фоне, процесса</p>
<pre
 class="PROGRAMLISTING">
LOG=$0.log

COMMAND1=&quot;sleep 100&quot;

echo &quot;Запись в лог всех PID фоновых процессов, запущенных из сценария: $0&quot; &gt;&gt; &quot;$LOG&quot;
# Таким образом возможен мониторинг и удаление процессов по мере необходимости.
echo &gt;&gt; &quot;$LOG&quot;

# Команды записи в лог.

echo -n &quot;PID of \&quot;$COMMAND1\&quot;:  &quot; &gt;&gt; &quot;$LOG&quot;
${COMMAND1} &amp;
echo $! &gt;&gt; &quot;$LOG&quot;
# PID процесса &quot;sleep 100&quot;:  1506

# Спасибо Jacques Lederer за предложенный пример.
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="UNDERSCOREREF"></a><tt
                 class="VARNAME">$_</tt></dt>

                <dd>
                  <p>Специальная переменная, содержит последний
                  аргумент предыдущей команды.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="USCREF"></a>

                    <p><strong>Пример 9-9. Переменная
                    &quot;подчеркивание&quot;</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo $_              # /bin/bash
                     # Для запуска сценария был вызван /bin/bash.

du &gt;/dev/null        # Подавление вывода.
echo $_              # du

ls -al &gt;/dev/null    # Подавление вывода.
echo $_              # -al  (последний аргумент)

:
echo $_              # :
</pre>
                  </div>
                </dd>

                <dt><a
                 name="XSTATVARREF"></a><tt
                 class="VARNAME">$?</tt></dt>

                <dd>
                  <p><a
                   href="#EXITSTATUSREF">Код возврата</a> команды, <a
                   href="#FUNCTIONREF">функции</a> или скрипта (см. <a
                   href="#MAX">Пример 22-3</a>)</p>
                </dd>

                <dt><a
                 name="PROCCID"></a><tt
                 class="VARNAME">$$</tt></dt>

                <dd>
                  <p>PID самого процесса-сценария. Переменная <tt
                   class="VARNAME">$$</tt> часто используется при
                  генерации &quot;уникальных&quot; имен для временных
                  файлов (см. <a
                   href="#FTPGET">Пример A-14</a>, <a
                   href="#ONLINE">Пример 29-6</a>, <a
                   href="#DERPM">Пример 12-23</a> и <a
                   href="#SELFDESTRUCT">Пример 11-23</a>). Обычно это
                  проще чем вызов <a
                   href="#MKTEMPREF">mktemp</a>.</p>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="STRING-MANIPULATION"></a>9.2. Работа со
            строками</h2>

            <p><a
             name="STRINGMANIP"></a></p>

            <p>Bash поддерживает на удивление большое количество
            операций над строками. К сожалению, этот раздел Bash
            испытывает недостаток унификации. Одни операции являются
            подмножеством операций <a
             href="#PARAMSUBREF">подстановки параметров</a>, а другие
            -- совпадают с функциональностью команды UNIX -- <a
             href="#EXPRREF">expr</a>. Это приводит к противоречиям в
            синтаксисе команд и перекрытию функциональных возможностей,
            не говоря уже о возникающей путанице.</p>

            <div
             class="VARIABLELIST">
              <p><strong>Длина строки</strong></p>

              <dl>
                <dt>${#string}</dt>

                <dt>expr length $string</dt>

                <dt>expr &quot;$string&quot; : &#39;.*&#39;</dt>

                <dd>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc

echo ${#stringZ}                 # 15
echo `expr length $stringZ`      # 15
echo `expr &quot;$stringZ&quot; : &#39;.*&#39;`    # 15
</pre>
                  <br>
                  <br>
                </dd>
              </dl>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="PARAGRAPHSPACE"></a>

              <p><strong>Пример 9-10. Вставка пустых строк между
              параграфами в текстовом файле</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# paragraph-space.sh

# Вставка пустых строк между параграфами в текстовом файле.
# Порядок использования: $0 &lt;FILENAME

MINLEN=45        # Возможно потребуется изменить это значение.
#  Строки, содержащие количество символов меньшее, чем $MINLEN
#+ принимаются за последнюю строку параграфа.

while read line  # Построчное чтение файла от начала до конца...
do
  echo &quot;$line&quot;   # Вывод строки.

  len=${#line}
  if [ &quot;$len&quot; -lt &quot;$MINLEN&quot; ]
    then echo    # Добавление пустой строки после последней строки параграфа.
  fi  
done

exit 0
</pre>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong>Длина подстроки в строке (подсчет совпадающих
              символов ведется с начала строки)</strong></p>

              <dl>
                <dt>expr match &quot;$string&quot;
                &#39;$substring&#39;</dt>

                <dd>
                  <p>где <tt
                   class="REPLACEABLE"><em>$substring</em></tt> -- <a
                   href="#REGEXREF">регулярное выражение</a>.</p>
                </dd>

                <dt>expr &quot;$string&quot; :
                &#39;$substring&#39;</dt>

                <dd>
                  <p>где <tt
                   class="REPLACEABLE"><em>$substring</em></tt> --
                  регулярное выражение.</p>

                  <p></p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#       |------|

echo `expr match &quot;$stringZ&quot; &#39;abc[A-Z]*.2&#39;`   # 8
echo `expr &quot;$stringZ&quot; : &#39;abc[A-Z]*.2&#39;`       # 8
</pre>
                  <br>
                  <br>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong>Index</strong></p>

              <dl>
                <dt>expr index $string $substring</dt>

                <dd>
                  <p>Номер позиции первого совпадения в $string c
                  первым символом в $substring.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
echo `expr index &quot;$stringZ&quot; C12`             # 6
                                             # позиция символа C.

echo `expr index &quot;$stringZ&quot; 1c`              # 3
# символ &#39;c&#39; (в #3 позиции) совпал раньше, чем &#39;1&#39;.
</pre>
                  <br>
                  <br>

                  <p>Эта функция довольно близка к функции <span
                   class="emphasis"><em
                   class="EMPHASIS">strchr()</em></span> в языке C.</p>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong>Извлечение подстроки</strong></p>

              <dl>
                <dt>${string:position}</dt>

                <dd>
                  <p>Извлекает подстроку из <tt
                   class="REPLACEABLE"><em>$string</em></tt>, начиная с
                  позиции <tt
                   class="REPLACEABLE"><em>$position</em></tt>.</p>

                  <p>Если строка <tt
                   class="VARNAME">$string</tt> -- <span
                   class="QUOTE">&quot;<span
                   class="TOKEN">*</span>&quot;</span> или <span
                   class="QUOTE">&quot;<span
                   class="TOKEN">@</span>&quot;</span>, то извлекается
                  <a
                   href="#POSPARAMREF">позиционный параметр</a>
                  (аргумент), <a
                   name="AEN4257"
                   href="#FTN.AEN4257"><span
                   class="footnote">[21]</span></a> с номером <tt
                   class="VARNAME">$position</tt>.</p>
                </dd>

                <dt>${string:position:length}</dt>

                <dd>
                  <p>Извлекает <tt
                   class="REPLACEABLE"><em>$length</em></tt> символов
                  из <tt
                   class="REPLACEABLE"><em>$string</em></tt>, начиная с
                  позиции <tt
                   class="REPLACEABLE"><em>$position</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#       0123456789.....
#       Индексация начинается с 0.

echo ${stringZ:0}                            # abcABC123ABCabc
echo ${stringZ:1}                            # bcABC123ABCabc
echo ${stringZ:7}                            # 23ABCabc

echo ${stringZ:7:3}                          # 23A
                                             # Извлекает 3 символа.



# Возможна ли индексация с &quot;правой&quot; стороны строки?

echo ${stringZ:-4}                           # abcABC123ABCabc
# По-умолчанию выводится полная строка.
# Однако . . .

echo ${stringZ:(-4)}                         # Cabc
echo ${stringZ: -4}                          # Cabc
# Теперь выводится правильно.
# Круглые скобки или дополнительный пробел &quot;экранируют&quot; параметр позиции.

# Спасибо Dan Jacobson, за разъяснения.
</pre>
                  <br>
                  <br>

                  <p>Если <tt
                   class="VARNAME">$string</tt> -- <span
                   class="QUOTE">&quot;<span
                   class="TOKEN">*</span>&quot;</span> или <span
                   class="QUOTE">&quot;<span
                   class="TOKEN">@</span>&quot;</span>, то извлекается
                  до <tt
                   class="VARNAME">$length</tt> позиционных параметров
                  (аргументов), начиная с <tt
                   class="VARNAME">$position</tt>.</p>
<pre
 class="PROGRAMLISTING">
echo ${*:2}          # Вывод 2-го и последующих аргументов.
echo ${@:2}          # То же самое.

echo ${*:2:3}        # Вывод 3-х аргументов, начиная со 2-го.
</pre>
                  <br>
                  <br>
                </dd>

                <dt>expr substr $string $position $length</dt>

                <dd>
                  <p>Извлекает <tt
                   class="REPLACEABLE"><em>$length</em></tt> символов
                  из <tt
                   class="REPLACEABLE"><em>$string</em></tt>, начиная с
                  позиции <tt
                   class="REPLACEABLE"><em>$position</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#       123456789......
#       Индексация начинается с 1.

echo `expr substr $stringZ 1 2`              # ab
echo `expr substr $stringZ 4 3`              # ABC
</pre>
                  <br>
                  <br>

                  <p><a
                   name="EXPRPAREN"></a></p>
                </dd>

                <dt>expr match &quot;$string&quot;
                &#39;\($substring\)&#39;</dt>

                <dd>
                  <p>Находит и извлекает первое совпадение <tt
                   class="REPLACEABLE"><em>$substring</em></tt> в <tt
                   class="REPLACEABLE"><em>$string</em></tt>, где <tt
                   class="REPLACEABLE"><em>$substring</em></tt> -- это
                  <a
                   href="#REGEXREF">регулярное выражение</a>.</p>
                </dd>

                <dt>expr &quot;$string&quot; :
                &#39;\($substring\)&#39;</dt>

                <dd>
                  <p>Находит и извлекает первое совпадение <tt
                   class="REPLACEABLE"><em>$substring</em></tt> в <tt
                   class="REPLACEABLE"><em>$string</em></tt>, где <tt
                   class="REPLACEABLE"><em>$substring</em></tt> -- это
                  регулярное выражение.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#       =======

echo `expr match &quot;$stringZ&quot; &#39;\(.[b-c]*[A-Z]..[0-9]\)&#39;`   # abcABC1
echo `expr &quot;$stringZ&quot; : &#39;\(.[b-c]*[A-Z]..[0-9]\)&#39;`       # abcABC1
echo `expr &quot;$stringZ&quot; : &#39;\(.......\)&#39;`                   # abcABC1
# Все вышеприведенные операции дают один и тот же результат.
</pre>
                  <br>
                  <br>
                </dd>

                <dt>expr match &quot;$string&quot;
                &#39;.*\($substring\)&#39;</dt>

                <dd>
                  <p>Находит и извлекает первое совпадение <tt
                   class="REPLACEABLE"><em>$substring</em></tt> в <tt
                   class="REPLACEABLE"><em>$string</em></tt>, где <tt
                   class="REPLACEABLE"><em>$substring</em></tt> -- это
                  регулярное выражение. Поиск начинается с конца <tt
                   class="REPLACEABLE"><em>$string</em></tt>.</p>
                </dd>

                <dt>expr &quot;$string&quot; :
                &#39;.*\($substring\)&#39;</dt>

                <dd>
                  <p>Находит и извлекает первое совпадение <tt
                   class="REPLACEABLE"><em>$substring</em></tt> в <tt
                   class="REPLACEABLE"><em>$string</em></tt>, где <tt
                   class="REPLACEABLE"><em>$substring</em></tt> -- это
                  регулярное выражение. Поиск начинается с конца <tt
                   class="REPLACEABLE"><em>$string</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#                ======

echo `expr match &quot;$stringZ&quot; &#39;.*\([A-C][A-C][A-C][a-c]*\)&#39;`    # ABCabc
echo `expr &quot;$stringZ&quot; : &#39;.*\(......\)&#39;`                       # ABCabc
</pre>
                  <br>
                  <br>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong>Удаление части строки</strong></p>

              <dl>
                <dt>${string#substring}</dt>

                <dd>
                  <p>Удаление самой короткой, из найденных, подстроки
                  <tt
                   class="REPLACEABLE"><em>$substring</em></tt> в
                  строке <tt
                   class="REPLACEABLE"><em>$string</em></tt>. Поиск
                  ведется с начала строки</p>
                </dd>

                <dt>${string##substring}</dt>

                <dd>
                  <p>Удаление самой длинной, из найденных, подстроки
                  <tt
                   class="REPLACEABLE"><em>$substring</em></tt> в
                  строке <tt
                   class="REPLACEABLE"><em>$string</em></tt>. Поиск
                  ведется с начала строки</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#       |----|
#       |----------|

echo ${stringZ#a*C}      # 123ABCabc
# Удаление самой короткой подстроки.

echo ${stringZ##a*C}     # abc
# Удаление самой длинной подстроки.
</pre>
                  <br>
                  <br>
                </dd>

                <dt>${string%substring}</dt>

                <dd>
                  <p>Удаление самой короткой, из найденных, подстроки
                  <tt
                   class="REPLACEABLE"><em>$substring</em></tt> в
                  строке <tt
                   class="REPLACEABLE"><em>$string</em></tt>. Поиск
                  ведется с конца строки</p>
                </dd>

                <dt>${string%%substring}</dt>

                <dd>
                  <p>Удаление самой длинной, из найденных, подстроки
                  <tt
                   class="REPLACEABLE"><em>$substring</em></tt> в
                  строке <tt
                   class="REPLACEABLE"><em>$string</em></tt>. Поиск
                  ведется с конца строки</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#                    ||
#        |------------|

echo ${stringZ%b*c}      # abcABC123ABCa
# Удаляется самое короткое совпадение. Поиск ведется с конца $stringZ.

echo ${stringZ%%b*c}     # a
# Удаляется самое длинное совпадение. Поиск ведется с конца $stringZ.
</pre>
                  <br>
                  <br>

                  <div
                   class="EXAMPLE">
                    <a
                     name="CVT"></a>

                    <p><strong>Пример 9-11. Преобразование графических
                    файлов из одного формата в другой, с изменением
                    имени файла</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
#  cvt.sh:
#  Преобразование всех файлов в заданном  каталоге,
#+ из графического формата MacPaint, в формат &quot;pbm&quot;.

#  Используется утилита &quot;macptopbm&quot;, входящая в состав пакета &quot;netpbm&quot;,
#+ который сопровождается Brian Henderson (bryanh@giraffe-data.com).
#  Netpbm -- стандартный пакет для большинства дистрибутивов Linux.

OPERATION=macptopbm
SUFFIX=pbm          # Новое расширение файла.

if [ -n &quot;$1&quot; ]
then
  directory=$1      # Если каталог задан в командной строке при вызове сценария
else
  directory=$PWD    # Иначе просматривается текущий каталог.
fi

#  Все файлы в каталоге, имеющие расширение &quot;.mac&quot;, считаются файлами
#+ формата  MacPaint.

for file in $directory/* # Подстановка имен файлов.
do
  filename=${file%.*c}   #  Удалить расширение &quot;.mac&quot; из имени файла
                         #+ ( с шаблоном &#39;.*c&#39; совпадают все подстроки
                         #+ начинающиеся с &#39;.&#39; и заканчивающиеся &#39;c&#39;,
  $OPERATION $file &gt; &quot;$filename.$SUFFIX&quot;
                         # Преобразование с перенаправлением в файл с новым именем
  rm -f $file            # Удаление оригинального файла после преобразования.
  echo &quot;$filename.$SUFFIX&quot;  # Вывод на stdout.
done

exit 0

# Упражнение:
# --------
#  Сейчас этот сценарий конвертирует *все* файлы в каталоге
#  Измените его так, чтобы он конвертировал *только* те файлы,
#+ которые имеют расширение &quot;.mac&quot;.
</pre>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong>Замена подстроки</strong></p>

              <dl>
                <dt>${string/substring/replacement}</dt>

                <dd>
                  <p>Замещает первое вхождение <tt
                   class="REPLACEABLE"><em>$substring</em></tt> строкой
                  <tt
                   class="REPLACEABLE"><em>$replacement</em></tt>.</p>
                </dd>

                <dt>${string//substring/replacement}</dt>

                <dd>
                  <p>Замещает все вхождения <tt
                   class="REPLACEABLE"><em>$substring</em></tt> строкой
                  <tt
                   class="REPLACEABLE"><em>$replacement</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc

echo ${stringZ/abc/xyz}           # xyzABC123ABCabc
                                  # Замена первой подстроки &#39;abc&#39; строкой &#39;xyz&#39;.

echo ${stringZ//abc/xyz}          # xyzABC123ABCxyz
                                  # Замена всех подстрок &#39;abc&#39; строкой &#39;xyz&#39;.
</pre>
                  <br>
                  <br>
                </dd>

                <dt>${string/#substring/replacement}</dt>

                <dd>
                  <p>Подстановка строки <tt
                   class="REPLACEABLE"><em>$replacement</em></tt>
                  вместо <tt
                   class="REPLACEABLE"><em>$substring</em></tt>. Поиск
                  ведется с начала строки <tt
                   class="REPLACEABLE"><em>$string</em></tt>.</p>
                </dd>

                <dt>${string/%substring/replacement}</dt>

                <dd>
                  <p>Подстановка строки <tt
                   class="REPLACEABLE"><em>$replacement</em></tt>
                  вместо <tt
                   class="REPLACEABLE"><em>$substring</em></tt>. Поиск
                  ведется с конца строки <tt
                   class="REPLACEABLE"><em>$string</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc

echo ${stringZ/#abc/XYZ}          # XYZABC123ABCabc
                                  # Поиск ведется с начала строки

echo ${stringZ/%abc/XYZ}          # abcABC123ABCXYZ
                                  # Поиск ведется с конца строки
</pre>
                  <br>
                  <br>
                </dd>
              </dl>
            </div>

            <div
             class="SECT2">
              <hr>

              <h3
               class="SECT2"><a
               name="AWKSTRINGMANIP"></a>9.2.1. Использование awk при
              работе со строками</h3>

              <p>В качестве альтернативы, Bash-скрипты могут
              использовать средства <a
               href="#AWKREF">awk</a> при работе со строками.</p>

              <div
               class="EXAMPLE">
                <a
                 name="SUBSTRINGEX"></a>

                <p><strong>Пример 9-12. Альтернативный способ
                извлечения подстрок</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# substring-extraction.sh

String=23skidoo1
#      012345678    Bash
#      123456789    awk
# Обратите внимание на различия в индексации:
# Bash начинает индексацию с &#39;0&#39;.
# Awk  начинает индексацию с &#39;1&#39;.

echo ${String:2:4} # с 3 позиции (0-1-2), 4 символа
                   # skid

# В эквивалент в awk: substr(string,pos,length).
echo | awk &#39;
{ print substr(&quot;&#39;&quot;${String}&quot;&#39;&quot;,3,4)      # skid
}
&#39;
#  Передача пустого &quot;echo&quot; по каналу в awk, означает фиктивный ввод,
#+ делая, тем самым, ненужным предоставление имени файла.

exit 0
</pre>
              </div>
            </div>

            <div
             class="SECT2">
              <hr>

              <h3
               class="SECT2"><a
               name="STRFDISC"></a>9.2.2. Дальнейшее обсуждение</h3>

              <p>Дополнительную информацию, по работе со строками, вы
              найдете в разделе <a
               href="#PARAMETER-SUBSTITUTION">Section 9.3</a> и в <a
               href="#EXPEXTRSUB">секции</a>, посвященной команде <a
               href="#EXPRREF">expr</a>. Примеры сценариев:</p>

              <ol
               type="1">
                <li>
                  <p><a
                   href="#EX45">Пример 12-6</a></p>
                </li>

                <li>
                  <p><a
                   href="#LENGTH">Пример 9-15</a></p>
                </li>

                <li>
                  <p><a
                   href="#PATTMATCHING">Пример 9-16</a></p>
                </li>

                <li>
                  <p><a
                   href="#RFE">Пример 9-17</a></p>
                </li>

                <li>
                  <p><a
                   href="#VARMATCH">Пример 9-19</a></p>
                </li>
              </ol>
              <br>
              <br>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="PARAMETER-SUBSTITUTION"></a>9.3. Подстановка
            параметров</h2>

            <p><a
             name="PARAMSUBREF"></a></p>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="PSSUB1"></a>Работа с переменными и/или подстановка
              их значений</strong></p>

              <dl>
                <dt><tt
                 class=
                "USERINPUT"><strong>${parameter}</strong></tt></dt>

                <dd>
                  <p>То же самое, что и <tt
                   class="REPLACEABLE"><em>$parameter</em></tt>, т.е.
                  значение переменной <tt
                   class="REPLACEABLE"><em>parameter</em></tt>. В
                  отдельных случаях, при возникновении неоднозначности
                  интерпретации, корректно будет работать только такая
                  форма записи: <tt
                   class="REPLACEABLE"><em>${parameter}</em></tt>.</p>

                  <p>Может использоваться для конкатенации (слияния)
                  строковых переменных.</p>
<pre
 class="PROGRAMLISTING">
your_id=${USER}-on-${HOSTNAME}
echo &quot;$your_id&quot;
#
echo &quot;Старый \$PATH = $PATH&quot;
PATH=${PATH}:/opt/bin  #Добавление /opt/bin в $PATH.
echo &quot;Новый \$PATH = $PATH&quot;
</pre>
                  <br>
                  <br>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${parameter-default}</strong></tt>,
                <tt
                 class=
                "USERINPUT"><strong>${parameter:-default}</strong></tt></dt>

                <dd>
                  <p>Если параметр отсутствует, то используется
                  значение по-умолчанию.</p>
<pre
 class="PROGRAMLISTING">
echo ${username-`whoami`}
# Вывод результата работы команды `whoami`, если переменная $username не установлена.
</pre>
                  <br>
                  <br>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Формы записи <tt
                           class=
                          "REPLACEABLE"><em>${parameter-default}</em></tt>
                          и <tt
                           class=
                          "REPLACEABLE"><em>${parameter:-default}</em></tt>
                          в большинстве случаев можно считать
                          эквивалентными. Дополнительный символ <span
                           class="TOKEN">:</span> имеет значение только
                          тогда, когда <span
                           class="emphasis"><em
                           class="EMPHASIS">parameter</em></span>
                          определен, но имеет &quot;пустое&quot; (null)
                          значение.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

username0=
# переменная username0 объявлена, но инициализирована &quot;пустым&quot; значением.
echo &quot;username0 = ${username0-`whoami`}&quot;
# Вывод после символа &quot;=&quot; отсутствует.

echo &quot;username1 = ${username1-`whoami`}&quot;
# Переменная username1 не была объявлена.
# Выводится имя пользователя, выданное командой `whoami`.

username2=
# переменная username2 объявлена, но инициализирована &quot;пустым&quot; значением.
echo &quot;username2 = ${username2:-`whoami`}&quot;
# Выводится имя пользователя, выданное командой `whoami`, поскольку
#+здесь употребляется конструкция &quot;:-&quot; , а не  &quot;-&quot;.

exit 0
</pre>
                  <br>
                  <br>

                  <p><span
                   class="emphasis"><em
                   class="EMPHASIS">Параметры по-умолчанию</em></span>
                  очень часто находят применение в случаях, когда
                  сценарию необходимы какие либо входные аргументы,
                  передаваемые из командной строки, но такие аргументы
                  не были переданы.</p>
<pre
 class="PROGRAMLISTING">
DEFAULT_FILENAME=generic.data
filename=${1:-$DEFAULT_FILENAME}
#  Если имя файла не задано явно, то последующие операторы будут работать
#+ с файлом &quot;generic.data&quot;.
#
</pre>
                  <br>
                  <br>

                  <p>см. так же <a
                   href="#EX58">Пример 3-4</a>, <a
                   href="#EX73">Пример 28-2</a> и <a
                   href="#COLLATZ">Пример A-7</a>.</p>

                  <p>Сравните этот подход с <a
                   href="#ANDDEFAULT">методом списков <span
                   class="emphasis"><em
                   class="EMPHASIS">and list</em></span>, для задания
                  параметров командной строки по-умолчанию</a> .</p>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${parameter=default}</strong></tt>,
                <tt
                 class=
                "USERINPUT"><strong>${parameter:=default}</strong></tt></dt>

                <dd>
                  <p><a
                   name="DEFPARAM"></a></p>

                  <p>Если значения параметров не задананы явно, то они
                  принимают значения по-умолчанию.</p>

                  <p>Оба метода задания значений по-умолчанию до
                  определенной степени идентичны. Символ <span
                   class="TOKEN">:</span> имеет значение только когда
                  <span
                   class="emphasis"><em
                   class="EMPHASIS">$parameter</em></span> был
                  инициализирован &quot;пустым&quot; (null) значением,
                  <a
                   name="AEN4520"
                   href="#FTN.AEN4520"><span
                   class="footnote">[22]</span></a> как показано
                  выше.</p>
<pre
 class="PROGRAMLISTING">
echo ${username=`whoami`}
# Переменная &quot;username&quot; принимает значение, возвращаемое командой `whoami`.
</pre>
                  <br>
                  <br>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${parameter+alt_value}</strong></tt>,
                <tt
                 class=
                "USERINPUT"><strong>${parameter:+alt_value}</strong></tt></dt>

                <dd>
                  <p>Если параметр имеет какое либо значение, то
                  используется <tt
                   class="USERINPUT"><strong>alt_value</strong></tt>,
                  иначе -- null (&quot;пустая&quot; строка).</p>

                  <p>Оба варианта до определенной степени идентичны.
                  Символ <span
                   class="TOKEN">:</span> имеет значение только если
                  <span
                   class="emphasis"><em
                   class="EMPHASIS">parameter</em></span> объявлен и
                  &quot;пустой&quot;, см. ниже.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;###### \${parameter+alt_value} ########&quot;
echo

a=${param1+xyz}
echo &quot;a = $a&quot;      # a =

param2=
a=${param2+xyz}
echo &quot;a = $a&quot;      # a = xyz

param3=123
a=${param3+xyz}
echo &quot;a = $a&quot;      # a = xyz

echo
echo &quot;###### \${parameter:+alt_value} ########&quot;
echo

a=${param4:+xyz}
echo &quot;a = $a&quot;      # a =

param5=
a=${param5:+xyz}
echo &quot;a = $a&quot;      # a =
# Вывод отличается от a=${param5+xyz}

param6=123
a=${param6+xyz}
echo &quot;a = $a&quot;      # a = xyz
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="QERRMSG"></a><tt
                 class=
                "USERINPUT"><strong>${parameter?err_msg}</strong></tt>,
                <tt
                 class=
                "USERINPUT"><strong>${parameter:?err_msg}</strong></tt></dt>

                <dd>
                  <p>Если parameter инициализирован, то используется
                  его значение, в противном случае -- выводится
                  err_msg.</p>

                  <p>Обе формы записи можно, до определенной степени,
                  считать идентичными. Символ <span
                   class="TOKEN">:</span> имеет значение только когда
                  <span
                   class="emphasis"><em
                   class="EMPHASIS">parameter</em></span>
                  инициализирован &quot;пустым&quot; значением, см.
                  ниже.</p>
                </dd>
              </dl>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="EX6"></a>

              <p><strong>Пример 9-13. Подстановка параметров и
              сообщения об ошибках</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#  Проверка отдельных переменных окружения.
#  Если переменная, к примеру $USER, не установлена,
#+ то выводится сообщение об ошибке.

: ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}
  echo
  echo &quot;Имя машины: $HOSTNAME.&quot;
  echo &quot;Ваше имя: $USER.&quot;
  echo &quot;Ваш домашний каталог: $HOME.&quot;
  echo &quot;Ваш почтовый ящик: $MAIL.&quot;
  echo
  echo &quot;Если перед Вами появилось это сообщение,&quot;
  echo &quot;то это значит, что все критические переменные окружения установлены.&quot;
  echo
  echo

# ------------------------------------------------------

#  Конструкция ${variablename?} так же выполняет проверку
#+ наличия переменной в сценарии.

ThisVariable=Value-of-ThisVariable
#  Обратите внимание, в строковые переменные могут быть записаны
#+ символы, которые запрещено использовать в именах переменных.
: ${ThisVariable?}
echo &quot;Value of ThisVariable is $ThisVariable&quot;.
echo
echo


: ${ZZXy23AB?&quot;Переменная ZZXy23AB не инициализирована.&quot;}
#  Если ZZXy23AB не инициализирована,
#+ то сценарий завершается с сообщением об ошибке.

# Текст сообщения об ошибке можно задать свой.
# : ${ZZXy23AB?&quot;Переменная ZZXy23AB не инициализирована.&quot;}


# То же самое:  dummy_variable=${ZZXy23AB?}
#               dummy_variable=${ZZXy23AB?&quot;Переменная ZXy23AB не инициализирована.&quot;}
#
#               echo ${ZZXy23AB?} &gt;/dev/null



echo &quot;Это сообщение не будет напечатано, поскольку сценарий завершится раньше.&quot;

HERE=0
exit $HERE   # Сценарий завершит работу не здесь.
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="USAGEMESSAGE"></a>

              <p><strong>Пример 9-14. Подстановка параметров и
              сообщение о <span
               class="QUOTE">&quot;порядке
              использования&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# usage-message.sh

: ${1?&quot;Порядок использования: $0 ARGUMENT&quot;}
#  Сценарий завершит свою работу здесь, если входные аргументы отсутствуют,
#+ со следующим сообщением.
#    usage-message.sh: 1: Порядок использования: usage-message.sh ARGUMENT

echo &quot;Эти две строки появятся, только когда задан аргумент в командной строке.&quot;
echo &quot;Входной аргумент командной строки = \&quot;$1\&quot;&quot;

exit 0 # Точка выхода находится здесь, только когда задан аргумент командной строки.

# Проверьте код возврата в обеих случаях, с и без аргумента командной строки.
# Если аргумент задан, то код возврата будет равен 0.
# Иначе -- 1.
</pre>
            </div>

            <div
             class="FORMALPARA">
              <p><strong>Подстановка параметров и/или
              экспансия.</strong> <a
               name="PSUB2"></a>Следующие выражения могут служить
              дополнениями оператора <strong
               class="COMMAND">match</strong> команды <strong
               class="COMMAND">expr</strong>, применяемой к строкам
              (см. <a
               href="#EX45">Пример 12-6</a>). Как правило, они
              используются при разборе имен файлов и каталогов.</p>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="PSOREX1"></a>Длина переменной / Удаление
              подстроки</strong></p>

              <dl>
                <dt><tt
                 class="USERINPUT"><strong>${#var}</strong></tt></dt>

                <dd>
                  <p><tt
                   class="USERINPUT"><strong>String
                  length</strong></tt> (число символов в переменной <tt
                   class="VARNAME">$var</tt>). В случае <a
                   href="#ARRAYREF">массивов</a>, команда <strong
                   class="COMMAND">${#array}</strong> возвращает длину
                  первого элемента массива.</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Исключения:</p>

                          <ul>
                            <li>
                              <p><strong
                               class="COMMAND">${#*}</strong> и <strong
                               class="COMMAND">${#@}</strong>
                              возвращает <span
                               class="emphasis"><em
                               class="EMPHASIS">количество аргументов
                              (позиционных параметров)</em></span>.</p>
                            </li>

                            <li>
                              <p>Для массивов, <strong
                               class="COMMAND">${#array[*]}</strong> и
                              <strong
                               class="COMMAND">${#array[@]}</strong>
                              возвращает количество элементов в
                              массиве.</p>
                            </li>
                          </ul>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="LENGTH"></a>

                    <p><strong>Пример 9-15. Длина
                    переменной</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# length.sh

E_NO_ARGS=65

if [ $# -eq 0 ]  # Для работы скрипта необходим хотя бы один входной параметр.
then
  echo &quot;Вызовите сценарий с одним или более параметром командной строки.&quot;
  exit $E_NO_ARGS
fi

var01=abcdEFGH28ij

echo &quot;var01 = ${var01}&quot;
echo &quot;Length of var01 = ${#var01}&quot;

echo &quot;Количество входных параметров = ${#@}&quot;
echo &quot;Количество входных параметров = ${#*}&quot;

exit 0
</pre>
                  </div>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${var#Pattern}</strong></tt>, <tt
                 class=
                "USERINPUT"><strong>${var##Pattern}</strong></tt></dt>

                <dd>
                  <p>Удаляет из переменной <tt
                   class="VARNAME">$var</tt> наименьшую/наибольшую
                  подстроку, совпадающую с шаблоном <tt
                   class="VARNAME">$Pattern</tt>. Поиск ведется с
                  начала строки <tt
                   class="VARNAME">$var</tt>.</p>

                  <p>Пример использования из <a
                   href="#DAYSBETWEEN">Пример A-8</a>:</p>
<pre
 class="PROGRAMLISTING">
# Функцмя из сценария &quot;days-between.sh&quot;.
# Удаляет нули, стоящие в начале аргумента-строки.

strip_leading_zero () # Ведущие нули, которые согут находиться в номере дня/месяца,
                      # лучше удалить
  val=${1#0}          # В противном случае Bash будет интерпретировать числа
  return $val         # как восьмеричные (POSIX.2, sect 2.9.2.1).
}
</pre>
                  <br>
                  <br>

                  <p>Другой пример:</p>
<pre
 class="PROGRAMLISTING">
echo `basename $PWD`        # Имя текущего рабочего каталога.
echo &quot;${PWD##*/}&quot;           # Имя текущего рабочего каталога.
echo
echo `basename $0`          # Имя файла-сценария.
echo $0                     # Имя файла-сценария.
echo &quot;${0##*/}&quot;             # Имя файла-сценария.
echo
filename=test.data
echo &quot;${filename##*.}&quot;      # data
                            # Расширение файла.
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="PCTPATREF"></a><tt
                 class=
                "USERINPUT"><strong>${var%Pattern}</strong></tt>, <tt
                 class=
                "USERINPUT"><strong>${var%%Pattern}</strong></tt></dt>

                <dd>
                  <p>Удаляет из переменной <tt
                   class="VARNAME">$var</tt> наименьшую/наибольшую
                  подстроку, совпадающую с шаблоном <tt
                   class="VARNAME">$Pattern</tt>. Поиск ведется с конца
                  строки <tt
                   class="VARNAME">$var</tt>.</p>
                </dd>
              </dl>
            </div>

            <p>Bash <a
             href="#BASH2REF">версии 2</a> имеет ряд дополнительных
            возможностей.</p>

            <div
             class="EXAMPLE">
              <a
               name="PATTMATCHING"></a>

              <p><strong>Пример 9-16. Поиск по шаблону в подстановке
              параметров</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Поиск по шаблону в операциях подстановки параметров # ## % %%.

var1=abcd12345abc6789
pattern1=a*c  # * (символ шаблона), означает любые символы между a и c.

echo
echo &quot;var1 = $var1&quot;           # abcd12345abc6789
echo &quot;var1 = ${var1}&quot;         # abcd12345abc6789   (альтернативный вариант)
echo &quot;Число символов в ${var1} = ${#var1}&quot;
echo &quot;pattern1 = $pattern1&quot;   # a*c  (между &#39;a&#39; и &#39;c&#39; могут быть любые символы)
echo


echo &#39;${var1#$pattern1}  =&#39; &quot;${var1#$pattern1}&quot;    #         d12345abc6789
# Наименьшая подстрока, удаляются первые 3 символа  abcd12345abc6789
                                  ^^^^^^            |-|
echo &#39;${var1##$pattern1} =&#39; &quot;${var1##$pattern1}&quot;   #                  6789
# Наибольшая подстрока, удаляются первые 12 символов abcd12345abc6789
#                                 ^^^^^^             |----------|

echo; echo

pattern2=b*9            # все, что между &#39;b&#39; и &#39;9&#39;
echo &quot;var1 = $var1&quot;     # abcd12345abc6789
echo &quot;pattern2 = $pattern2&quot;
echo

echo &#39;${var1%pattern2}  =&#39; &quot;${var1%$pattern2}&quot;     #     abcd12345a
# Наименьшая подстрока, удаляются последние 6 символов  abcd12345abc6789
#                                 ^^^^^^^^^                       |----|
echo &#39;${var1%%pattern2} =&#39; &quot;${var1%%$pattern2}&quot;    #     a
# Наибольшая подстрока, удаляются последние 12 символов  abcd12345abc6789
#                                 ^^^^^^^^^               |-------------|

# Запомните, # и ## используются для поиска с начала строки,
#            % и %% используются для поиска с конца строки.

echo

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="RFE"></a>

              <p><strong>Пример 9-17. Изменение расширений в именах
              файлов<span
               class="TOKEN">:</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#                 rfe
#                 ---

# Изменение расширений в именах файлов.
#
#         rfe old_extension new_extension
#
# Пример:
# Изменить все расширения *.gif в именах файлов на *.jpg, в текущем каталоге
#          rfe gif jpg

ARGS=2
E_BADARGS=65

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` old_file_suffix new_file_suffix&quot;
  exit $E_BADARGS
fi

for filename in *.$1
# Цикл прохода по списку имен файлов, имеющих расширение равное первому аргументу.
do
  mv $filename ${filename%$1}$2
  #  Удалить первое расширение и добавить второе,
done

exit 0
</pre>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="EXPREPL1"></a>Подстановка значений переменных /
              Замена подстроки</strong></p>

              <dl>
                <dd>
                  <p>Эти конструкции перекочевали в Bash из <span
                   class="emphasis"><em
                   class="EMPHASIS">ksh</em></span>.</p>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${var:pos}</strong></tt></dt>

                <dd>
                  <p>Подстанавливается значение переменной <tt
                   class="REPLACEABLE"><em>var</em></tt>, начиная с
                  позиции <tt
                   class="REPLACEABLE"><em>pos</em></tt>.</p>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${var:pos:len}</strong></tt></dt>

                <dd>
                  <p>Подстанавливается значение переменной <tt
                   class="REPLACEABLE"><em>var</em></tt>, начиная с
                  позиции <tt
                   class="REPLACEABLE"><em>pos</em></tt>, не более <tt
                   class="REPLACEABLE"><em>len</em></tt> символов. См.
                  <a
                   href="#PW">Пример A-16</a>.</p>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${var/Pattern/Replacement}</strong></tt></dt>

                <dd>
                  <p>Первое совпадение с шаблоном <tt
                   class="REPLACEABLE"><em>Pattern</em></tt>, в
                  переменной <tt
                   class="REPLACEABLE"><em>var</em></tt> замещается
                  подстрокой <tt
                   class="REPLACEABLE"><em>Replacement</em></tt>.</p>

                  <p>Если подстрока <tt
                   class="REPLACEABLE"><em>Replacement</em></tt>
                  отсутствует, то найденное совпадение будет
                  удалено.</p>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${var//Pattern/Replacement}</strong></tt></dt>

                <dd>
                  <div
                   class="FORMALPARA">
                    <p><strong>Глобальная замена.</strong> Все
                    найденные совпадения с шаблоном <tt
                     class="REPLACEABLE"><em>Pattern</em></tt>, в
                    переменной <tt
                     class="REPLACEABLE"><em>var</em></tt>, будут
                    замещены подстрокой <tt
                     class="REPLACEABLE"><em>Replacement</em></tt>.</p>
                  </div>

                  <p>Как и в первом случае, если подстрока <tt
                   class="REPLACEABLE"><em>Replacement</em></tt>
                  отсутствует, то все найденные совпадения будут
                  удалены.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX7"></a>

                    <p><strong>Пример 9-18. Поиск по шаблону при
                    анализе произвольных строк</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

var1=abcd-1234-defg
echo &quot;var1 = $var1&quot;

t=${var1#*-*}
echo &quot;var1 (все, от начала строки по первый символ \&quot;-\&quot;, включительно, удаляется) = $t&quot;
#  t=${var1#*-}  то же самое,
#+ поскольку оператор # ищет кратчайшее совпадение,
#+ а * соответствует любым предшествующим символам, включая пустую строку.
# (Спасибо S. C. за разъяснения.)

t=${var1##*-*}
echo &quot;Если var1 содержит \&quot;-\&quot;, то возвращается пустая строка...   var1 = $t&quot;


t=${var1%*-*}
echo &quot;var1 (все, начиная с последнего \&quot;-\&quot; удаляется) = $t&quot;

echo

# -------------------------------------------
path_name=/home/bozo/ideas/thoughts.for.today
# -------------------------------------------
echo &quot;path_name = $path_name&quot;
t=${path_name##/*/}
echo &quot;Из path_name удален путь к файлу = $t&quot;
#  В данном случае, тот эе эффект можно получить так:  t=`basename $path_name`
#  t=${path_name%/}; t=${t##*/}   более общее решение,
#+ но имеет некоторые ограничения.
#  Если $path_name заканчивается символом перевода строки, то `basename $path_name` не будет работать,
#+ но для данного случая вполне применимо.
# (Спасибо S.C.)

t=${path_name%/*.*}
# Тот же эффект дает    t=`dirname $path_name`
echo &quot;Из path_name удалено имя файла = $t&quot;
# Этот вариант будет терпеть неудачу в случаях: &quot;../&quot;, &quot;/foo////&quot;, # &quot;foo/&quot;, &quot;/&quot;.
#  Удаление имени файла, особенно когда его нет,
#+ использование dirname имеет свои особенности.
# (Спасибо S.C.)

echo

t=${path_name:11}
echo &quot;Из $path_name удалены первые 11 символов = $t&quot;
t=${path_name:11:5}
echo &quot;Из $path_name удалены первые 11 символов, выводится 5 символов = $t&quot;

echo

t=${path_name/bozo/clown}
echo &quot;В $path_name подстрока \&quot;bozo\&quot; заменена на \&quot;clown\&quot; = $t&quot;
t=${path_name/today/}
echo &quot;В $path_name подстрока \&quot;today\&quot; удалена = $t&quot;
t=${path_name//o/O}
echo &quot;В $path_name все символы \&quot;o\&quot; переведены в верхний регистр, = $t&quot;
t=${path_name//o/}
echo &quot;Из $path_name удалены все символы \&quot;o\&quot; = $t&quot;

exit 0
</pre>
                  </div>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${var/#Pattern/Replacement}</strong></tt></dt>

                <dd>
                  <p>Если в переменной <tt
                   class="REPLACEABLE"><em>var</em></tt> найдено
                  совпадение с <tt
                   class="REPLACEABLE"><em>Pattern</em></tt>, причем
                  совпадающая подстрока расположена в начале строки
                  (префикс), то оно заменяется на <tt
                   class="REPLACEABLE"><em>Replacement</em></tt>. Поиск
                  ведется с начала строки</p>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${var/%Pattern/Replacement}</strong></tt></dt>

                <dd>
                  <p>Если в переменной <tt
                   class="REPLACEABLE"><em>var</em></tt> найдено
                  совпадение с <tt
                   class="REPLACEABLE"><em>Pattern</em></tt>, причем
                  совпадающая подстрока расположена в конце строки
                  (суффикс), то оно заменяется на <tt
                   class="REPLACEABLE"><em>Replacement</em></tt>. Поиск
                  ведется с конца строки</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="VARMATCH"></a>

                    <p><strong>Пример 9-19. Поиск префиксов и суффиксов
                    с заменой по шаблону</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Поиск с заменой по шаблону.

v0=abc1234zip1234abc    # Начальное значение переменной.
echo &quot;v0 = $v0&quot;         # abc1234zip1234abc
echo

# Поиск совпадения с начала строки.
v1=${v0/#abc/ABCDEF}    # abc1234zip1234abc
                        # |-|
echo &quot;v1 = $v1&quot;         # ABCDE1234zip1234abc
                        # |---|

# Поиск совпадения с конца строки.
v2=${v0/%abc/ABCDEF}    # abc1234zip123abc
                        #              |-|
echo &quot;v2 = $v2&quot;         # abc1234zip1234ABCDEF
                        #               |----|

echo

#  ----------------------------------------------------
#  Если совпадение находится не с начала/конца строки,
#+ то замена не производится.
#  ----------------------------------------------------
v3=${v0/#123/000}       # Совпадение есть, но не в начале строки.
echo &quot;v3 = $v3&quot;         # abc1234zip1234abc
                        # ЗАМЕНА НЕ ПРОИЗВОДТСЯ!
v4=${v0/%123/000}       # Совпадение есть, но не в конце строки.
echo &quot;v4 = $v4&quot;         # abc1234zip1234abc
                        # ЗАМЕНА НЕ ПРОИЗВОДТСЯ!

exit 0
</pre>
                  </div>
                </dd>

                <dt><tt
                 class=
                "USERINPUT"><strong>${!varprefix*}</strong></tt>, <tt
                 class=
                "USERINPUT"><strong>${!varprefix@}</strong></tt></dt>

                <dd>
                  <p>Поиск по шаблону всех, ранее объявленных
                  переменных, имена которых начинаются с <span
                   class="emphasis"><em
                   class="EMPHASIS">varprefix</em></span>.</p>
<pre
 class="PROGRAMLISTING">
xyz23=whatever
xyz24=

a=${!xyz*}      # Подстановка имен объявленных переменных, которые начинаются с &quot;xyz&quot;.
echo &quot;a = $a&quot;   # a = xyz23 xyz24
a=${!xyz@}      # То же самое.
echo &quot;a = $a&quot;   # a = xyz23 xyz24

# Эта возможность была добавлена в Bash, в версии 2.04.
</pre>
                  <br>
                  <br>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="DECLAREREF"></a>9.4. Объявление переменных: <strong
             class="COMMAND">declare</strong> и <strong
             class="COMMAND">typeset</strong></h2>

            <p>Инструкции <strong
             class="COMMAND">declare</strong> и <strong
             class="COMMAND">typeset</strong> являются <a
             href="#BUILTINREF">встроенными</a> инструкциями (они
            абсолютно идентичны друг другу и являются синонимами) и
            предназначена для наложения ограничений на переменные. Это
            очень слабая попытка контроля над типами, которая имеется
            во многих языках программирования. Инструкция <strong
             class="COMMAND">declare</strong> появилась в Bash, начиная
            с версии 2. Кроме того, инструкция <strong
             class="COMMAND">typeset</strong> может использоваться и в
            ksh-сценариях.</p>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="DECLAREOPSREF1"></a>ключи инструкций
              declare/typeset</strong></p>

              <dl>
                <dt><span
                 class="TOKEN">-r</span> <tt
                 class="REPLACEABLE"><em>readonly</em></tt> (только для
                чтения)</dt>

                <dd>
<pre
 class="PROGRAMLISTING">
declare -r var1
</pre>
                  <br>
                  <br>

                  <p>(<tt
                   class="USERINPUT"><strong>declare -r
                  var1</strong></tt> аналогично объявлению <tt
                   class="USERINPUT"><strong>readonly
                  var1</strong></tt>)</p>

                  <p>Это грубый эквивалент констант (const) в языке C.
                  Попытка изменения таких переменных завершается
                  сообщением об ошибке.</p>
                </dd>

                <dt><span
                 class="TOKEN">-i</span> <tt
                 class="REPLACEABLE"><em>integer</em></tt></dt>

                <dd>
<pre
 class="PROGRAMLISTING">
declare -i number
# Сценарий интерпретирует переменную &quot;number&quot; как целое число.

number=3
echo &quot;number = $number&quot;     # number = 3

number=three
echo &quot;number = $number&quot;     # number = 0
# Строка &quot;three&quot; интерпретируется как целое число.
</pre>
                  Примечательно, что допускается выполнение некоторых
                  арифметических операций над переменными, объявленными
                  как integer, не прибегая к инструкциям <a
                   href="#EXPRREF">expr</a> или <a
                   href="#LETREF">let</a>.<br>
                  <br>
                </dd>

                <dt><span
                 class="TOKEN">-a</span> <tt
                 class="REPLACEABLE"><em>array</em></tt></dt>

                <dd>
<pre
 class="PROGRAMLISTING">
declare -a indices
</pre>
                  <br>
                  <br>

                  <p>Переменная <tt
                   class="VARNAME">indices</tt> объявляется
                  массивом.</p>
                </dd>

                <dt><span
                 class="TOKEN">-f</span> <tt
                 class="REPLACEABLE"><em>functions</em></tt></dt>

                <dd>
<pre
 class="PROGRAMLISTING">
declare -f
</pre>
                  <br>
                  <br>

                  <p>Инструкция <tt
                   class="USERINPUT"><strong>declare -f</strong></tt>,
                  без аргументов, приводит к выводу списка ранее
                  объявленных функций в сценарии.</p>
<pre
 class="PROGRAMLISTING">
declare -f function_name
</pre>
                  <br>
                  <br>

                  <p>Инструкция <tt
                   class="USERINPUT"><strong>declare -f
                  function_name</strong></tt> выводит имя функции
                  function_name, если она была объявлена ранее.</p>
                </dd>

                <dt><span
                 class="TOKEN">-x</span> <a
                 href="#EXPORTREF">export</a></dt>

                <dd>
<pre
 class="PROGRAMLISTING">
declare -x var3
</pre>
                  <br>
                  <br>

                  <p>Эта инструкция объявляет переменную, как доступную
                  для экспорта.</p>
                </dd>

                <dt>var=$value</dt>

                <dd>
<pre
 class="PROGRAMLISTING">
declare -x var3=373
</pre>
                  <br>
                  <br>

                  <p>Инструкция <strong
                   class="COMMAND">declare</strong> допускает
                  совмещение объявления и присваивания значения
                  переменной одновременно.</p>
                </dd>
              </dl>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="EX20"></a>

              <p><strong>Пример 9-20. Объявление переменных с помощью
              инструкции declare</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

func1 ()
{
echo Это функция.
}

declare -f        # Список функций, объявленных выше.

echo

declare -i var1   # var1 -- целочисленная переменная.
var1=2367
echo &quot;переменная var1 объявлена как $var1&quot;
var1=var1+1       # Допустимая арифметическая операция над целочисленными переменными.
echo &quot;переменная var1 увеличена на 1 = $var1.&quot;
# Допустимая операция для целочисленных переменных
echo &quot;Возможно ли записать дробное число 2367.1 в var1?&quot;
var1=2367.1       # Сообщение об ошибке, переменная не изменяется.
echo &quot;значение переменной var1 осталось прежним = $var1&quot;

echo

declare -r var2=13.36         # инструкция &#39;declare&#39; допускает установку свойств переменной
                              #+ и одновременно присваивать значение.
echo &quot;var2 declared as $var2&quot; # Допускается ли изменять значение readonly переменных?
var2=13.37                    # Сообщение об ошибке и завершение работы сценария.

echo &quot;значение переменной var2 осталось прежним $var2&quot; # Эта строка никогда не будет выполнена.

exit 0                        # Сценарий завершит работу выше.
</pre>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="IVR"></a>9.5. Косвенные ссылки на переменные</h2>

            <p><a
             name="IVRREF"></a></p>

            <p>Предположим, что значение одной переменной -- есть имя
            второй переменной. Возможно ли получить значение второй
            переменной через обращение к первой? Например, Пусть <tt
             class="REPLACEABLE"><em>a=letter_of_alphabet</em></tt> и
            <tt
             class="REPLACEABLE"><em>letter_of_alphabet=z</em></tt>,
            тогда вопрос будет звучать так: &quot;Возможно ли получить
            значение <tt
             class="REPLACEABLE"><em>z</em></tt>, обратившись к
            переменной <tt
             class="REPLACEABLE"><em>a</em></tt>?&quot;. В
            действительности это возможно и это называется <span
             class="emphasis"><em
             class="EMPHASIS">косвенной ссылкой</em></span>. Для этого
            необходимо прибегнуть к несколько необычной нотации <tt
             class="REPLACEABLE"><em>eval var1=\$$var2</em></tt>.</p>

            <div
             class="EXAMPLE">
              <a
               name="INDREF"></a>

              <p><strong>Пример 9-21. Косвенные ссылки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Косвенные ссылки на переменные.

a=letter_of_alphabet
letter_of_alphabet=z

echo

# Прямое обращение к переменной.
echo &quot;a = $a&quot;

# Косвенное обращение к переменной.
eval a=\$$a
echo &quot;А теперь a = $a&quot;

echo


# Теперь попробуем изменить переменную, на которую делается ссылка.

t=table_cell_3
table_cell_3=24
echo &quot;\&quot;table_cell_3\&quot; = $table_cell_3&quot;
echo -n &quot;разыменование (получение ссылки) \&quot;t\&quot; = &quot;; eval echo \$$t
# В данном, простом, случае,
#   eval t=\$$t; echo &quot;\&quot;t\&quot; = $t&quot;
# дает тот же результат (почему?).

echo

t=table_cell_3
NEW_VAL=387
table_cell_3=$NEW_VAL
echo &quot;Значение переменной \&quot;table_cell_3\&quot; изменено на $NEW_VAL.&quot;
echo &quot;Теперь \&quot;table_cell_3\&quot; = $table_cell_3&quot;
echo -n &quot;разыменование (получение ссылки) \&quot;t\&quot; = &quot;; eval echo \$$t
# инструкция &quot;eval&quot; принимает два аргумента &quot;echo&quot; и &quot;\$$t&quot; (назначает равным $table_cell_3)
echo

# (Спасибо S.C. за разъяснения.)


# Еще один способ -- нотация ${!t}, будет обсуждаться в разделе &quot;Bash, версия 2&quot;.
# Так же, см. пример &quot;ex78.sh&quot;.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="COLTOTALER2"></a>

              <p><strong>Пример 9-22. Передача косвенных ссылок в <tt
               class="REPLACEABLE"><em>awk</em></tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Другая версия сценария &quot;column totaler&quot;
# который суммирует заданную колонку (чисел) в заданном файле.
# Здесь используются косвенные ссылки.

ARGS=2
E_WRONGARGS=65

if [ $# -ne &quot;$ARGS&quot; ] # Проверка количества входных аргументов.
then
   echo &quot;Порядок использования: `basename $0` filename column-number&quot;
   exit $E_WRONGARGS
fi

filename=$1
column_number=$2

#===== До этой строки идентично первоначальному варианту сценария =====#


# Мнгострочные скрипты awk вызываются конструкцией   awk &#39; ..... &#39;


# Начало awk-сценария.
# ------------------------------------------------
awk &quot;

{ total += \$${column_number} # косвенная ссылка
}
END {
     print total
     }

     &quot; &quot;$filename&quot;
# ------------------------------------------------
# Конец awk-сценария.

# Косвенные ссылки делают возможным бесконфликтное
# обращение к переменным shell внутри вложенных сценариев awk.
# Спасибо Stephane Chazelas.


exit 0
</pre>
            </div>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="100%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Такой метод обращения к переменным имеет свои
                    особенности. Если переменная, на которую делается
                    ссылка, меняет свое значение, то переменная которая
                    ссылается, должна быть должным образом
                    разыменована, т.е. олжна быть выполнена операция
                    получения ссылки, как это делается в примере выше.
                    <a
                     name="IVR2"></a>К счастью, нотация <tt
                     class="REPLACEABLE"><em>${!variable}</em></tt>,
                    введенная в Bash, начиная с <a
                     href="#BASH2REF">версии 2</a> (см. <a
                     href="#EX78">Пример 34-2</a>) позволяет выполнять
                    косвенные ссылки более интуитивно понятным
                    образом.</p>
                  </td>
                </tr>
              </table>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="RANDOMVAR"></a>9.6. $RANDOM: генерация
            псевдослучайных целых чисел</h2>

            <p>$RANDOM -- внутренняя функция Bash (не константа),
            которая возвращает <span
             class="emphasis"><em
             class="EMPHASIS">псевдослучайные</em></span> целые числа в
            диапазоне 0 - 32767. Функция $RANDOM <tt
             class="REPLACEABLE"><em>не</em></tt> должна использоваться
            для генераци ключей шифрования.</p>

            <div
             class="EXAMPLE">
              <a
               name="EX21"></a>

              <p><strong>Пример 9-23. Генерация случайных
              чисел</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# $RANDOM возвращает различные случайные числа при каждом обращении к ней.
# Диапазон изменения: 0 - 32767 (16-битовое целое со знаком).

MAXCOUNT=10
count=1

echo
echo &quot;$MAXCOUNT случайных чисел:&quot;
echo &quot;-----------------&quot;
while [ &quot;$count&quot; -le $MAXCOUNT ]      # Генерация 10 ($MAXCOUNT) случайных чисел.
do
  number=$RANDOM
  echo $number
  let &quot;count += 1&quot;  # Нарастить счетчик.
done
echo &quot;-----------------&quot;

# Если вам нужны случайные числа не превышающие определенного числа,
# воспользуйтесь оператором деления по модулю (остаток от деления).

RANGE=500

echo

number=$RANDOM
let &quot;number %= $RANGE&quot;
echo &quot;Случайное число меньше $RANGE  ---  $number&quot;

echo

# Если вы желаете ограничить диапазон &quot;снизу&quot;,
# то просто производите генерацию псевдослучайных чисел в цикле до тех пор,
# пока не получите число большее нижней границы.

FLOOR=200

number=0   # инициализация
while [ &quot;$number&quot; -le $FLOOR ]
do
  number=$RANDOM
done
echo &quot;Случайное число, большее $FLOOR ---  $number&quot;
echo


# Эти два способа могут быть скомбинированы.
number=0   #initialize
while [ &quot;$number&quot; -le $FLOOR ]
do
  number=$RANDOM
  let &quot;number %= $RANGE&quot;  # Ограничение &quot;сверху&quot; числом $RANGE.
done
echo &quot;Случайное число в диапазоне от $FLOOR до $RANGE ---  $number&quot;
echo


# Генерация случайных &quot;true&quot; и &quot;false&quot; значений.
BINARY=2
number=$RANDOM
T=1

let &quot;number %= $BINARY&quot;
# let &quot;number &gt;&gt;= 14&quot;    дает более равномерное распределение
# (сдвиг вправо смещает старший бит на нулевую позицию, остальные биты обнуляются).
if [ &quot;$number&quot; -eq $T ]
then
  echo &quot;TRUE&quot;
else
  echo &quot;FALSE&quot;
fi

echo


# Можно имитировать бросание 2-х игровых кубиков.
SPOTS=7   # остаток от деления на 7 дает диапазон 0 - 6.
ZERO=0
die1=0
die2=0

# Кубики &quot;выбрасываются&quot; раздельно.

  while [ &quot;$die1&quot; -eq $ZERO ]     # Пока на &quot;кубике&quot; ноль.
  do
    let &quot;die1 = $RANDOM % $SPOTS&quot; # Имитировать бросок первого кубика.
  done

  while [ &quot;$die2&quot; -eq $ZERO ]
  do
    let &quot;die2 = $RANDOM % $SPOTS&quot; # Имитировать бросок второго кубика.
  done

let &quot;throw = $die1 + $die2&quot;
echo &quot;Результат броска кубиков = $throw&quot;
echo


exit 0

<a href="abs3.html">Advanced Bash-Scripting Guide - Часть 3</a>

  </body>
</html>

