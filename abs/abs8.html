<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <meta
     name="generator"
     content=
    "HTML Tidy for Linux/x86 (vers 1st July 2002), see www.w3.org">

    <title>Advanced Bash-Scripting Guide - Часть 8</title>
    <meta
     http-equiv="Content-Type"
     content="text/html; charset=koi8-r">
    <meta
     name="GENERATOR"
     content="Modular DocBook HTML Stylesheet Version 1.7">
  </head>
        <a href="/testing/index.html">Главная</a>
	<h1
         class="TITLE"><a
         name="AEN2"></a>Advanced Bash-Scripting Guide - Часть 8</h1>
  <body
   class="BOOK"
   bgcolor="#FFFFFF"
   text="#000000"
   link="#0000FF"
   vlink="#840084"
   alink="#0000FF">
      <div
       class="TOC">
       
          <dt>B. <a
           href="#SEDAWK">Маленький учебник по Sed и Awk</a></dt>

          <dd>
            <dl>
              <dt>B.1. <a
               href="#AEN14605">Sed</a></dt>

              <dt>B.2. <a
               href="#AWK">Awk</a></dt>
            </dl>
          </dd>

          <dt>C. <a
           href="#EXITCODES">Коды завершения, имеющие предопределенный
          смысл</a></dt>

          <dt>D. <a
           href="#IOREDIRINTRO">Подробное введение в операции
          ввода-вывода и перенаправление ввода-вывода</a></dt>

          <dt>E. <a
           href="#LOCALIZATION">Локализация</a></dt>

          <dt>F. <a
           href="#HISTCOMMANDS">История команд</a></dt>

          <dt>G. <a
           href="#SAMPLE-BASHRC">Пример файла <tt
           class="FILENAME">.bashrc</tt></a></dt>

          <dt>H. <a
           href="#DOSBATCH">Преобразование пакетных (*.bat) файлов DOS
          в сценарии командной оболочки</a></dt>

          <dt>I. <a
           href="#EXERCISES">Упражнения</a></dt>

          <dd>
            <dl>
              <dt>I.1. <a
               href="#SCRIPTANALYSIS">Анализ сценариев</a></dt>

              <dt>I.2. <a
               href="#WRITINGSCRIPTS">Создание сценариев</a></dt>
            </dl>
          </dd>

          <dt>J. <a
           href="#COPYRIGHT">Авторские права</a></dt>
        </dl>
      </div>

      <div
       class="LOT">
        <dl
         class="LOT">
          <dt><strong>Перечень таблиц</strong></dt>

          <dt>11-1. <a
           href="#JOBIDTABLE">Идентификация заданий</a></dt>

          <dt>30-1. <a
           href="#AEN13260">Ключи Bash</a></dt>

          <dt>33-1. <a
           href="#AEN13673">Числовые значения цвета в
          escape-последовательностях</a></dt>

          <dt>B-1. <a
           href="#AEN14623">Основные операции sed</a></dt>

          <dt>B-2. <a
           href="#AEN14681">Примеры операций в sed</a></dt>

          <dt>C-1. <a
           href="#AEN14880"><span
           class="QUOTE">&quot;Зарезервированные&quot;</span> коды
          завершения</a></dt>

          <dt>H-1. <a
           href="#AEN15143">Ключевые слова/переменные/операторы
          пакетных файлов DOS и их аналоги командной оболочки</a></dt>

          <dt>H-2. <a
           href="#AEN15350">Команды DOS и их эквиваленты в
          UNIX</a></dt>
        </dl>
      </div>

      <div
       class="LOT">
        <dl
         class="LOT">
          <dt><strong>Перечень приложений</strong></dt>

          <dt>2-1. <a
           href="#EX1"><strong
           class="COMMAND">cleanup</strong>: Сценарий очистки
          лог-файлов в /var/log</a></dt>

          <dt>2-2. <a
           href="#EX2"><strong
           class="COMMAND">cleanup</strong>: Расширенная версия
          предыдущего сценария.</a></dt>

          <dt>3-1. <a
           href="#EX8">Вложенные блоки и перенаправление
          ввода-вывода</a></dt>

          <dt>3-2. <a
           href="#RPMCHECK">Сохранение результата исполнения вложенного
          блока в файл</a></dt>

          <dt>3-3. <a
           href="#BGLOOP">Запуск цикла в фоновом режиме</a></dt>

          <dt>3-4. <a
           href="#EX58">Резервное архивирование всех файлов, которые
          были изменены в течение последних суток</a></dt>

          <dt>4-1. <a
           href="#EX9">Присваивание значений переменным и подстановка
          значений переменных</a></dt>

          <dt>4-2. <a
           href="#EX15">Простое присваивание</a></dt>

          <dt>4-3. <a
           href="#EX16">Присваивание значений переменным простое и
          замаскированное</a></dt>

          <dt>4-4. <a
           href="#INTORSTRING">Целое число или строка?</a></dt>

          <dt>4-5. <a
           href="#EX17">Позиционные параметры</a></dt>

          <dt>4-6. <a
           href="#EX18"><strong
           class="COMMAND">wh</strong>,</a> <a
           href="#WHOISREF">whois</a> выяснение имени домена</dt>

          <dt>4-7. <a
           href="#EX19">Использование команды <strong
           class="COMMAND">shift</strong></a></dt>

          <dt>5-1. <a
           href="#WEIRDVARS">Вывод &quot;причудливых&quot;
          переменных</a></dt>

          <dt>5-2. <a
           href="#ESCAPED">Экранированные символы</a></dt>

          <dt>6-1. <a
           href="#EX5">завершение / код завершения</a></dt>

          <dt>6-2. <a
           href="#NEGCOND">Использование символа <span
           class="TOKEN">!</span> для логической инверсии кода
          возврата</a></dt>

          <dt>7-1. <a
           href="#EX10">Что есть &quot;истина&quot;?</a></dt>

          <dt>7-2. <a
           href="#EX11">Эквиваленты команды <span
           class="TOKEN">test</span> -- <tt
           class="FILENAME">/usr/bin/test</tt>, <span
           class="TOKEN">[ ]</span>, и <tt
           class="FILENAME">/usr/bin/[</tt></a></dt>

          <dt>7-3. <a
           href="#ARITHTESTS">Арифметические выражения внутри <span
           class="TOKEN">(( ))</span></a></dt>

          <dt>7-4. <a
           href="#BROKENLINK">Проверка &quot;битых&quot;
          ссылок</a></dt>

          <dt>7-5. <a
           href="#EX13">Операции сравнения</a></dt>

          <dt>7-6. <a
           href="#STRTEST">Проверка -- является ли строка <span
           class="emphasis"><em
           class="EMPHASIS">пустой</em></span></a></dt>

          <dt>7-7. <a
           href="#EX14"><strong
           class="COMMAND">zmost</strong></a></dt>

          <dt>8-1. <a
           href="#GCD">Наибольший общий делитель</a></dt>

          <dt>8-2. <a
           href="#ARITHOPS">Арифметические операции</a></dt>

          <dt>8-3. <a
           href="#ANDOR">Построение сложных условий, использующих
          &amp;&amp; и ||</a></dt>

          <dt>8-4. <a
           href="#NUMBERS">Различные представления числовых
          констант</a></dt>

          <dt>9-1. <a
           href="#IFSH">$IFS и пробельные символы</a></dt>

          <dt>9-2. <a
           href="#TMDIN">Ограничения времени ожидания ввода</a></dt>

          <dt>9-3. <a
           href="#TIMEOUT">Еще один пример ограничения времени ожидания
          ввода от пользователя</a></dt>

          <dt>9-4. <a
           href="#TOUT">Ограничение времени ожидания команды <strong
           class="COMMAND">read</strong></a></dt>

          <dt>9-5. <a
           href="#AMIROOT">Я -- root?</a></dt>

          <dt>9-6. <a
           href="#ARGLIST"><strong
           class="COMMAND">arglist</strong>: Вывод списка аргументов с
          помощью переменных $* и $@</a></dt>

          <dt>9-7. <a
           href="#INCOMPAT">Противоречия в переменных <tt
           class="VARNAME">$*</tt> и <tt
           class="VARNAME">$@</tt></a></dt>

          <dt>9-8. <a
           href="#IFSEMPTY">Содержимое <tt
           class="VARNAME">$*</tt> и <tt
           class="VARNAME">$@</tt>, когда переменная <tt
           class="VARNAME">$IFS</tt> -- пуста</a></dt>

          <dt>9-9. <a
           href="#USCREF">Переменная &quot;подчеркивание&quot;</a></dt>

          <dt>9-10. <a
           href="#PARAGRAPHSPACE">Вставка пустых строк между
          параграфами в текстовом файле</a></dt>

          <dt>9-11. <a
           href="#CVT">Преобразование графических файлов из одного
          формата в другой, с изменением имени файла</a></dt>

          <dt>9-12. <a
           href="#SUBSTRINGEX">Альтернативный способ извлечения
          подстрок</a></dt>

          <dt>9-13. <a
           href="#EX6">Подстановка параметров и сообщения об
          ошибках</a></dt>

          <dt>9-14. <a
           href="#USAGEMESSAGE">Подстановка параметров и сообщение о
          <span
           class="QUOTE">&quot;порядке
          использования&quot;</span></a></dt>

          <dt>9-15. <a
           href="#LENGTH">Длина переменной</a></dt>

          <dt>9-16. <a
           href="#PATTMATCHING">Поиск по шаблону в подстановке
          параметров</a></dt>

          <dt>9-17. <a
           href="#RFE">Изменение расширений в именах файлов<span
           class="TOKEN">:</span></a></dt>

          <dt>9-18. <a
           href="#EX7">Поиск по шаблону при анализе произвольных
          строк</a></dt>

          <dt>9-19. <a
           href="#VARMATCH">Поиск префиксов и суффиксов с заменой по
          шаблону</a></dt>

          <dt>9-20. <a
           href="#EX20">Объявление переменных с помощью инструкции
          <strong
           class="COMMAND">declare</strong></a></dt>

          <dt>9-21. <a
           href="#INDREF">Косвенные ссылки</a></dt>

          <dt>9-22. <a
           href="#COLTOTALER2">Передача косвенных ссылок в <tt
           class="REPLACEABLE"><em>awk</em></tt></a></dt>

          <dt>9-23. <a
           href="#EX21">Генерация случайных чисел</a></dt>

          <dt>9-24. <a
           href="#PICKCARD">Выбор случайной карты из колоды</a></dt>

          <dt>9-25. <a
           href="#RANDOMTEST">Имитация бросания кубика с помощью
          RANDOM</a></dt>

          <dt>9-26. <a
           href="#SEEDINGRANDOM">Переустановка RANDOM</a></dt>

          <dt>9-27. <a
           href="#RANDOM2">Получение псевдослучайных чисел с
          помощью</a> <a
           href="#AWKREF">awk</a></dt>

          <dt>9-28. <a
           href="#CVARS">Работа с переменными в стиле языка C</a></dt>

          <dt>10-1. <a
           href="#EX22">Простой цикл <strong
           class="COMMAND">for</strong></a></dt>

          <dt>10-2. <a
           href="#EX22A">Цикл <strong
           class="COMMAND">for</strong> с двумя параметрами в каждом из
          элементов списка</a></dt>

          <dt>10-3. <a
           href="#FILEINFO"><span
           class="emphasis"><em
           class="EMPHASIS">Fileinfo:</em></span> обработка списка
          файлов, находящегося в переменной</a></dt>

          <dt>10-4. <a
           href="#LISTGLOB">Обработка списка файлов в цикле <strong
           class="COMMAND">for</strong></a></dt>

          <dt>10-5. <a
           href="#EX23">Цикл <strong
           class="COMMAND">for</strong> без списка аргументов</a></dt>

          <dt>10-6. <a
           href="#FORLOOPCMD">Создание списка аргументов в цикле
          <strong
           class="COMMAND">for</strong> с помощью операции подстановки
          команд</a></dt>

          <dt>10-7. <a
           href="#BINGREP"></a><a
           href="#GREPREF">grep</a> для бинарных файлов</dt>

          <dt>10-8. <a
           href="#USERLIST">Список всех пользователей системы</a></dt>

          <dt>10-9. <a
           href="#FINDSTRING">Проверка авторства всех бинарных файлов в
          текущем каталоге</a></dt>

          <dt>10-10. <a
           href="#SYMLINKS">Список символических ссылок в
          каталоге</a></dt>

          <dt>10-11. <a
           href="#SYMLINKS2">Список символических ссылок в каталоге,
          сохраняемый в файле</a></dt>

          <dt>10-12. <a
           href="#FORLOOPC">C-подобный синтаксис оператора цикла
          <strong
           class="COMMAND">for</strong></a></dt>

          <dt>10-13. <a
           href="#EX24">Работа с командой <strong
           class="COMMAND">efax</strong> в пакетном режиме</a></dt>

          <dt>10-14. <a
           href="#EX25">Простой цикл <strong
           class="COMMAND">while</strong></a></dt>

          <dt>10-15. <a
           href="#EX26">Другой пример цикла <strong
           class="COMMAND">while</strong></a></dt>

          <dt>10-16. <a
           href="#EX26A">Цикл <strong
           class="COMMAND">while</strong> с несколькими
          условиями</a></dt>

          <dt>10-17. <a
           href="#WHLOOPC">C-подобный синтаксис оформления цикла
          <strong
           class="COMMAND">while</strong></a></dt>

          <dt>10-18. <a
           href="#EX27">Цикл <strong
           class="COMMAND">until</strong></a></dt>

          <dt>10-19. <a
           href="#NESTEDLOOP">Вложенный цикл</a></dt>

          <dt>10-20. <a
           href="#EX28">Команды <strong
           class="COMMAND">break</strong> и <strong
           class="COMMAND">continue</strong> в цикле</a></dt>

          <dt>10-21. <a
           href="#BREAKLEVELS">Прерывание многоуровневых
          циклов</a></dt>

          <dt>10-22. <a
           href="#CONTINUELEVELS">Передача управление в начало внешнего
          цикла</a></dt>

          <dt>10-23. <a
           href="#CONTINUENEX">Живой пример использования <span
           class="QUOTE">&quot;continue N&quot;</span></a></dt>

          <dt>10-24. <a
           href="#EX29">Использование <strong
           class="COMMAND">case</strong></a></dt>

          <dt>10-25. <a
           href="#EX30">Создание меню с помощью <strong
           class="COMMAND">case</strong></a></dt>

          <dt>10-26. <a
           href="#CASECMD">Оператор <strong
           class="COMMAND">case</strong> допускает использовать
          подстановку команд вместо анализируемой переменной</a></dt>

          <dt>10-27. <a
           href="#MATCHSTRING">Простой пример сравнения строк</a></dt>

          <dt>10-28. <a
           href="#ISALPHA">Проверка ввода</a></dt>

          <dt>10-29. <a
           href="#EX31">Создание меню с помощью <strong
           class="COMMAND">select</strong></a></dt>

          <dt>10-30. <a
           href="#EX32">Создание меню с помощью <strong
           class="COMMAND">select</strong> в функции</a></dt>

          <dt>11-1. <a
           href="#EX47"><strong
           class="COMMAND">printf</strong> в действии</a></dt>

          <dt>11-2. <a
           href="#EX36">Ввод значений переменных с помощью <strong
           class="COMMAND">read</strong></a></dt>

          <dt>11-3. <a
           href="#READNOVAR">Пример использования команды <strong
           class="COMMAND">read</strong> без указания переменной для
          ввода</a></dt>

          <dt>11-4. <a
           href="#READR">Ввод многострочного текста с помощью <strong
           class="COMMAND">read</strong></a></dt>

          <dt>11-5. <a
           href="#ARROWDETECT">Обнаружение нажатия на курсорные
          клавиши</a></dt>

          <dt>11-6. <a
           href="#READREDIR">Чтение командой <strong
           class="COMMAND">read</strong> из файла через</a> <a
           href="#IOREDIRREF">перенаправление</a></dt>

          <dt>11-7. <a
           href="#EX37">Смена текущего каталога</a></dt>

          <dt>11-8. <a
           href="#EX46">Команда <strong
           class="COMMAND">let</strong>, арифметические
          операции.</a></dt>

          <dt>11-9. <a
           href="#EX43">Демонстрация команды <strong
           class="COMMAND">eval</strong></a></dt>

          <dt>11-10. <a
           href="#EX44">Принудительное завершение сеанса</a></dt>

          <dt>11-11. <a
           href="#ROT14">Шифрование по алгоритму <span
           class="QUOTE">&quot;rot13&quot;</span></a></dt>

          <dt>11-12. <a
           href="#EVALEX">Замена имени переменной на ее значение, в
          исходном тексте программы на языке Perl, с помощью <strong
           class="COMMAND">eval</strong></a></dt>

          <dt>11-13. <a
           href="#EX34">Установка значений аргументов с помощью команды
          <strong
           class="COMMAND">set</strong></a></dt>

          <dt>11-14. <a
           href="#SETPOS">Изменение значений позиционных параметров
          (аргументов)</a></dt>

          <dt>11-15. <a
           href="#UNS"><span
           class="QUOTE">&quot;Сброс&quot;</span> переменной</a></dt>

          <dt>11-16. <a
           href="#COLTOTALER3">Передача переменных во вложенный
          сценарий</a> <a
           href="#AWKREF">awk</a>, с помощью <strong
           class="COMMAND">export</strong></dt>

          <dt>11-17. <a
           href="#EX33">Прием опций/аргументов, передаваемых сценарию,
          с помощью <strong
           class="COMMAND">getopts</strong></a></dt>

          <dt>11-18. <a
           href="#EX38"><span
           class="QUOTE">&quot;Подключение&quot;</span> внешнего
          файла</a></dt>

          <dt>11-19. <a
           href="#SELFSOURCE">Пример (бесполезный) сценария, который
          подключает себя самого.</a></dt>

          <dt>11-20. <a
           href="#EX54">Команда <strong
           class="COMMAND">exec</strong></a></dt>

          <dt>11-21. <a
           href="#SELFEXEC">Сценарий, который запускает себя
          самого</a></dt>

          <dt>11-22. <a
           href="#EX39">Ожидание завершения процесса перед тем как
          продолжить работу</a></dt>

          <dt>11-23. <a
           href="#SELFDESTRUCT">Сценарий, завершающий себя сам с
          помощью команды kill</a></dt>

          <dt>12-1. <a
           href="#EX40">Создание оглавления диска для записи <span
           class="ABBREV">CDR</span>, с помощью команды <strong
           class="COMMAND">ls</strong></a></dt>

          <dt>12-2. <a
           href="#EX57"><strong
           class="COMMAND">Badname</strong>, удаление файлов в текущем
          каталоге, имена которых содержат недопустимые символы и</a>
          <a
           href="#WHITESPACEREF">пробелы</a>.</dt>

          <dt>12-3. <a
           href="#IDELETE">Удаление файла по его номеру <span
           class="emphasis"><em
           class="EMPHASIS">inode</em></span></a></dt>

          <dt>12-4. <a
           href="#EX41">Использование команды <strong
           class="COMMAND">xargs</strong> для мониторинга системного
          журнала</a></dt>

          <dt>12-5. <a
           href="#EX42"><strong
           class="COMMAND">copydir</strong>, копирование файлов из
          текущего каталога в другое место, с помощью <strong
           class="COMMAND">xargs</strong></a></dt>

          <dt>12-6. <a
           href="#EX45">Пример работы с <strong
           class="COMMAND">expr</strong></a></dt>

          <dt>12-7. <a
           href="#EX51">Команда <strong
           class="COMMAND">date</strong></a></dt>

          <dt>12-8. <a
           href="#WF">Частота встречаемости отдельных слов</a></dt>

          <dt>12-9. <a
           href="#SCRIPTDETECTOR">Какие из файлов являются
          сценариями?</a></dt>

          <dt>12-10. <a
           href="#RND">Генератор 10-значных случайных чисел</a></dt>

          <dt>12-11. <a
           href="#EX12">Мониторинг системного журнала с помощью <strong
           class="COMMAND">tail</strong></a></dt>

          <dt>12-12. <a
           href="#GRP">Сценарий-эмулятор <span
           class="QUOTE">&quot;grep&quot;</span></a></dt>

          <dt>12-13. <a
           href="#LOOKUP">Поиск слов в словаре</a></dt>

          <dt>12-14. <a
           href="#EX49"><strong
           class="COMMAND">toupper</strong>: Преобразование символов в
          верхний регистр.</a></dt>

          <dt>12-15. <a
           href="#LOWERCASE"><strong
           class="COMMAND">lowercase</strong>: Изменение имен всех
          файлов в текущем каталоге в нижний регистр.</a></dt>

          <dt>12-16. <a
           href="#DU"><strong
           class="COMMAND">du</strong>: Преобразование текстового файла
          из формата DOS в формат UNIX.</a></dt>

          <dt>12-17. <a
           href="#ROT13"><strong
           class="COMMAND">rot13</strong>: Сверхслабое шифрование по
          алгоритму rot13.</a></dt>

          <dt>12-18. <a
           href="#CRYPTOQUOTE">Более <span
           class="QUOTE">&quot;сложный&quot;</span> шифр</a></dt>

          <dt>12-19. <a
           href="#EX50">Отформатированный список файлов.</a></dt>

          <dt>12-20. <a
           href="#COL">Пример форматирования списка файлов в
          каталоге</a></dt>

          <dt>12-21. <a
           href="#LNUM"><strong
           class="COMMAND">nl</strong>: Самонумерующийся
          сценарий.</a></dt>

          <dt>12-22. <a
           href="#EX48">Пример перемещения дерева каталогов с помощью
          <strong
           class="COMMAND">cpio</strong></a></dt>

          <dt>12-23. <a
           href="#DERPM">Распаковка архива <span
           class="emphasis"><em
           class="EMPHASIS">rpm</em></span></a></dt>

          <dt>12-24. <a
           href="#STRIPC">Удаление комментариев из файла с текстом
          программы на языке C</a></dt>

          <dt>12-25. <a
           href="#WHAT"><strong
           class="COMMAND">Исследование каталога <tt
           class="FILENAME">/usr/X11R6/bin</tt></strong></a></dt>

          <dt>12-26. <a
           href="#WSTRINGS"><span
           class="QUOTE">&quot;Расширенная&quot;</span> команда <span
           class="emphasis"><em
           class="EMPHASIS">strings</em></span></a></dt>

          <dt>12-27. <a
           href="#FILECOMP">Пример сравнения двух файлов с помощью
          <strong
           class="COMMAND">cmp</strong>.</a></dt>

          <dt>12-28. <a
           href="#EX35">Утилиты <strong
           class="COMMAND">basename</strong> и <strong
           class="COMMAND">dirname</strong></a></dt>

          <dt>12-29. <a
           href="#FILEINTEGRITY">Проверка целостности файла</a></dt>

          <dt>12-30. <a
           href="#EX52">Декодирование файлов</a></dt>

          <dt>12-31. <a
           href="#SELFMAILER">Сценарий, отправляющий себя самого по
          электронной почте</a></dt>

          <dt>12-32. <a
           href="#MONTHLYPMT">Ежемесячные выплаты по займу</a></dt>

          <dt>12-33. <a
           href="#BASE">Перевод чисел из одной системы счисления в
          другую</a></dt>

          <dt>12-34. <a
           href="#ALTBC">Пример взаимодействия <strong
           class="COMMAND">bc</strong> со <span
           class="QUOTE">&quot;встроенным
          документом&quot;</span></a></dt>

          <dt>12-35. <a
           href="#CANNON">Вычисление числа &quot;пи&quot;</a></dt>

          <dt>12-36. <a
           href="#HEXCONVERT">Преобразование чисел из десятичной в
          шестнадцатиричную систему счисления</a></dt>

          <dt>12-37. <a
           href="#FACTR">Разложение числа на простые множители</a></dt>

          <dt>12-38. <a
           href="#HYPOT">Расчет гипотенузы прямоугольного
          треугольника</a></dt>

          <dt>12-39. <a
           href="#EX53">Использование <strong
           class="COMMAND">seq</strong> для генерации списка аргументов
          цикла for</a></dt>

          <dt>12-40. <a
           href="#EX33A">Использование <strong
           class="COMMAND">getopt</strong> для разбора аргументов
          командной строки</a></dt>

          <dt>12-41. <a
           href="#DDKEYPRESS">Захват нажатых клавиш</a></dt>

          <dt>12-42. <a
           href="#BLOTOUT">Надежное удаление файла</a></dt>

          <dt>12-43. <a
           href="#TEMPFILENAME">Генератор имен файлов</a></dt>

          <dt>12-44. <a
           href="#UNITCONVERSION">Преобразование метров в мили</a></dt>

          <dt>12-45. <a
           href="#M4">Пример работы с m4</a></dt>

          <dt>13-1. <a
           href="#ERASE">Установка символа &quot;забоя&quot;</a></dt>

          <dt>13-2. <a
           href="#SECRETPW"><strong
           class="COMMAND">невидимый пароль</strong>: Отключение
          эхо-вывода на терминал</a></dt>

          <dt>13-3. <a
           href="#KEYPRESS"></a></dt>

          <dt>13-4. <a
           href="#KILLPROCESS">Использование команды <strong
           class="COMMAND">pidof</strong> при остановке
          процесса</a></dt>

          <dt>13-5. <a
           href="#ISOMOUNTREF">Проверка образа CD</a></dt>

          <dt>13-6. <a
           href="#CREATEFS">Создание файловой системы в обычном
          файле</a></dt>

          <dt>13-7. <a
           href="#ADDDRV">Добавление нового жесткого диска</a></dt>

          <dt>13-8. <a
           href="#EX55">Сценарий <strong
           class="COMMAND">killall</strong>, из каталога <tt
           class="FILENAME">/etc/rc.d/init.d</tt></a></dt>

          <dt>14-1. <a
           href="#STUPSCR">Глупая выходка</a></dt>

          <dt>14-2. <a
           href="#CSUBLOOP">Запись результатов выполнения цикла в
          переменную</a></dt>

          <dt>16-1. <a
           href="#REDIR1">Перенаправление <tt
           class="FILENAME">stdin</tt> с помощью <strong
           class="COMMAND">exec</strong></a></dt>

          <dt>16-2. <a
           href="#REASSIGNSTDOUT">Перенаправление <tt
           class="FILENAME">stdout</tt> с помощью <strong
           class="COMMAND">exec</strong></a></dt>

          <dt>16-3. <a
           href="#UPPERCONV">Одновременное перенаправление устройств,
          <tt
           class="FILENAME">stdin</tt> и <tt
           class="FILENAME">stdout</tt>, с помощью команды <strong
           class="COMMAND">exec</strong></a></dt>

          <dt>16-4. <a
           href="#REDIR2">Перенаправление в цикл <span
           class="emphasis"><em
           class="EMPHASIS">while</em></span></a></dt>

          <dt>16-5. <a
           href="#REDIR2A">Альтернативная форма перенаправления в цикле
          <span
           class="emphasis"><em
           class="EMPHASIS">while</em></span></a></dt>

          <dt>16-6. <a
           href="#REDIR3">Перенаправление в цикл <span
           class="emphasis"><em
           class="EMPHASIS">until</em></span></a></dt>

          <dt>16-7. <a
           href="#REDIR4">Перенаправление в цикл <span
           class="emphasis"><em
           class="EMPHASIS">for</em></span></a></dt>

          <dt>16-8. <a
           href="#REDIR4A">Перенаправление устройств (<tt
           class="FILENAME">stdin</tt> и <tt
           class="FILENAME">stdout</tt>) в цикле <span
           class="emphasis"><em
           class="EMPHASIS">for</em></span></a></dt>

          <dt>16-9. <a
           href="#REDIR5">Перенаправление в конструкции <span
           class="emphasis"><em
           class="EMPHASIS">if/then</em></span></a></dt>

          <dt>16-10. <a
           href="#NAMESDATA">Файл с именами <span
           class="QUOTE">&quot;names.data&quot;</span>, для примеров
          выше</a></dt>

          <dt>16-11. <a
           href="#LOGEVENTS">Регистрация событий</a></dt>

          <dt>17-1. <a
           href="#EX69"><strong
           class="COMMAND">dummyfile</strong>: Создание 2-х строчного
          файла-заготовки</a></dt>

          <dt>17-2. <a
           href="#EX70"><strong
           class="COMMAND">broadcast</strong>: Передача сообщения всем,
          работающим в системе, пользователям</a></dt>

          <dt>17-3. <a
           href="#EX71">Вывод многострочных сообщений с помощью <strong
           class="COMMAND">cat</strong></a></dt>

          <dt>17-4. <a
           href="#EX71A">Вывод многострочных сообщений с подавлением
          символов табуляции</a></dt>

          <dt>17-5. <a
           href="#EX71B">Встроенные документы и подстановка
          параметров</a></dt>

          <dt>17-6. <a
           href="#EX71C">Отключение подстановки параметров</a></dt>

          <dt>17-7. <a
           href="#EX72">Передача пары файлов во входящий каталог на
          <span
           class="QUOTE">&quot;Sunsite&quot;</span></a></dt>

          <dt>17-8. <a
           href="#HF">Встроенные документы и функции</a></dt>

          <dt>17-9. <a
           href="#ANONHEREDOC"><span
           class="QUOTE">&quot;Анонимный&quot;</span> Встроенный
          Документ</a></dt>

          <dt>17-10. <a
           href="#COMMENTBLOCK">Блочный комментарий</a></dt>

          <dt>17-11. <a
           href="#SELFDOCUMENT">Встроенная справка к сценарию</a></dt>

          <dt>19-1. <a
           href="#SUBSHELL">Область видимости переменных</a></dt>

          <dt>19-2. <a
           href="#ALLPROFS">Личные настройки пользователей</a></dt>

          <dt>19-3. <a
           href="#PARALLEL-PROCESSES">Запуск нескольких процессов в
          подоболочках</a></dt>

          <dt>20-1. <a
           href="#RESTRICTED">Запуск сценария в ограниченном
          режиме</a></dt>

          <dt>22-1. <a
           href="#EX59">Простая функция</a></dt>

          <dt>22-2. <a
           href="#EX60">Функция с аргументами</a></dt>

          <dt>22-3. <a
           href="#MAX">Наибольшее из двух чисел</a></dt>

          <dt>22-4. <a
           href="#EX61">Преобразование чисел в римскую форму
          записи</a></dt>

          <dt>22-5. <a
           href="#RETURNTEST">Проверка возможности возврата функциями
          больших значений</a></dt>

          <dt>22-6. <a
           href="#MAX2">Сравнение двух больших целых чисел</a></dt>

          <dt>22-7. <a
           href="#REALNAME">Настоящее имя пользователя</a></dt>

          <dt>22-8. <a
           href="#EX62">Область видимости локальных переменных</a></dt>

          <dt>22-9. <a
           href="#EX63">Использование локальных переменных при
          рекурсии</a></dt>

          <dt>23-1. <a
           href="#AL">Псевдонимы в сценарии</a></dt>

          <dt>23-2. <a
           href="#UNAL"><strong
           class="COMMAND">unalias</strong>: Объявление и удаление
          псевдонимов</a></dt>

          <dt>24-1. <a
           href="#EX64">Проверка аргументов командной строки с помощью
          <span
           class="QUOTE">&quot;И-списка&quot;</span></a></dt>

          <dt>24-2. <a
           href="#ANDLIST2">Еще один пример проверки аргументов с
          помощью <span
           class="QUOTE">&quot;И-списков&quot;</span></a></dt>

          <dt>24-3. <a
           href="#EX65">Комбинирование <span
           class="QUOTE">&quot;ИЛИ-списков&quot;</span> и <span
           class="QUOTE">&quot;И-списков&quot;</span></a></dt>

          <dt>25-1. <a
           href="#EX66">Простой массив</a></dt>

          <dt>25-2. <a
           href="#POEM">Форматирование стихотворения</a></dt>

          <dt>25-3. <a
           href="#EX67">Некоторые специфичные особенности
          массивов</a></dt>

          <dt>25-4. <a
           href="#EMPTYARRAY">Пустые массивы и пустые элементы</a></dt>

          <dt>25-5. <a
           href="#COPYARRAY">Копирование и конкатенация
          массивов</a></dt>

          <dt>25-6. <a
           href="#BUBBLE">Старая, добрая: <span
           class="emphasis"><em
           class="EMPHASIS">&quot;Пузырьковая&quot;
          сортировка</em></span></a></dt>

          <dt>25-7. <a
           href="#EMBARR">Вложенные массивы и косвенные ссылки</a></dt>

          <dt>25-8. <a
           href="#EX68">Пример реализации алгоритма <span
           class="emphasis"><em
           class="EMPHASIS">Решето Эратосфена</em></span></a></dt>

          <dt>25-9. <a
           href="#STACKEX">Эмуляция структуры &quot;СТЕК&quot;
          (&quot;первый вошел -- последний вышел&quot;)</a></dt>

          <dt>25-10. <a
           href="#QFUNCTION"><span
           class="emphasis"><em
           class="EMPHASIS">Исследование математических
          последовательностей</em></span></a></dt>

          <dt>25-11. <a
           href="#TWODIM">Эмуляция массива с двумя измерениями</a></dt>

          <dt>27-1. <a
           href="#PIDID">Поиск файла программы по идентификатору
          процесса</a></dt>

          <dt>27-2. <a
           href="#CONSTAT">Проверка состояния соединения</a></dt>

          <dt>28-1. <a
           href="#COOKIES">Удаление cookie-файлов</a></dt>

          <dt>28-2. <a
           href="#EX73">Создание файла подкачки (swapfile), с помощью
          <tt
           class="FILENAME">/dev/zero</tt></a></dt>

          <dt>28-3. <a
           href="#RAMDISK">Создание электронного диска</a></dt>

          <dt>29-1. <a
           href="#EX74">Сценарий, содержащий ошибку</a></dt>

          <dt>29-2. <a
           href="#MISSINGKEYWORD">Пропущено</a> <a
           href="#KEYWORDREF">ключевое слово</a></dt>

          <dt>29-3. <a
           href="#EX75">test24</a></dt>

          <dt>29-4. <a
           href="#ASSERT">Проверка условия с помощью функции <span
           class="QUOTE">&quot;assert&quot;</span></a></dt>

          <dt>29-5. <a
           href="#EX76">Ловушка на выходе</a></dt>

          <dt>29-6. <a
           href="#ONLINE">Удаление временного файла при нажатии на
          Control-C</a></dt>

          <dt>29-7. <a
           href="#VARTRACE">Трассировка переменной</a></dt>

          <dt>31-1. <a
           href="#SUBPIT">Западня в подоболочке</a></dt>

          <dt>31-2. <a
           href="#BADREAD">Передача вывода от команды <strong
           class="COMMAND">echo</strong> команде <strong
           class="COMMAND">read</strong>, по конвейеру</a></dt>

          <dt>33-1. <a
           href="#EX3"><strong
           class="COMMAND">сценарий-обертка</strong></a></dt>

          <dt>33-2. <a
           href="#EX4">Более сложный пример <strong
           class="COMMAND">сценария-обертки</strong></a></dt>

          <dt>33-3. <a
           href="#COLTOTALER"><strong
           class="COMMAND">Сценарий-обертка</strong> вокруг сценария
          awk</a></dt>

          <dt>33-4. <a
           href="#EX56">Сценарий на языке Perl, встроенный в <strong
           class="COMMAND">Bash</strong>-скрипт</a></dt>

          <dt>33-5. <a
           href="#BASHANDPERL">Комбинирование сценария Bash и Perl в
          одном файле</a></dt>

          <dt>33-6. <a
           href="#RECURSE">Сценарий (бесполезный), который вызывает
          себя сам</a></dt>

          <dt>33-7. <a
           href="#PBOOK">Сценарий имеющий практическую ценность),
          который вызывает себя сам</a></dt>

          <dt>33-8. <a
           href="#EX30A"><span
           class="QUOTE">&quot;Цветная&quot;</span> адресная
          книга</a></dt>

          <dt>33-9. <a
           href="#COLORECHO">Вывод цветного текста</a></dt>

          <dt>33-10. <a
           href="#MULTIPLICATION">Необычный способ передачи
          возвращаемого значения</a></dt>

          <dt>33-11. <a
           href="#SUMPRODUCT">Необычный способ получения нескольких
          возвращаемых значений</a></dt>

          <dt>33-12. <a
           href="#ARRFUNC">Передача массива в функцию и возврат массива
          из функции</a></dt>

          <dt>33-13. <a
           href="#AGRAM">Игры с анаграммами</a></dt>

          <dt>34-1. <a
           href="#EX77">Расширение строк</a></dt>

          <dt>34-2. <a
           href="#EX78">Косвенные ссылки на переменные -- новый
          метод</a></dt>

          <dt>34-3. <a
           href="#RESISTOR">Простая база данных, с применением
          косвенных ссылок</a></dt>

          <dt>34-4. <a
           href="#EX79">Массивы и другие хитрости для раздачи колоды
          карт в четыре руки</a></dt>

          <dt>A-1. <a
           href="#MANVIEW"><strong
           class="COMMAND">manview</strong>: Просмотр страниц
          руководств man</a></dt>

          <dt>A-2. <a
           href="#MAILFORMAT"><strong
           class="COMMAND">mailformat</strong>: Форматирование
          электронных писем</a></dt>

          <dt>A-3. <a
           href="#RN"><strong
           class="COMMAND">rn</strong>: Очень простая утилита для
          переименования файлов</a></dt>

          <dt>A-4. <a
           href="#BLANKRENAME"><strong
           class="COMMAND">blank-rename</strong>: переименование
          файлов, чьи имена содержат пробелы</a></dt>

          <dt>A-5. <a
           href="#ENCRYPTEDPW"><strong
           class="COMMAND">encryptedpw</strong>: Передача файла на
          ftp-сервер, с использованием пароля</a></dt>

          <dt>A-6. <a
           href="#COPYCD"><strong
           class="COMMAND">copy-cd</strong>: Копирование компакт-дисков
          с данными</a></dt>

          <dt>A-7. <a
           href="#COLLATZ">Последовательности Коллаца
          (Collatz)</a></dt>

          <dt>A-8. <a
           href="#DAYSBETWEEN"><strong
           class="COMMAND">days-between</strong>: Подсчет числа дней
          между двумя датами</a></dt>

          <dt>A-9. <a
           href="#MAKEDICT">Создание <span
           class="QUOTE">&quot;словаря&quot;</span></a></dt>

          <dt>A-10. <a
           href="#SOUNDEX">Расчет индекса
          &quot;созвучности&quot;</a></dt>

          <dt>A-11. <a
           href="#LIFESLOW"><span
           class="QUOTE">&quot;Игра
          &quot;Жизнь&quot;&quot;</span></a></dt>

          <dt>A-12. <a
           href="#GEN0DATA">Файл с первым поколением для игры <span
           class="QUOTE">&quot;Жизнь&quot;</span></a></dt>

          <dt>A-13. <a
           href="#BEHEAD"><strong
           class="COMMAND">behead</strong>: Удаление заголовков из
          электронных писем и новостей</a></dt>

          <dt>A-14. <a
           href="#FTPGET"><strong
           class="COMMAND">ftpget</strong>: Скачивание файлов по
          ftp</a></dt>

          <dt>A-15. <a
           href="#MORCOPY">Указание на авторские права</a></dt>

          <dt>A-16. <a
           href="#PW"><strong
           class="COMMAND">password</strong>: Генератор случайного 8-ми
          символьного пароля</a></dt>

          <dt>A-17. <a
           href="#FIFO"><strong
           class="COMMAND">fifo</strong>: Создание резервных копий с
          помощью именованных каналов</a></dt>

          <dt>A-18. <a
           href="#PRIMES">Генерация простых чисел, с использованием
          оператора деления по модулю (остаток от деления)</a></dt>

          <dt>A-19. <a
           href="#TREE"><strong
           class="COMMAND">tree</strong>: Вывод дерева
          каталогов</a></dt>

          <dt>A-20. <a
           href="#STRING"><strong
           class="COMMAND">Функции для работы со
          строками</strong></a></dt>

          <dt>A-21. <a
           href="#DIRECTORYINFO">Directory information</a></dt>

          <dt>A-22. <a
           href="#OBJORIENTED">Объектно ориентированная база
          данных</a></dt>

          <dt>G-1. <a
           href="#BASHRC">Пример файла <tt
           class="FILENAME">.bashrc</tt></a></dt>

          <dt>H-1. <a
           href="#VIEWDAT">VIEWDATA.BAT: пакетный файл DOS</a></dt>

          <dt>H-2. <a
           href="#VIEWDATA">viewdata.sh: Результат преобразования
          VIEWDATA.BAT в сценарий командной оболочки</a></dt>
        </dl>
      </div>
		
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# mail-format.sh: Форматирование электронных писем.

# Удаляет символы &quot;^&quot;, табуляции и ограничивает чрезмерно длинные строки.

# =================================================================
#                 Стандартная проверка аргументов
ARGS=1
E_BADARGS=65
E_NOFILE=66

if [ $# -ne $ARGS ]  # Проверка числа аргументов
then
  echo &quot;Порядок использования: `basename $0` имя_файла&quot;
  exit $E_BADARGS
fi

if [ -f &quot;$1&quot; ]       # Проверка наличия файла.
then
    file_name=$1
else
    echo &quot;Файл \&quot;$1\&quot; не найден.&quot;
    exit $E_NOFILE
fi
# =================================================================

MAXWIDTH=70          # Максимальная длина строки.

#  Удаление символов &quot;^&quot; начиная с первого символа строки,
#+ и ограничить длину строки 70-ю символами.
sed &#39;
s/^&gt;//
s/^  *&gt;//
s/^  *//
s/              *//
&#39; $1 | fold -s --width=$MAXWIDTH
          # ключ -s команды &quot;fold&quot; разрывает, если это возможно, строку по пробельному символу.

#  Этот сценарий был написан после прочтения статьи, в котором расхваливалась
#+ утилита под Windows, размером в 164K, с подобной функциональностью.
#
#  Хороший набор утилит для обработки текста и эффективный
#+ скриптовый язык -- это все, что необходимо, чтобы составить серьезную конкуренцию
#+ чрезмерно &quot;раздутым&quot; программам.

exit 0
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="RN"></a>

          <p><strong>Пример A-3. rn: Очень простая утилита для
          переименования файлов</strong></p>

          <p>Этот сценарий является модификацией <a
           href="#LOWERCASE">Пример 12-15</a>.</p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
#
# Очень простая утилита для переименования файлов
#
#  Утилита &quot;ren&quot;, автор Vladimir Lanin (lanin@csd2.nyu.edu),
#+ выполняет эти же действия много лучше.


ARGS=2
E_BADARGS=65
ONE=1                     # Единственное или множественное число (см. ниже).

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` старый_шаблон новый_шаблон&quot;
  # Например: &quot;rn gif jpg&quot;, поменяет расширения всех файлов в текущем каталоге с gif на jpg.
  exit $E_BADARGS
fi

number=0                  # Количество переименованных файлов.


for filename in *$1*      # Проход по списку файлов в текущем каталоге.
do
   if [ -f &quot;$filename&quot; ]
   then
     fname=`basename $filename`            # Удалить путь к файлу из имени.
     n=`echo $fname | sed -e &quot;s/$1/$2/&quot;`   # Поменять старое имя на новое.
     mv $fname $n                          # Переименовать.
     let &quot;number += 1&quot;
   fi
done

if [ &quot;$number&quot; -eq &quot;$ONE&quot; ]                # Соблюдение правил грамматики.
then
 echo &quot;$number файл переименован.&quot;
else
 echo &quot;Переименовано файлов: $number.&quot;
fi

exit 0


# Упражнения:
# ----------
# С какими типами файлов этот сценарий не будет работать?
# Как это исправить?
#
#  Переделайте сценарий таким образом, чтобы он мог обрабатывать все файлы в каталоге,
#+ в именах которых содержатся пробелы, заменяя пробелы символом подчеркивания.
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="BLANKRENAME"></a>

          <p><strong>Пример A-4. blank-rename: переименование файлов,
          чьи имена содержат пробелы</strong></p>

          <p>Это даже более простая версия предыдущего примера.</p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
# blank-rename.sh
#
# Заменяет пробелы символом подчеркивания в именах файлов в текущем каталоге.

ONE=1                     # единственное или множественное число (см. ниже).
number=0                  # Количество переименованных файлов.
FOUND=0                   # Код завершения в случае успеха.

for filename in *         # Перебор всех файлов в текущем каталоге.
do
     echo &quot;$filename&quot; | grep -q &quot; &quot;         #  Проверить -- содержит ли имя файла
     if [ $? -eq $FOUND ]                   #+ пробелы.
     then
       fname=$filename                      # Удалить путь из имени файла.
       n=`echo $fname | sed -e &quot;s/ /_/g&quot;`   # Заменить пробелы символом подчеркивания.
       mv &quot;$fname&quot; &quot;$n&quot;                     # Переименование.
       let &quot;number += 1&quot;
     fi
done

if [ &quot;$number&quot; -eq &quot;$ONE&quot; ]
then
 echo &quot;$number файл переименован.&quot;
else
 echo &quot;Переименовано файлов: $number&quot;
fi

exit 0
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="ENCRYPTEDPW"></a>

          <p><strong>Пример A-5. encryptedpw: Передача файла на
          ftp-сервер, с использованием пароля</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Модификация примера &quot;ex72.sh&quot;, добавлено шифрование пароля.

#  Обратите внимание: этот вариант все еще нельзя считать безопасным,
#+ поскольку в сеть пароль уходит в незашифрованном виде.
# Используйте &quot;ssh&quot;, если вас это беспокоит.

E_BADARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` имя_файла&quot;
  exit $E_BADARGS
fi

Username=bozo           # Измените на свой.
pword=/home/bozo/secret/password_encrypted.file
# Файл, содержащий пароль в зашифрованном виде.

Filename=`basename $1`  # Удалить путь из имени файла

Server=&quot;XXX&quot;
Directory=&quot;YYY&quot;         # Подставьте фактические имя сервера и каталога.


Password=`cruft &lt;$pword`          # Расшифровка.
#  Используется авторская программа &quot;cruft&quot;,
#+ основанная на алгоритме &quot;onetime pad&quot;,
#+ ее можно скачать с :
#+ Primary-site:   ftp://ibiblio.org/pub/Linux/utils/file
#+                 cruft-0.2.tar.gz [16k]


ftp -n $Server &lt;&lt;End-Of-Session
user $Username $Password
binary
bell
cd $Directory
put $Filename
bye
End-Of-Session
# ключ -n, команды &quot;ftp&quot;, запрещает автоматический вход.
# &quot;bell&quot; -- звонок (звуковой сигнал) после передачи каждого файла.

exit 0
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="COPYCD"></a>

          <p><strong>Пример A-6. copy-cd: Копирование компакт-дисков с
          данными</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# copy-cd.sh: copying a data CD

CDROM=/dev/cdrom                           # устройство CD ROM
OF=/home/bozo/projects/cdimage.iso         # промежуточный файл
#       /xxxx/xxxxxxx/                     измените для своей системы.
BLOCKSIZE=2048
SPEED=2                                    # Можно задать более высокую скорость, если поддерживается.

echo; echo &quot;Вставьте исходный CD, но *НЕ* монтируйте его.&quot;
echo &quot;Нажмите ENTER, когда будете готовы. &quot;
read ready                                 # Ожидание.

echo; echo &quot;Создается промежуточный файл $OF.&quot;
echo &quot;Это может занять какое-то время. Пожалуйста подождите.&quot;

dd if=$CDROM of=$OF bs=$BLOCKSIZE          # Копирование.


echo; echo &quot;Выньте исходный CD.&quot;
echo &quot;Вставьте чистую болванку CDR.&quot;
echo &quot;Нажмите ENTER, когда будете готовы. &quot;
read ready                                 # Ожидание.

echo &quot;Копируется файл $OF на болванку.&quot;

cdrecord -v -isosize speed=$SPEED dev=0,0 $OF
# Используется пакет Joerg Schilling -- &quot;cdrecord&quot; .
# http://www.fokus.gmd.de/nthp/employees/schilling/cdrecord.html


echo; echo &quot;Копирование завершено.&quot;

echo &quot;Желаете удалить промежуточный файл (y/n)? &quot;  # Наверняка большой файл получился.
read answer

case &quot;$answer&quot; in
[yY]) rm -f $OF
      echo &quot;Файл $OF удален.&quot;
      ;;
*)    echo &quot;Файл $OF не был удален.&quot;;;
esac

echo

# Упражнение:
# Добавьте в оператор &quot;case&quot; возможность обработки, введенных пользователем, &quot;yes&quot; и &quot;Yes&quot;.

exit 0
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="COLLATZ"></a>

          <p><strong>Пример A-7. Последовательности Коллаца
          (Collatz)</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# collatz.sh

#  Широко известная последовательность Коллаца (Collatz) (гипотеза Коллаца).
#  -------------------------------------------
#  1) Принимает из командной строки &quot;начальное&quot; целое число.
#  2) ЧИСЛО &lt;--- НАЧАЛЬНОЕ ЗНАЧЕНИЕ
#  3) Вывести ЧИСЛО.
#  4)  Если ЧИСЛО четное, разделить на 2,
#  5)+ Если не четное -- умножить на 3 и прибавить 1.
#  6) ЧИСЛО &lt;--- РЕЗУЛЬТАТ
#  7) Повторить, начиная с п. 3, заданное число раз.
#
#  Теоретически, такая последовательность должна сходиться,
#+ не зависимо от величины начального значения,
#+ к повторению циклов &quot;4,2,1...&quot;,
#+ даже после значительных флуктуаций в самом начале.


MAX_ITERATIONS=200
# Для больших начальных значений (&gt;32000), это значение придется увеличить.

h=${1:-$$}                      #  Начальное значение
                                #  если из командной строки ничего не задано, то берется $PID,

echo
echo &quot;C($h) --- $MAX_ITERATIONS итераций&quot;
echo

for ((i=1; i&lt;=MAX_ITERATIONS; i++))
do

echo -n &quot;$h     &quot;
#          ^^^^^
#           табуляция

  let &quot;remainder = h % 2&quot;
  if [ &quot;$remainder&quot; -eq 0 ]   # Четное?
  then
    let &quot;h /= 2&quot;              # Разделить на 2.
  else
    let &quot;h = h*3 + 1&quot;         # Умножить на 3 и прибавить 1.
  fi


COLUMNS=10                    # Выводить по 10 значений в строке.
let &quot;line_break = i % $COLUMNS&quot;
if [ &quot;$line_break&quot; -eq 0 ]
then
  echo
fi

done

echo

exit 0
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="DAYSBETWEEN"></a>

          <p><strong>Пример A-8. days-between: Подсчет числа дней между
          двумя датами</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# days-between.sh:    Подсчет числа дней между двумя датами.
# Порядок использования: ./days-between.sh [M]M/[D]D/YYYY [M]M/[D]D/YYYY

ARGS=2                # Ожидается два аргумента из командной строки.
E_PARAM_ERR=65        # Ошибка в числе ожидаемых аргументов.

REFYR=1600            # Начальный год.
CENTURY=100
DIY=365
ADJ_DIY=367           # Корректировка на високосный год + 1.
MIY=12
DIM=31
LEAPCYCLE=4

MAXRETVAL=255         # Максимально возможное возвращаемое значение
                      # для положительных чисел.

diff=                         # Количество дней между датами.
value=                # Абсолютное значение.
day=                  # день, месяц, год.
month=
year=


Param_Error ()        # Ошибка в пвраметрах командной строки.
{
  echo &quot;Порядок использования: `basename $0` [M]M/[D]D/YYYY [M]M/[D]D/YYYY&quot;
  echo &quot;       (даты должны быть после 1/3/1600)&quot;
  exit $E_PARAM_ERR
}


Parse_Date ()                 # Разбор даты.
{
  month=${1%%/**}
  dm=${1%/**}                 # День и месяц.
  day=${dm#*/}
  let &quot;year = `basename $1`&quot;  # Хотя это и не имя файла, но результат тот же.
}


check_date ()                 # Проверка даты.
{
  [ &quot;$day&quot; -gt &quot;$DIM&quot; ] || [ &quot;$month&quot; -gt &quot;$MIY&quot; ] || [ &quot;$year&quot; -lt &quot;$REFYR&quot; ] &amp;&amp; Param_Error
  # Выход из сценария при обнаружении ошибки.
  # Используется комбинация &quot;ИЛИ-списка / И-списка&quot;.
  #
  # Упражнение: Реализуйте более строгую проверку даты.
}


strip_leading_zero () # Удалить ведущий ноль
{
  val=${1#0}          # иначе Bash будет считать числа
  return $val         # восьмеричными (POSIX.2, sect 2.9.2.1).
}


day_index ()          # Формула Гаусса:
{                     # Количество дней от 3 Янв. 1600 до заданной даты.

  day=$1
  month=$2
  year=$3

  let &quot;month = $month - 2&quot;
  if [ &quot;$month&quot; -le 0 ]
  then
    let &quot;month += 12&quot;
    let &quot;year -= 1&quot;
  fi

  let &quot;year -= $REFYR&quot;
  let &quot;indexyr = $year / $CENTURY&quot;


  let &quot;Days = $DIY*$year + $year/$LEAPCYCLE - $indexyr + $indexyr/$LEAPCYCLE + $ADJ_DIY*$month/$MIY + $day - $DIM&quot;
  # Более подробное объяснение алгоритма вы найдете в
  # http://home.t-online.de/home/berndt.schwerdtfeger/cal.htm


  if [ &quot;$Days&quot; -gt &quot;$MAXRETVAL&quot; ]  # Если больше 255,
  then                             # то поменять знак
    let &quot;dindex = 0 - $Days&quot;       # чтобы функция смогла вернуть полное значение.
  else let &quot;dindex = $Days&quot;
  fi

  return $dindex

}


calculate_difference ()            # Разница между двумя датами.
{
  let &quot;diff = $1 - $2&quot;             # Глобальная переменная.
}


abs ()                             # Абсолютное значение
{                                  # Используется глобальная переменная &quot;value&quot;.
  if [ &quot;$1&quot; -lt 0 ]                # Если число отрицательное
  then                             # то
    let &quot;value = 0 - $1&quot;           # изменить знак,
  else                             # иначе
    let &quot;value = $1&quot;               # оставить как есть.
  fi
}



if [ $# -ne &quot;$ARGS&quot; ]              # Требуется два аргумента командной строки.
then
  Param_Error
fi

Parse_Date $1
check_date $day $month $year      # Проверка даты.

strip_leading_zero $day           # Удалить ведущие нули
day=$?                            # в номере дня и/или месяца.
strip_leading_zero $month
month=$?

day_index $day $month $year
date1=$?

abs $date1                         # Абсолютное значение
date1=$value

Parse_Date $2
check_date $day $month $year

strip_leading_zero $day
day=$?
strip_leading_zero $month
month=$?

day_index $day $month $year
date2=$?

abs $date2                         # Абсолютное значение
date2=$value

calculate_difference $date1 $date2

abs $diff                          # Абсолютное значение
diff=$value

echo $diff

exit 0
# Сравните этот сценарий с реализацией формулы Гаусса на C
# http://buschencrew.hypermart.net/software/datedif
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="MAKEDICT"></a>

          <p><strong>Пример A-9. Создание <span
           class="QUOTE">&quot;словаря&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# makedict.sh  [создание словаря]

# Модификация сценария /usr/sbin/mkdict.
# Авторские права на оригинальный сценарий принадлежат Alec Muffett.
#
#  Этот модифицированный вариант включен в документ на основе
#+ документа &quot;LICENSE&quot; из пакета &quot;Crack&quot;
#+ с которым распространяется оригинальный сценарий.

#  Этот скрипт обрабатывает текстовые файлы и создает отсортированный список
#+ слов, найденных в этих файлах.
#  Он может оказаться полезным для сборки словарей
#+ и проведения лексикографического анализа.


E_BADARGS=65

if [ ! -r &quot;$1&quot; ]                     #  Необходим хотя бы один аргумент --
then                                 #+ имя файла.
  echo &quot;Порядок использования: $0 имена_файлов&quot;
  exit $E_BADARGS
fi


# SORT=&quot;sort&quot;                        #  Необходимость задания ключей сортировки отпала.
                                     #+ Изменено, по отношению к оригинальному сценарию.

cat $* |                             # Выдать содержимое файлов на stdout.
        tr A-Z a-z |                 # Преобразовать в нижний регистр.
        tr &#39; &#39; &#39;\012&#39; |              # Новое: заменить пробелы символами перевода строки.
#       tr -cd &#39;\012[a-z][0-9]&#39; |    #  В оригинальном сценарии: удалить все символы,
                                     #+ которые не являются буквами или цифрами.
        tr -c &#39;\012a-z&#39;  &#39;\012&#39; |    #  Вместо удаления
                                     #+ неалфавитно-цифровые символы заменяются на перевод строки.
        sort |
        uniq |                       # Удалить повторяющиеся слова.
        grep -v &#39;^#&#39; |               # Удалить строки, начинающиеся с &quot;#&quot;.
        grep -v &#39;^$&#39;                 # Удалить пустые строки.

exit 0
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="SOUNDEX"></a>

          <p><strong>Пример A-10. Расчет индекса
          &quot;созвучности&quot;</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# soundex.sh: Расчет индекса &quot;созвучности&quot;

# =======================================================
#       Сценарий Soundex
#            Автор
#         Mendel Cooper
#     thegrendel@theriver.com
#       23 Января 2002 г.
#
#   Условия распространения: Public Domain.
#
# Несколько отличающаяся версия этого сценария была опубликована
#+ Эдом Шэфером (Ed Schaefer) в Июле 2002 года в колонке &quot;Shell Corner&quot;
#+ &quot;Unix Review&quot; on-line,
#+ http://www.unixreview.com/documents/uni1026336632258/
# =======================================================


ARGCOUNT=1                     # Требуется аргумент командной строки.
E_WRONGARGS=70

if [ $# -ne &quot;$ARGCOUNT&quot; ]
then
  echo &quot;Порядок использования: `basename $0` имя&quot;
  exit $E_WRONGARGS
fi


assign_value ()                #  Присвоить числовые значения
{                              #+ символам в имени.

  val1=bfpv                    # &#39;b,f,p,v&#39; = 1
  val2=cgjkqsxz                # &#39;c,g,j,k,q,s,x,z&#39; = 2
  val3=dt                      #  и т.п.
  val4=l
  val5=mn
  val6=r

# Попробуйте разобраться в том, что здесь происходит.

value=$( echo &quot;$1&quot; \
| tr -d wh \
| tr $val1 1 | tr $val2 2 | tr $val3 3 \
| tr $val4 4 | tr $val5 5 | tr $val6 6 \
| tr -s 123456 \
| tr -d aeiouy )

# Символам в имени присваиваются числовые значения.
# Удаляются повторяющиеся числа, если они не разделены гласными.
# Гласные игнорируются, если они не являются разделителями, которые удаляются в последнюю очередь.
# Символы &#39;w&#39; и &#39;h&#39; удаляются в первую очередь.
}


input_name=&quot;$1&quot;
echo
echo &quot;Имя = $input_name&quot;


# Перевести все символы в имени в нижний регистр.
# ------------------------------------------------
name=$( echo $input_name | tr A-Z a-z )
# ------------------------------------------------


# Начальный символ в индекса &quot;созвучия&quot;: первая буква в имени.
# --------------------------------------------


char_pos=0                     # Начальная позиция в имени.
prefix0=${name:$char_pos:1}
prefix=`echo $prefix0 | tr a-z A-Z`
                               # Первую букву в имени -- в верхний регистр.

let &quot;char_pos += 1&quot;            # Передвинуть &quot;указатель&quot; на один символ.
name1=${name:$char_pos}


# ++++++++++++++++++++++++++++ Исключение отдельных ситуаций +++++++++++++++++++++++++++++++
#  Теперь мы передвинулись на один символ вправо.
#  Если второй символ в имени совпадает с первым
#+ то его нужно отбросить.
#  Кроме того, мы должны проверить -- не является ли первый символ
#+ гласной, &#39;w&#39; или &#39;h&#39;.

char1=`echo $prefix | tr A-Z a-z`    # Первый символ -- в нижний регистр.

assign_value $name
s1=$value
assign_value $name1
s2=$value
assign_value $char1
s3=$value
s3=9$s3                              #  Если первый символ в имени -- гласная буква
                                     #+ или &#39;w&#39; или &#39;h&#39;,
                                     #+ то ее &quot;значение&quot; нужно отбросить.
                                     #+ Поэтому ставим 9, или другое
                                     #+ неиспользуемое значение, которое можно будет проверить.


if [[ &quot;$s1&quot; -ne &quot;$s2&quot; || &quot;$s3&quot; -eq 9 ]]
then
  suffix=$s2
else
  suffix=${s2:$char_pos}
fi
# ++++++++++++++++++++++++ Конец исключения отдельных ситуаций +++++++++++++++++++++++++++++++


padding=000                    # Дополнить тремя нулями.


soun=$prefix$suffix$padding    # Нули добавить в конец получившегося индекса.

MAXLEN=4                       # Ограничить длину индекса 4-мя символами.
soundex=${soun:0:$MAXLEN}

echo &quot;Индекс созвучия = $soundex&quot;

echo

#  Индекс &quot;созвучия&quot; - это метод индексации и классификации имен
#+ по подобию звучания.
#  Индекс &quot;созвучия&quot; начинается с первого символа в имени,
#+ за которым следуют 3-значный расчетный код.
#  Имена, которые произносятся примерно одинаково, имеют близкие индексы &quot;созвучия&quot;.

#   Например:
#   Smith и Smythe -- оба имеют индекс &quot;созвучия&quot; &quot;S530&quot;.
#   Harrison = H625
#   Hargison = H622
#   Harriman = H655

#  Как правило эта методика дает неплохой результат, но имеются и аномалии.
#
#
#  Дополнительную информацию вы найдете на
#+ &quot;National Archives and Records Administration home page&quot;,
#+ http://www.nara.gov/genealogy/soundex/soundex.html



# Упражнение:
# ----------
# Упростите блок &quot;Исключение отдельных ситуаций&quot; .

exit 0
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="LIFESLOW"></a>

          <p><strong>Пример A-11. <span
           class="QUOTE">&quot;Игра
          &quot;Жизнь&quot;&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# life.sh: Игра &quot;Жизнь&quot;

# ##################################################################### #
# Это Bash-версия известной игры Джона Конвея (John Conway) &quot;Жизнь&quot;.    #
# --------------------------------------------------------------------- #
# Прямоугольное игровое поле разбито на ячейки, в каждой ячейке может   #
#+ располагаться живая особь.                                           #
# Соответственно, ячейка с живой особью отмечается точкой,              #
#+ не занятая ячейка -- остается пустой.                                #
#  Изначально, ячейки заполняются из файла --                           #
#+ это первое поколение, или &quot;поколение 0&quot;                              #
# Воспроизводство особей, в каждом последующем поколении,               #
#+ определяется следующими правилами                                    #
# 1) Каждая ячейка имеет &quot;соседей&quot;                                      #
#+   слева, справа, сверху, снизу и 4 по диагоналям.                    #
#                       123                                             #
#                       4*5                                             #
#                       678                                             #
#                                                                       #
# 2) Если живая особь имеет 2 или 3 живых соседей, то она остается жить.#
# 3) Если пустая ячейка имеет 3 живых соседей --                        #
#+   в ней &quot;рождается&quot; новая особь                                      #
SURVIVE=2                                                               #
BIRTH=3                                                                 #
# 4) В любом другом случае, живая особь &quot;погибает&quot;                      #
# ##################################################################### #


startfile=gen0   # Начальное поколение из файла по-умолчанию -- &quot;gen0&quot;.
                 # если не задан другой файл, из командной строки.
                 #
if [ -n &quot;$1&quot; ]   # Проверить аргумент командной строки -- файл с &quot;поколениемn 0&quot;.
then
  if [ -e &quot;$1&quot; ] # Проверка наличия файла.
  then
    startfile=&quot;$1&quot;
  fi
fi


ALIVE1=.
DEAD1=_
                 # Представление &quot;живых&quot; особей и пустых ячеек в файле с &quot;поколением 0&quot;.

#  Этот сценарий работает с игровым полем 10 x 10 grid (может быть увеличено,
#+ но большое игровое поле будет обрабатываться очень медленно).
ROWS=10
COLS=10

GENERATIONS=10          #  Максимальное число поколений.

NONE_ALIVE=80           #  Код завершения на случай,
                        #+ если не осталось ни одной &quot;живой&quot; особи.
TRUE=0
FALSE=1
ALIVE=0
DEAD=1

avar=                   # Текущее поколение.
generation=0            # Инициализация счетчика поколений.

# =================================================================


let &quot;cells = $ROWS * $COLS&quot;
                        # Количество ячеек на игровом поле.

declare -a initial      # Массивы ячеек.
declare -a current

display ()
{

alive=0                 # Количество &quot;живых&quot; особей.
                        # Изначально -- ноль.

declare -a arr
arr=( `echo &quot;$1&quot;` )     # Преобразовать аргумент в массив.

element_count=${#arr[*]}

local i
local rowcheck

for ((i=0; i&lt;$element_count; i++))
do

  # Символ перевода строки -- в конец каждой строки.
  let &quot;rowcheck = $i % ROWS&quot;
  if [ &quot;$rowcheck&quot; -eq 0 ]
  then
    echo                # Перевод строки.
    echo -n &quot;      &quot;    # Выравнивание.
  fi

  cell=${arr[i]}

  if [ &quot;$cell&quot; = . ]
  then
    let &quot;alive += 1&quot;
  fi

  echo -n &quot;$cell&quot; | sed -e &#39;s/_/ /g&#39;
  # Вывести массив, по пути заменяя символы подчеркивания на пробелы.
done

return

}

IsValid ()                            # Проверка корректности координат ячейки.
{

  if [ -z &quot;$1&quot;  -o -z &quot;$2&quot; ]          # Проверка наличия входных аргументов.
  then
    return $FALSE
  fi

local row
local lower_limit=0                   # Запрет на отрицательные координаты.
local upper_limit
local left
local right

let &quot;upper_limit = $ROWS * $COLS - 1&quot; # Номер последней ячейки на игровом поле.


if [ &quot;$1&quot; -lt &quot;$lower_limit&quot; -o &quot;$1&quot; -gt &quot;$upper_limit&quot; ]
then
  return $FALSE                       # Выход за границы массива.
fi

row=$2
let &quot;left = $row * $ROWS&quot;             # Левая граница.
let &quot;right = $left + $COLS - 1&quot;       # Правая граница.

if [ &quot;$1&quot; -lt &quot;$left&quot; -o &quot;$1&quot; -gt &quot;$right&quot; ]
then
  return $FALSE                       # Выхол за нижнюю строку.
fi

return $TRUE                          # Координаты корректны.

}


IsAlive ()              # Проверка наличия &quot;живой&quot; особи в ячейке.
                        # Принимает массив и номер ячейки в качестве входных аргументов.
{
  GetCount &quot;$1&quot; $2      # Подсчитать кол-во &quot;живых&quot; соседей.
  local nhbd=$?


  if [ &quot;$nhbd&quot; -eq &quot;$BIRTH&quot; ]  # &quot;Живая&quot;.
  then
    return $ALIVE
  fi

  if [ &quot;$3&quot; = &quot;.&quot; -a &quot;$nhbd&quot; -eq &quot;$SURVIVE&quot; ]
  then                  # &quot;Живая&quot; если перед этим была &quot;живая&quot;.
    return $ALIVE
  fi

  return $DEAD          # По-умолчанию.

}


GetCount ()             # Подсчет &quot;живых&quot; соседей.
                        # Необходимо 2 аргумента:
                        # $1) переменная-массив
                        # $2) cell номер ячейки
{
  local cell_number=$2
  local array
  local top
  local center
  local bottom
  local r
  local row
  local i
  local t_top
  local t_cen
  local t_bot
  local count=0
  local ROW_NHBD=3

  array=( `echo &quot;$1&quot;` )

  let &quot;top = $cell_number - $COLS - 1&quot;    # Номера соседних ячеек.
  let &quot;center = $cell_number - 1&quot;
  let &quot;bottom = $cell_number + $COLS - 1&quot;
  let &quot;r = $cell_number / $ROWS&quot;

  for ((i=0; i&lt;$ROW_NHBD; i++))           # Просмотр слева-направо.
  do
    let &quot;t_top = $top + $i&quot;
    let &quot;t_cen = $center + $i&quot;
    let &quot;t_bot = $bottom + $i&quot;


    let &quot;row = $r&quot;                        # Пройти по соседям в средней строке.
    IsValid $t_cen $row                   # Координаты корректны?
    if [ $? -eq &quot;$TRUE&quot; ]
    then
      if [ ${array[$t_cen]} = &quot;$ALIVE1&quot; ] # &quot;Живая&quot;?
      then                                # Да!
        let &quot;count += 1&quot;                  # Нарастить счетчик.
      fi
    fi

    let &quot;row = $r - 1&quot;                    # По верхней строке.
    IsValid $t_top $row
    if [ $? -eq &quot;$TRUE&quot; ]
    then
      if [ ${array[$t_top]} = &quot;$ALIVE1&quot; ]
      then
        let &quot;count += 1&quot;
      fi
    fi

    let &quot;row = $r + 1&quot;                    # По нижней строке.
    IsValid $t_bot $row
    if [ $? -eq &quot;$TRUE&quot; ]
    then
      if [ ${array[$t_bot]} = &quot;$ALIVE1&quot; ]
      then
        let &quot;count += 1&quot;
      fi
    fi

  done


  if [ ${array[$cell_number]} = &quot;$ALIVE1&quot; ]
  then
    let &quot;count -= 1&quot;        #  Убедиться, что сама проверяемая ячейка
  fi                        #+ не была подсчитана.


  return $count

}

next_gen ()               # Обновить массив, в котором содержится информация о новом &quot;поколении&quot;.
{

local array
local i=0

array=( `echo &quot;$1&quot;` )     # Преобразовать в массив.

while [ &quot;$i&quot; -lt &quot;$cells&quot; ]
do
  IsAlive &quot;$1&quot; $i ${array[$i]}   # &quot;Живая&quot;?
  if [ $? -eq &quot;$ALIVE&quot; ]
  then                           #  Если &quot;живая&quot;, то
    array[$i]=.                  #+ записать точку.
  else
    array[$i]=&quot;_&quot;                #  Иначе -- символ подчеркивания
   fi                            #+ (который позднее заменится на пробел).
  let &quot;i += 1&quot;
done


# let &quot;generation += 1&quot;   # Увеличить счетчик поколений.

# Подготовка переменных, для передачи в функцию &quot;display&quot;.
avar=`echo ${array[@]}`   # Преобразовать массив в строку.
display &quot;$avar&quot;           # Вывести его.
echo; echo
echo &quot;Поколение $generation -- живых особей $alive&quot;

if [ &quot;$alive&quot; -eq 0 ]
then
  echo
  echo &quot;Преждеверменное завершение: не осталось ни одной живой особи!&quot;
  exit $NONE_ALIVE        #  Нет смысла продолжать
fi                        #+ если не осталось ни одной живой особи

}


# =========================================================

# main ()

# Загрузить начальное поколение из файла.
initial=( `cat &quot;$startfile&quot; | sed -e &#39;/#/d&#39; | tr -d &#39;\n&#39; |\
sed -e &#39;s/\./\. /g&#39; -e &#39;s/_/_ /g&#39;` )
# Удалить строки, начинающиеся с символа &#39;#&#39; -- комментарии.
# Удалить строки перевода строки и вставить пробелы между элементами.

clear          # Очистка экрана.

echo #       Заголовок
echo &quot;=======================&quot;
echo &quot;    $GENERATIONS поколений&quot;
echo &quot;           в&quot;
echo &quot;      игре \&quot; ЖИЗНЬ\&quot;&quot;
echo &quot;=======================&quot;


# -------- Вывести первое поколение. --------
Gen0=`echo ${initial[@]}`
display &quot;$Gen0&quot;           # Тлько вывод.
echo; echo
echo &quot;Поколение $generation -- живых особей $alive&quot;
# -------------------------------------------


let &quot;generation += 1&quot;     # Нарастить счетчик поколений.
echo

# ------- Вывести второе поколение. -------
Cur=`echo ${initial[@]}`
next_gen &quot;$Cur&quot;          # Обновить и вывести.
# ------------------------------------------

let &quot;generation += 1&quot;     # Нарастить счетчик поколений.

# ------ Основной цикл игры ------
while [ &quot;$generation&quot; -le &quot;$GENERATIONS&quot; ]
do
  Cur=&quot;$avar&quot;
  next_gen &quot;$Cur&quot;
  let &quot;generation += 1&quot;
done
# ==============================================================

echo

exit 0

# --------------------------------------------------------------
# Этот сценарий имеет недоработку.
# Граничные ячейки сверху, снизу и сбоков  остаются пустыми.
# Упражнение: Доработайте сценарий таким образом, чтобы ,
# +         левая и правая стороны как бы &quot;соприкасались&quot;,
# +         так же и верхняя и нижняя стороны.
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="GEN0DATA"></a>

          <p><strong>Пример A-12. Файл с первым поколением для игры
          <span
           class="QUOTE">&quot;Жизнь&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
# Это файл-пример, содержащий &quot;поколение 0&quot;, для сценария &quot;life.sh&quot;.
# --------------------------------------------------------------
#  Игровое поле имеет размер 10 x 10, точкой обозначается &quot;живая&quot; особь,
#+ символом подчеркивания -- пустая ячейка. Мы не можем использовать пробелы,
#+ для обозначения пустых ячеек, из-за особенностей строения массивов в Bash.
#  [Упражнение для читателей: объясните, почему?.]
#
# Строки, начинающиеся с символа &#39;#&#39; считаются комментариями, сценарий их игнорирует.
__.__..___
___._.____
____.___..
_._______.
____._____
..__...___
____._____
___...____
__.._..___
_..___..__
</pre>
        </div>

        <p>+++</p>

        <p>Следующие два сценария предоставил Mark Moraes, из
        университета в Торонто. См. файл <span
         class="QUOTE">&quot;Moraes-COPYRIGHT&quot;</span>, который
        содержит указание на авторские права.</p>

        <div
         class="EXAMPLE">
          <a
           name="BEHEAD"></a>

          <p><strong>Пример A-13. behead: Удаление заголовков из
          электронных писем и новостей</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/sh
# Удаление заголовков из электронных писем и новостей т.е. до первой
# пустой строки
# Mark Moraes, Университет в Торонто

# ==&gt; Такие комментарии добавлены автором документа.

if [ $# -eq 0 ]; then
# ==&gt; Если входной аргумент не задан (файл), то выводить результат на stdin.
        sed -e &#39;1,/^$/d&#39; -e &#39;/^[        ]*$/d&#39;
        # --&gt; Удалить пустые строки и все строки предшествующие им
else
# ==&gt; Если аргумент командной строки задан, то использовать его как имя файла.
        for i do
                sed -e &#39;1,/^$/d&#39; -e &#39;/^[        ]*$/d&#39; $i
                # --&gt; То же, что и выше.
        done
fi

# ==&gt; Упражнение: Добавьте проверку на наличие ошибок.
# ==&gt;
# ==&gt; Обратите внимание -- как похожи маленькие сценарии sed, за исключением передачи аргумента.
# ==&gt; Можно ли его оформит в виде функции? Почему да или почему нет?
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="FTPGET"></a>

          <p><strong>Пример A-14. ftpget: Скачивание файлов по
          ftp</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/sh
# $Id: ftpget,v 1.2 91/05/07 21:15:43 moraes Exp $
# Сценарий устанавливает анонимное соединение с ftp-сервером.
# Простой и быстрый - написан как дополнение к ftplist
# -h -- удаленный сервер (по-умолчанию prep.ai.mit.edu)
# -d -- каталог на сервере - вы можете указать последовательность из нескольких ключей -d
# Если вы используете относительные пути,
# будьте внимательны при задании последовательности.
# (по-умолчанию -- каталог пользователя ftp)
# -v -- &quot;многословный&quot; режим, будет показывать все ответы ftp-сервера
# -f -- file[:localfile] скачивает удаленный file и записывает под именем localfile
# -m -- шаблон для mget. Не забудьте взять в кавычки!
# -c -- локальный каталог
# Например,
#       ftpget -h expo.lcs.mit.edu -d contrib -f xplaces.shar:xplaces.sh \
#               -d ../pub/R3/fixes -c ~/fixes -m &#39;fix*&#39;
# Эта команда загрузит файл xplaces.shar из ~ftp/contrib с expo.lcs.mit.edu
# и сохранит под именем xplaces.sh в текущем каталоге, затем заберет все исправления (fixes)
# из ~ftp/pub/R3/fixes и поместит их в каталог ~/fixes.
# Очевидно, что последовательность ключей и аргументов очень важна, поскольку
# она определяет последовательность операций, выполняемых с удаленным ftp-сервером
#
# Mark Moraes (moraes@csri.toronto.edu), Feb 1, 1989
#


# ==&gt; Эти комментарии добавлены автором документа.

# PATH=/local/bin:/usr/ucb:/usr/bin:/bin
# export PATH
# ==&gt; Первые две строки в оригинальном сценарии вероятно излишни.

TMPFILE=/tmp/ftp.$$
# ==&gt; Создан временный файл

SITE=`domainname`.toronto.edu
# ==&gt; &#39;domainname&#39; подобен &#39;hostname&#39;

usage=&quot;Порядок использования: $0 [-h удаленный_сервер] [-d удаленный_каталог]... [-f удаленный_файл:локальный_файл]... \
                [-c локальный_каталог] [-m шаблон_имен_файлов] [-v]&quot;
ftpflags=&quot;-i -n&quot;
verbflag=
set -f          # разрешить подстановку имен файлов (globbing) для опции -m
set x `getopt vh:d:c:m:f: $*`
if [ $? != 0 ]; then
        echo $usage
        exit 65
fi
shift
trap &#39;rm -f ${TMPFILE} ; exit&#39; 0 1 2 3 15
echo &quot;user anonymous ${USER-gnu}@${SITE} &gt; ${TMPFILE}&quot;
# ==&gt; Добавлены кавычки (рекомендуется).
echo binary &gt;&gt; ${TMPFILE}
for i in $*   # ==&gt; Разбор командной строки.
do
        case $i in
        -v) verbflag=-v; echo hash &gt;&gt; ${TMPFILE}; shift;;
        -h) remhost=$2; shift 2;;
        -d) echo cd $2 &gt;&gt; ${TMPFILE};
            if [ x${verbflag} != x ]; then
                echo pwd &gt;&gt; ${TMPFILE};
            fi;
            shift 2;;
        -c) echo lcd $2 &gt;&gt; ${TMPFILE}; shift 2;;
        -m) echo mget &quot;$2&quot; &gt;&gt; ${TMPFILE}; shift 2;;
        -f) f1=`expr &quot;$2&quot; : &quot;\([^:]*\).*&quot;`; f2=`expr &quot;$2&quot; : &quot;[^:]*:\(.*\)&quot;`;
            echo get ${f1} ${f2} &gt;&gt; ${TMPFILE}; shift 2;;
        --) shift; break;;
        esac
done
if [ $# -ne 0 ]; then
        echo $usage
        exit 65   # ==&gt; В оригинале было &quot;exit 2&quot;, изменено в соответствии со стандартами.
fi
if [ x${verbflag} != x ]; then
        ftpflags=&quot;${ftpflags} -v&quot;
fi
if [ x${remhost} = x ]; then
        remhost=prep.ai.mit.edu
        # ==&gt; Здесь можете указать свой ftp-сервер по-умолчанию.
fi
echo quit &gt;&gt; ${TMPFILE}
# ==&gt; Все команды сохранены во временном файле.

ftp ${ftpflags} ${remhost} &lt; ${TMPFILE}
# ==&gt; Теперь обработать пакетный файл.

rm -f ${TMPFILE}
# ==&gt; В заключение, удалить временный файл (можно скопировать его в системный журнал).


# ==&gt; Упражнения:
# ==&gt; ----------
# ==&gt; 1) Добавьте обработку ошибок.
# ==&gt; 2) Добавьте уведомление звуковым сигналом.
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="MORCOPY"></a>

          <p><strong>Пример A-15. Указание на авторские
          права</strong></p>
<pre
 class="PROGRAMLISTING">
Следующее соглащение об авторских правах относится к двум, включенным в книгу,
сценариям от Mark Moraes: &quot;behead.sh&quot; и &quot;ftpget.sh&quot;

/*
 * Copyright University of Toronto 1988, 1989.
 * Автор: Mark Moraes
 *
 * Автор дает право на использование этого программного обеспечения
 * его изменение и рапространение со следующими ограничениями:
 *
 * 1. Автор и Университет Торонто не отвечают
 *    за последствия использования этого программного обеспечения,
 *    какими ужасными бы они ни были,
 *    даже если они вызваны ошибками в нем.
 *
 * 2. Указание на происхождение программного обеспечения не должно подвергаться изменениям,
 *    явно или по оплошности. Так как некоторые пользователи обращаются к исходным текстам,
 *    они обязательно должны быть включены в документацию.
 *
 * 3. Измененная версия должна содержать явное упоминание об этом и не должна
 *    выдаваться за оригинал. Так как некоторые пользователи обращаются к исходным текстам,
 *    они обязательно должны быть включены в документацию.
 *
 * 4. Это соглашение не может удаляться и/или изменяться.
 */
</pre>
        </div>

        <p>+</p>

        <p>Antek Sawicki предоставил следующий сценарий, который
        демонстрирует операцию подстановки параметров, обсуждавшуюся в
        <a
         href="#PARAMETER-SUBSTITUTION">Section 9.3</a>.</p>

        <div
         class="EXAMPLE">
          <a
           name="PW"></a>

          <p><strong>Пример A-16. password: Генератор случайного 8-ми
          символьного пароля</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Для старых систем может потребоваться указать  #!/bin/bash2.
#
# Генератор случайных паролей для bash 2.x
# Автор: Antek Sawicki &lt;tenox@tenox.tc&gt;,
# который великодушно позволил использовать его в данном документе.
#
# ==&gt; Комментарии, добавленные автором документа ==&gt;


MATRIX=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;
LENGTH=&quot;8&quot;
# ==&gt; &#39;LENGTH&#39; можно увеличить, для генерации более длинных паролей.


while [ &quot;${n:=1}&quot; -le &quot;$LENGTH&quot; ]
# ==&gt; Напоминаю, что &quot;:=&quot; -- это оператор &quot;подстановки значения по-умолчанию&quot;.
# ==&gt; Таким образом, если &#39;n&#39; не инициализирована, то в нее заносится 1.
do
        PASS=&quot;$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}&quot;
        # ==&gt; Хитро, хитро....

        # ==&gt; Начнем с самых внутренних скобок...
        # ==&gt; ${#MATRIX} -- возвращает длину массива MATRIX.

        # ==&gt; $RANDOM%${#MATRIX} -- возвращает случайное число
        # ==&gt; в диапазоне 1 .. ДЛИНА_МАССИВА(MATRIX) - 1.

        # ==&gt; ${MATRIX:$(($RANDOM%${#MATRIX})):1}
        # ==&gt; возвращает символ из MATRIX, из случайной позиции (найденной выше).
        # ==&gt; См. подстановку параметров {var:pos:len} в Разделе 3.3.1
        # ==&gt; и примеры в этом разделе.

        # ==&gt; PASS=... -- добавление символа к строке PASS, полученной на предыдущих итерациях.

        # ==&gt; Чтобы детальнее проследить ход работы цикла, раскомментируйте следующую строку
        # ==&gt;             echo &quot;$PASS&quot;
        # ==&gt; Вы увидите, как на каждом проходе цикла,
        # ==&gt; к строке PASS добавляется по одному символу.

        let n+=1
        # ==&gt; Увеличить &#39;n&#39; перед началом следующей итерации.
done

echo &quot;$PASS&quot;      # ==&gt; Или перенаправьте в файл, если пожелаете.

exit 0
</pre>
        </div>

        <p>+</p>

        <p>James R. Van Zandt предоставил следующий сценарий, который
        демонстрирует применение именованных каналов, по его словам,
        <span
         class="QUOTE">&quot;на самом деле -- упражнение на применение
        кавычек и на экранирование&quot;</span>.</p>

        <div
         class="EXAMPLE">
          <a
           name="FIFO"></a>

          <p><strong>Пример A-17. fifo: Создание резервных копий с
          помощью именованных каналов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# ==&gt; Автор:James R. Van Zandt
# ==&gt; используется с его разрешения.

# ==&gt; Комментарии, добавленные автором документа.


  HERE=`uname -n`    # ==&gt; hostname
  THERE=bilbo
  echo &quot;начало создания резервной копии на $THERE, за `date +%r`&quot;
  # ==&gt; `date +%r` возвращает время в 12-ти часовом формате, т.е. &quot;08:08:34 PM&quot;.

  # убедиться в том, что /pipe -- это действительно канал, а не простой файл
  rm -rf /pipe
  mkfifo /pipe       # ==&gt; Создание &quot;именованного канала&quot;, с именем &quot;/pipe&quot;.

  # ==&gt; &#39;su xyz&#39; -- запускает команду от имени порльзователя &quot;xyz&quot;.
  # ==&gt; &#39;ssh&#39; -- вызов secure shell (вход на удаленную систему).
  su xyz -c &quot;ssh $THERE \&quot;cat &gt;/home/xyz/backup/${HERE}-daily.tar.gz\&quot; &lt; /pipe&quot;&amp;
  cd /
  tar -czf - bin boot dev etc home info lib man root sbin share usr var &gt;/pipe
  # ==&gt; Именованный канал /pipe, используется для передачи данных между процессами:
  # ==&gt; &#39;tar/gzip&#39; пишет в /pipe, а &#39;ssh&#39; -- читает из /pipe.

  # ==&gt; В результате будет получена резервная копия всех основных каталогов.

  # ==&gt; В чем состоит преимущество именованного канала, в данной ситуации,
        # ==&gt; перед неименованным каналом &quot;|&quot; ?
  # ==&gt; Будет ли работать неименованный канал в данной ситуации?


  exit 0
</pre>
        </div>

        <p>+</p>

        <p>Stephane Chazelas предоставил следующий сценарий, который
        демонстрирует возможность генерации простых чисел без
        использования массивов.</p>

        <div
         class="EXAMPLE">
          <a
           name="PRIMES"></a>

          <p><strong>Пример A-18. Генерация простых чисел, с
          использованием оператора деления по модулю (остаток от
          деления)</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# primes.sh: Генерация простых чисел, без использования массивов.
# Автор: Stephane Chazelas.

#  Этот сценарий не использует класический алгоритм &quot;Решето Эратосфена&quot;,
#+ вместо него используется более понятный метод проверки каждого кандидата в простые числа
#+ путем поиска делителей, с помощью оператора нахождения остатка от деления &quot;%&quot;.


LIMIT=1000                    # Простые от 2 до 1000

Primes()
{
 (( n = $1 + 1 ))             # Перейти к следующему числу.
 shift                        # Следующий параметр в списке.
#  echo &quot;_n=$n i=$i_&quot;

 if (( n == LIMIT ))
 then echo $*
 return
 fi

 for i; do                    # &quot;i&quot; устанавливается в &quot;@&quot;, предыдущее значение $n.
#   echo &quot;-n=$n i=$i-&quot;
   (( i * i &gt; n )) &amp;&amp; break   # Оптимизация.
   (( n % i )) &amp;&amp; continue    # Отсечь составное число с помощью оператора &quot;%&quot;.
   Primes $n $@               # Рекурсивный вызов внутри цикла.
   return
   done

   Primes $n $@ $n            # Рекурсивный вызов за пределами цикла.
                              # Последовательное накопление позиционных параметров.
                              # в &quot;$@&quot; накапливаются простые числа.
}

Primes 1

exit 0

# Раскомментарьте строки 16 и 24, это поможет понять суть происходящего.

# Сравните скоростные характеристики этого сценария и сценария (ex68.sh),
# реализующего алгоритм &quot;Решето Эратосфена&quot;.

# Упражнение: Попробуйте реализовать этот сценарий без использования рекурсии.
#             Это даст некоторый выигрыш в скорости.
</pre>
        </div>

        <p>+</p>

        <p>Jordi Sanfeliu дал согласие на публикацию своего сценария
        <span
         class="emphasis"><em
         class="EMPHASIS">tree</em></span>.</p>

        <div
         class="EXAMPLE">
          <a
           name="TREE"></a>

          <p><strong>Пример A-19. tree: Вывод дерева
          каталогов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/sh
#         @(#) tree      1.1  30/11/95       by Jordi Sanfeliu
#                                         email: mikaku@fiwix.org
#
#         Начальная версия:  1.0  30/11/95
#         Следующая версия:  1.1  24/02/97   Now, with symbolic links
#         Исправления     :  Ian Kjos, поддержка недоступных каталогов
#                           email: beth13@mail.utexas.edu
#
#         Tree -- средство просмотра дерева каталогов (очевидно :-) )
#

# ==&gt; Используется в данном документе с разрешения автора сценария, Jordi Sanfeliu.
# ==&gt; Комментарии, добавленные автором документа.
# ==&gt; Добавлено &quot;окавычивание&quot; аргументов.


search () {
   for dir in `echo *`
   # ==&gt; `echo *` список всех файлов в текущем каталоге, без символов перевода строки.
   # ==&gt; Тот же эффект дает     for dir in *
   # ==&gt; но &quot;dir in `echo *`&quot; не обрабатывет файлы, чьи имена содержат пробелы.
   do
      if [ -d &quot;$dir&quot; ] ; then   # ==&gt; Если это каталог (-d)...
         zz=0   # ==&gt; Временная переменная, для сохранения уровня вложенности каталога.
         while [ $zz != $deep ]    # Keep track of inner nested loop.
         do
            echo -n &quot;|   &quot;    # ==&gt; Показать символ вертикальной связи,
                              # ==&gt; с 2 пробелами и без перевода строки.
            zz=`expr $zz + 1` # ==&gt; Нарастить zz.
         done
         if [ -L &quot;$dir&quot; ] ; then   # ==&gt; Если символическая ссылка на каталог...
            echo &quot;+---$dir&quot; `ls -l $dir | sed &#39;s/^.*&#39;$dir&#39; //&#39;`
            # ==&gt; Показать горизонтальный соединитель и имя связянного каталога, но...
            # ==&gt; без указания даты/времени.
         else
            echo &quot;+---$dir&quot;      # ==&gt; Вывести горизонтальный соединитель...
                                 # ==&gt; и название каталога.
            if cd &quot;$dir&quot; ; then  # ==&gt; Если можно войти в каталог...
               deep=`expr $deep + 1`   # ==&gt; Нарастить уровень вложенности.
               search     # рекурсия ;-)
               numdirs=`expr $numdirs + 1`   # ==&gt; Нарастить счетчик каталогов.
            fi
         fi
      fi
   done
   cd ..   # ==&gt; Подняться на один уровень вверх.
   if [ &quot;$deep&quot; ] ; then  # ==&gt; Если depth = 0 (возвращает TRUE)...
      swfi=1              # ==&gt; выставить признак окончания поиска.
   fi
   deep=`expr $deep - 1`  # ==&gt; Уменьшить уровень вложенности.
}

# - Main -
if [ $# = 0 ] ; then
   cd `pwd`    # ==&gt; Если аргумент командной строки отсутствует, то используется текущий каталог.
else
   cd $1       # ==&gt; иначе перейти в заданный каталог.
fi
echo &quot;Начальный каталог = `pwd`&quot;
swfi=0      # ==&gt; Признак завершения поиска.
deep=0      # ==&gt; Уровень вложенности.
numdirs=0
zz=0

while [ &quot;$swfi&quot; != 1 ]   # Пока поиск не закончен...
do
   search   # ==&gt; Вызвать функцию поиска.
done
echo &quot;Всего каталогов = $numdirs&quot;

exit 0
# ==&gt; Попробуйте разобраться в том как этот сценарий работает.
</pre>
        </div>

        <p>Noah Friedman дал разрешение на публикацию своей библиотеки
        <span
         class="emphasis"><em
         class="EMPHASIS">функций для работы со строками</em></span>,
        которая, по сути, воспроизводит некоторые библиотечные функции
        языка C.</p>

        <div
         class="EXAMPLE">
          <a
           name="STRING"></a>

          <p><strong>Пример A-20. Функции для работы со
          строками</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# string.bash --- эмуляция библиотеки функций string(3)
# Автор: Noah Friedman &lt;friedman@prep.ai.mit.edu&gt;
# ==&gt;     Используется с его разрешения.
# Дата создания: 1992-07-01
# Дата последней модификации: 1993-09-29
# Public domain

# Преобразование в синтаксис bash v2 выполнил Chet Ramey

# Комментарий:
# Код:

#:docstring strcat:
# Порядок использования: strcat s1 s2
#
# Strcat добавляет содержимое переменной s2 к переменной s1.
#
# Пример:
#    a=&quot;foo&quot;
#    b=&quot;bar&quot;
#    strcat a b
#    echo $a
#    =&gt; foobar
#
#:end docstring:

###;;;autoload
function strcat ()
{
    local s1_val s2_val

    s1_val=${!1}                        # косвенная ссылка
    s2_val=${!2}
    eval &quot;$1&quot;=\&#39;&quot;${s1_val}${s2_val}&quot;\&#39;
    # ==&gt; eval $1=&#39;${s1_val}${s2_val}&#39; во избежание проблем,
    # ==&gt; если одна из переменных содержит одиночную кавычку.
}

#:docstring strncat:
# Порядок использования: strncat s1 s2 $n
#
# Аналог strcat, но добавляет не более n символов из
# переменной s2. Результат выводится на stdout.
#
# Пример:
#    a=foo
#    b=barbaz
#    strncat a b 3
#    echo $a
#    =&gt; foobar
#
#:end docstring:

###;;;autoload
function strncat ()
{
    local s1=&quot;$1&quot;
    local s2=&quot;$2&quot;
    local -i n=&quot;$3&quot;
    local s1_val s2_val

    s1_val=${!s1}                       # ==&gt; косвенная ссылка
    s2_val=${!s2}

    if [ ${#s2_val} -gt ${n} ]; then
       s2_val=${s2_val:0:$n}            # ==&gt; выделение подстроки
    fi

    eval &quot;$s1&quot;=\&#39;&quot;${s1_val}${s2_val}&quot;\&#39;
    # ==&gt; eval $1=&#39;${s1_val}${s2_val}&#39; во избежание проблем,
    # ==&gt; если одна из переменных содержит одиночную кавычку.
}

#:docstring strcmp:
# Порядок использования: strcmp $s1 $s2
#
# Strcmp сравнивает две строки и возвращает число меньше, равно
# или больше нуля, в зависимости от результатов сравнения.
#:end docstring:

###;;;autoload
function strcmp ()
{
    [ &quot;$1&quot; = &quot;$2&quot; ] &amp;&amp; return 0

    [ &quot;${1}&quot; &#39;&lt;&#39; &quot;${2}&quot; ] &gt; /dev/null &amp;&amp; return -1

    return 1
}

#:docstring strncmp:
# Порядок использования: strncmp $s1 $s2 $n
#
# Подобна strcmp, но сравнивает не более n символов
#:end docstring:

###;;;autoload
function strncmp ()
{
    if [ -z &quot;${3}&quot; -o &quot;${3}&quot; -le &quot;0&quot; ]; then
       return 0
    fi

    if [ ${3} -ge ${#1} -a ${3} -ge ${#2} ]; then
       strcmp &quot;$1&quot; &quot;$2&quot;
       return $?
    else
       s1=${1:0:$3}
       s2=${2:0:$3}
       strcmp $s1 $s2
       return $?
    fi
}

#:docstring strlen:
# Порядок использования: strlen s
#
# возвращает количество символов в строке s.
#:end docstring:

###;;;autoload
function strlen ()
{
    eval echo &quot;\${#${1}}&quot;
    # ==&gt; Возвращает длину переменной,
    # ==&gt; чье имя передается как аргумент.
}

#:docstring strspn:
# Порядок использования: strspn $s1 $s2
#
# Strspn возвращает максимальную длину сегмента в строке s1,
# который полностью состоит из символов строки s2.
#:end docstring:

###;;;autoload
function strspn ()
{
    # Сброс содержимого переменной IFS позволяет обрабатывать пробелы как обычные символы.
    local IFS=
    local result=&quot;${1%%[!${2}]*}&quot;

    echo ${#result}
}

#:docstring strcspn:
# Порядок использования: strcspn $s1 $s2
#
# Strcspn возвращает максимальную длину сегмента в строке s1,
# который полностью не содержит символы из строки s2.
#:end docstring:

###;;;autoload
function strcspn ()
{
    # Сброс содержимого переменной IFS позволяет обрабатывать пробелы как обычные символы.
    local IFS=
    local result=&quot;${1%%[${2}]*}&quot;

    echo ${#result}
}

#:docstring strstr:
# Порядок использования: strstr s1 s2
#
# Strstr выводит подстроку первого вхождения строки s2
# в строке s1, или ничего не выводит, если подстрока s2 в строке s1 не найдена.
# Если s2 содержит строку нулевой длины, то strstr выводит строку s1.
#:end docstring:

###;;;autoload
function strstr ()
{
    # Если s2 -- строка нулевой длины, то вывести строку s1
    [ ${#2} -eq 0 ] &amp;&amp; { echo &quot;$1&quot; ; return 0; }

    # не выводить ничего, если s2 не найдена в s1
    case &quot;$1&quot; in
    *$2*) ;;
    *) return 1;;
    esac

    # использовать шаблон, для удаления всех несоответствий после s2 в s1
    first=${1/$2*/}

    # Затем удалить все несоответствия с начала строки
    echo &quot;${1##$first}&quot;
}

#:docstring strtok:
# Порядок использования: strtok s1 s2
#
# Strtok рассматривает строку s1, как последовательность из 0, или более,
# лексем (токенов), разделенных символами строки s2
# При первом вызове (с непустым аргументом s1)
# выводит первую лексему на stdout.
# Функция запоминает свое положение в строке s1 от вызова к вызову,
# так что последующие вызовы должны производиться с пустым первым аргументом,
# чтобы продолжить выделение лексем из строки s1.
# После вывода последней лексемы, все последующие вызовы будут выводить на stdout
# пустое значение. Строка-разделитель может изменяться от вызова к вызову.
#:end docstring:

###;;;autoload
function strtok ()
{
 :
}

#:docstring strtrunc:
# Порядок использования: strtrunc $n $s1 {$s2} {$...}
#
# Используется многими функциями, такими как strncmp, чтобы отсечь &quot;лишние&quot; символы.
# Выводит первые n символов в каждой из строк s1 s2 ... на stdout.
#:end docstring:

###;;;autoload
function strtrunc ()
{
    n=$1 ; shift
    for z; do
        echo &quot;${z:0:$n}&quot;
    done
}

# provide string

# string.bash конец библиотеки


# ========================================================================== #
# ==&gt; Все, что находится ниже, добавлено автором документа.

# ==&gt; Чтобы этот сценарий можно было использовать как &quot;библиотеку&quot;, необходимо
# ==&gt; удалить все, что находится ниже и &quot;source&quot; этот файл в вашем сценарии.

# strcat
string0=one
string1=two
echo
echo &quot;Проверка функции \&quot;strcat\&quot; :&quot;
echo &quot;Изначально \&quot;string0\&quot; = $string0&quot;
echo &quot;\&quot;string1\&quot; = $string1&quot;
strcat string0 string1
echo &quot;Теперь \&quot;string0\&quot; = $string0&quot;
echo

# strlen
echo
echo &quot;Проверка функции  \&quot;strlen\&quot; :&quot;
str=123456789
echo &quot;\&quot;str\&quot; = $str&quot;
echo -n &quot;Длина строки \&quot;str\&quot; = &quot;
strlen str
echo



# Упражнение:
# ---------
# Добавьте проверку остальных функций.


exit 0
</pre>
        </div>

        <p>Michael Zick предоставил очень сложный пример работы с
        массивами и утилитой <a
         href="#MD5SUMREF">md5sum</a>, используемой для кодирования
        сведений о каталоге.</p>

        <p>От переводчика:</p>

        <p>К своему стыду вынужден признаться, что перевод комментариев
        оказался мне не &quot;по зубам&quot;, поэтому оставляю этот
        сценарий без перевода.</p>

        <div
         class="EXAMPLE">
          <a
           name="DIRECTORYINFO"></a>

          <p><strong>Пример A-21. Directory information</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
# directory-info.sh
# Parses and lists directory information.

# NOTE: Change lines 273 and 353 per &quot;README&quot; file.

# Michael Zick is the author of this script.
# Used here with his permission.

# Controls
# If overridden by command arguments, they must be in the order:
#   Arg1: &quot;Descriptor Directory&quot;
#   Arg2: &quot;Exclude Paths&quot;
#   Arg3: &quot;Exclude Directories&quot;
#
# Environment Settings override Defaults.
# Command arguments override Environment Settings.

# Default location for content addressed file descriptors.
MD5UCFS=${1:-${MD5UCFS:-&#39;/tmpfs/ucfs&#39;}}

# Directory paths never to list or enter
declare -a \
  EXCLUDE_PATHS=${2:-${EXCLUDE_PATHS:-&#39;(/proc /dev /devfs /tmpfs)&#39;}}

# Directories never to list or enter
declare -a \
  EXCLUDE_DIRS=${3:-${EXCLUDE_DIRS:-&#39;(ucfs lost+found tmp wtmp)&#39;}}

# Files never to list or enter
declare -a \
  EXCLUDE_FILES=${3:-${EXCLUDE_FILES:-&#39;(core &quot;Name with Spaces&quot;)&#39;}}


# Here document used as a comment block.
: &lt;&lt; LSfieldsDoc
# # # # # List Filesystem Directory Information # # # # #
#
#       ListDirectory &quot;FileGlob&quot; &quot;Field-Array-Name&quot;
# or
#       ListDirectory -of &quot;FileGlob&quot; &quot;Field-Array-Filename&quot;
#       &#39;-of&#39; meaning &#39;output to filename&#39;
# # # # #

String format description based on: ls (GNU fileutils) version 4.0.36

Produces a line (or more) formatted:
inode permissions hard-links owner group ...
32736 -rw-------    1 mszick   mszick

size    day month date hh:mm:ss year path
2756608 Sun Apr 20 08:53:06 2003 /home/mszick/core

Unless it is formatted:
inode permissions hard-links owner group ...
266705 crw-rw----    1    root  uucp

major minor day month date hh:mm:ss year path
4,  68 Sun Apr 20 09:27:33 2003 /dev/ttyS4
NOTE: that pesky comma after the major number

NOTE: the &#39;path&#39; may be multiple fields:
/home/mszick/core
/proc/982/fd/0 -&gt; /dev/null
/proc/982/fd/1 -&gt; /home/mszick/.xsession-errors
/proc/982/fd/13 -&gt; /tmp/tmpfZVVOCs (deleted)
/proc/982/fd/7 -&gt; /tmp/kde-mszick/ksycoca
/proc/982/fd/8 -&gt; socket:[11586]
/proc/982/fd/9 -&gt; pipe:[11588]

If that isn&#39;t enough to keep your parser guessing,
either or both of the path components may be relative:
../Built-Shared -&gt; Built-Static
../linux-2.4.20.tar.bz2 -&gt; ../../../SRCS/linux-2.4.20.tar.bz2

The first character of the 11 (10?) character permissions field:
&#39;s&#39; Socket
&#39;d&#39; Directory
&#39;b&#39; Block device
&#39;c&#39; Character device
&#39;l&#39; Symbolic link
NOTE: Hard links not marked - test for identical inode numbers
on identical filesystems.
All information about hard linked files are shared, except
for the names and the name&#39;s location in the directory system.
NOTE: A &quot;Hard link&quot; is known as a &quot;File Alias&quot; on some systems.
&#39;-&#39; An undistingushed file

Followed by three groups of letters for: User, Group, Others
Character 1: &#39;-&#39; Not readable; &#39;r&#39; Readable
Character 2: &#39;-&#39; Not writable; &#39;w&#39; Writable
Character 3, User and Group: Combined execute and special
&#39;-&#39; Not Executable, Not Special
&#39;x&#39; Executable, Not Special
&#39;s&#39; Executable, Special
&#39;S&#39; Not Executable, Special
Character 3, Others: Combined execute and sticky (tacky?)
&#39;-&#39; Not Executable, Not Tacky
&#39;x&#39; Executable, Not Tacky
&#39;t&#39; Executable, Tacky
&#39;T&#39; Not Executable, Tacky

Followed by an access indicator
Haven&#39;t tested this one, it may be the eleventh character
or it may generate another field
&#39; &#39; No alternate access
&#39;+&#39; Alternate access
LSfieldsDoc


ListDirectory()
{
        local -a T
        local -i of=0           # Default return in variable
#       OLD_IFS=$IFS            # Using BASH default &#39; \t\n&#39;

        case &quot;$#&quot; in
        3)      case &quot;$1&quot; in
                -of)    of=1 ; shift ;;
                 * )    return 1 ;;
                esac ;;
        2)      : ;;            # Poor man&#39;s &quot;continue&quot;
        *)      return 1 ;;
        esac

        # NOTE: the (ls) command is NOT quoted (&quot;)
        T=( $(ls --inode --ignore-backups --almost-all --directory \
        --full-time --color=none --time=status --sort=none \
        --format=long $1) )

        case $of in
        # Assign T back to the array whose name was passed as $2
                0) eval $2=\( \&quot;\$\{T\[@\]\}\&quot; \) ;;
        # Write T into filename passed as $2
                1) echo &quot;${T[@]}&quot; &gt; &quot;$2&quot; ;;
        esac
        return 0
   }

# # # # # Is that string a legal number? # # # # #
#
#       IsNumber &quot;Var&quot;
# # # # # There has to be a better way, sigh...

IsNumber()
{
        local -i int
        if [ $# -eq 0 ]
        then
                return 1
        else
                (let int=$1)  2&gt;/dev/null
                return $?       # Exit status of the let thread
        fi
}

# # # # # Index Filesystem Directory Information # # # # #
#
#       IndexList &quot;Field-Array-Name&quot; &quot;Index-Array-Name&quot;
# or
#       IndexList -if Field-Array-Filename Index-Array-Name
#       IndexList -of Field-Array-Name Index-Array-Filename
#       IndexList -if -of Field-Array-Filename Index-Array-Filename
# # # # #

: &lt;&lt; IndexListDoc
Walk an array of directory fields produced by ListDirectory

Having suppressed the line breaks in an otherwise line oriented
report, build an index to the array element which starts each line.

Each line gets two index entries, the first element of each line
(inode) and the element that holds the pathname of the file.

The first index entry pair (Line-Number==0) are informational:
Index-Array-Name[0] : Number of &quot;Lines&quot; indexed
Index-Array-Name[1] : &quot;Current Line&quot; pointer into Index-Array-Name

The following index pairs (if any) hold element indexes into
the Field-Array-Name per:
Index-Array-Name[Line-Number * 2] : The &quot;inode&quot; field element.
NOTE: This distance may be either +11 or +12 elements.
Index-Array-Name[(Line-Number * 2) + 1] : The &quot;pathname&quot; element.
NOTE: This distance may be a variable number of elements.
Next line index pair for Line-Number+1.
IndexListDoc



IndexList()
{
        local -a LIST                   # Local of listname passed
        local -a -i INDEX=( 0 0 )       # Local of index to return
        local -i Lidx Lcnt
        local -i if=0 of=0              # Default to variable names

        case &quot;$#&quot; in                    # Simplistic option testing
                0) return 1 ;;
                1) return 1 ;;
                2) : ;;                 # Poor man&#39;s continue
                3) case &quot;$1&quot; in
                        -if) if=1 ;;
                        -of) of=1 ;;
                         * ) return 1 ;;
                   esac ; shift ;;
                4) if=1 ; of=1 ; shift ; shift ;;
                *) return 1
        esac

        # Make local copy of list
        case &quot;$if&quot; in
                0) eval LIST=\( \&quot;\$\{$1\[@\]\}\&quot; \) ;;
                1) LIST=( $(cat $1) ) ;;
        esac

        # Grok (grope?) the array
        Lcnt=${#LIST[@]}
        Lidx=0
        until (( Lidx &gt;= Lcnt ))
        do
        if IsNumber ${LIST[$Lidx]}
        then
                local -i inode name
                local ft
                inode=Lidx
                local m=${LIST[$Lidx+2]}        # Hard Links field
                ft=${LIST[$Lidx+1]:0:1}         # Fast-Stat
                case $ft in
                b)      ((Lidx+=12)) ;;         # Block device
                c)      ((Lidx+=12)) ;;         # Character device
                *)      ((Lidx+=11)) ;;         # Anything else
                esac
                name=Lidx
                case $ft in
                -)      ((Lidx+=1)) ;;          # The easy one
                b)      ((Lidx+=1)) ;;          # Block device
                c)      ((Lidx+=1)) ;;          # Character device
                d)      ((Lidx+=1)) ;;          # The other easy one
                l)      ((Lidx+=3)) ;;          # At LEAST two more fields
#  A little more elegance here would handle pipes,
#+ sockets, deleted files - later.
                *)      until IsNumber ${LIST[$Lidx]} || ((Lidx &gt;= Lcnt))
                        do
                                ((Lidx+=1))
                        done
                        ;;                      # Not required
                esac
                INDEX[${#INDEX[*]}]=$inode
                INDEX[${#INDEX[*]}]=$name
                INDEX[0]=${INDEX[0]}+1          # One more &quot;line&quot; found
# echo &quot;Line: ${INDEX[0]} Type: $ft Links: $m Inode: \
# ${LIST[$inode]} Name: ${LIST[$name]}&quot;

        else
                ((Lidx+=1))
        fi
        done
        case &quot;$of&quot; in
                0) eval $2=\( \&quot;\$\{INDEX\[@\]\}\&quot; \) ;;
                1) echo &quot;${INDEX[@]}&quot; &gt; &quot;$2&quot; ;;
        esac
        return 0                                # What could go wrong?
}

# # # # # Content Identify File # # # # #
#
#       DigestFile Input-Array-Name Digest-Array-Name
# or
#       DigestFile -if Input-FileName Digest-Array-Name
# # # # #

# Here document used as a comment block.
: &lt;&lt;DigestFilesDoc

The key (no pun intended) to a Unified Content File System (UCFS)
is to distinguish the files in the system based on their content.
Distinguishing files by their name is just, so, 20th Century.

The content is distinguished by computing a checksum of that content.
This version uses the md5sum program to generate a 128 bit checksum
representative of the file&#39;s contents.
There is a chance that two files having different content might
generate the same checksum using md5sum (or any checksum).  Should
that become a problem, then the use of md5sum can be replace by a
cyrptographic signature.  But until then...

The md5sum program is documented as outputting three fields (and it
does), but when read it appears as two fields (array elements).  This
is caused by the lack of whitespace between the second and third field.
So this function gropes the md5sum output and returns:
        [0]     32 character checksum in hexidecimal (UCFS filename)
        [1]     Single character: &#39; &#39; text file, &#39;*&#39; binary file
        [2]     Filesystem (20th Century Style) name
        Note: That name may be the character &#39;-&#39; indicating STDIN read.

DigestFilesDoc



DigestFile()
{
        local if=0              # Default, variable name
        local -a T1 T2

        case &quot;$#&quot; in
        3)      case &quot;$1&quot; in
                -if)    if=1 ; shift ;;
                 * )    return 1 ;;
                esac ;;
        2)      : ;;            # Poor man&#39;s &quot;continue&quot;
        *)      return 1 ;;
        esac

        case $if in
        0) eval T1=\( \&quot;\$\{$1\[@\]\}\&quot; \)
           T2=( $(echo ${T1[@]} | md5sum -) )
           ;;
        1) T2=( $(md5sum $1) )
           ;;
        esac

        case ${#T2[@]} in
        0) return 1 ;;
        1) return 1 ;;
        2) case ${T2[1]:0:1} in         # SanScrit-2.0.5
           \*) T2[${#T2[@]}]=${T2[1]:1}
               T2[1]=\*
               ;;
            *) T2[${#T2[@]}]=${T2[1]}
               T2[1]=&quot; &quot;
               ;;
           esac
           ;;
        3) : ;; # Assume it worked
        *) return 1 ;;
        esac

        local -i len=${#T2[0]}
        if [ $len -ne 32 ] ; then return 1 ; fi
        eval $2=\( \&quot;\$\{T2\[@\]\}\&quot; \)
}

# # # # # Locate File # # # # #
#
#       LocateFile [-l] FileName Location-Array-Name
# or
#       LocateFile [-l] -of FileName Location-Array-FileName
# # # # #

# A file location is Filesystem-id and inode-number

# Here document used as a comment block.
: &lt;&lt;StatFieldsDoc
        Based on stat, version 2.2
        stat -t and stat -lt fields
        [0]     name
        [1]     Total size
                File - number of bytes
                Symbolic link - string length of pathname
        [2]     Number of (512 byte) blocks allocated
        [3]     File type and Access rights (hex)
        [4]     User ID of owner
        [5]     Group ID of owner
        [6]     Device number
        [7]     Inode number
        [8]     Number of hard links
        [9]     Device type (if inode device) Major
        [10]    Device type (if inode device) Minor
        [11]    Time of last access
                May be disabled in &#39;mount&#39; with noatime
                atime of files changed by exec, read, pipe, utime, mknod (mmap?)
                atime of directories changed by addition/deletion of files
        [12]    Time of last modification
                mtime of files changed by write, truncate, utime, mknod
                mtime of directories changed by addtition/deletion of files
        [13]    Time of last change
                ctime reflects time of changed inode information (owner, group
                permissions, link count
-*-*- Per:
        Return code: 0
        Size of array: 14
        Contents of array
        Element 0: /home/mszick
        Element 1: 4096
        Element 2: 8
        Element 3: 41e8
        Element 4: 500
        Element 5: 500
        Element 6: 303
        Element 7: 32385
        Element 8: 22
        Element 9: 0
        Element 10: 0
        Element 11: 1051221030
        Element 12: 1051214068
        Element 13: 1051214068

        For a link in the form of linkname -&gt; realname
        stat -t  linkname returns the linkname (link) information
        stat -lt linkname returns the realname information

        stat -tf and stat -ltf fields
        [0]     name
        [1]     ID-0?           # Maybe someday, but Linux stat structure
        [2]     ID-0?           # does not have either LABEL nor UUID
                                # fields, currently information must come
                                # from file-system specific utilities
        These will be munged into:
        [1]     UUID if possible
        [2]     Volume Label if possible
        Note: &#39;mount -l&#39; does return the label and could return the UUID

        [3]     Maximum length of filenames
        [4]     Filesystem type
        [5]     Total blocks in the filesystem
        [6]     Free blocks
        [7]     Free blocks for non-root user(s)
        [8]     Block size of the filesystem
        [9]     Total inodes
        [10]    Free inodes

-*-*- Per:
        Return code: 0
        Size of array: 11
        Contents of array
        Element 0: /home/mszick
        Element 1: 0
        Element 2: 0
        Element 3: 255
        Element 4: ef53
        Element 5: 2581445
        Element 6: 2277180
        Element 7: 2146050
        Element 8: 4096
        Element 9: 1311552
        Element 10: 1276425

StatFieldsDoc


#       LocateFile [-l] FileName Location-Array-Name
#       LocateFile [-l] -of FileName Location-Array-FileName

LocateFile()
{
        local -a LOC LOC1 LOC2
        local lk=&quot;&quot; of=0

        case &quot;$#&quot; in
        0) return 1 ;;
        1) return 1 ;;
        2) : ;;
        *) while (( &quot;$#&quot; &gt; 2 ))
           do
              case &quot;$1&quot; in
               -l) lk=-1 ;;
              -of) of=1 ;;
                *) return 1 ;;
              esac
           shift
           done ;;
        esac

# More Sanscrit-2.0.5
      # LOC1=( $(stat -t $lk $1) )
      # LOC2=( $(stat -tf $lk $1) )
      # Uncomment above two lines if system has &quot;stat&quot; command installed.
        LOC=( ${LOC1[@]:0:1} ${LOC1[@]:3:11}
              ${LOC2[@]:1:2} ${LOC2[@]:4:1} )

        case &quot;$of&quot; in
                0) eval $2=\( \&quot;\$\{LOC\[@\]\}\&quot; \) ;;
                1) echo &quot;${LOC[@]}&quot; &gt; &quot;$2&quot; ;;
        esac
        return 0
# Which yields (if you are lucky, and have &quot;stat&quot; installed)
# -*-*- Location Discriptor -*-*-
#       Return code: 0
#       Size of array: 15
#       Contents of array
#       Element 0: /home/mszick         20th Century name
#       Element 1: 41e8                 Type and Permissions
#       Element 2: 500                  User
#       Element 3: 500                  Group
#       Element 4: 303                  Device
#       Element 5: 32385                inode
#       Element 6: 22                   Link count
#       Element 7: 0                    Device Major
#       Element 8: 0                    Device Minor
#       Element 9: 1051224608           Last Access
#       Element 10: 1051214068          Last Modify
#       Element 11: 1051214068          Last Status
#       Element 12: 0                   UUID (to be)
#       Element 13: 0                   Volume Label (to be)
#       Element 14: ef53                Filesystem type
}



# And then there was some test code

ListArray() # ListArray Name
{
        local -a Ta

        eval Ta=\( \&quot;\$\{$1\[@\]\}\&quot; \)
        echo
        echo &quot;-*-*- List of Array -*-*-&quot;
        echo &quot;Size of array $1: ${#Ta[*]}&quot;
        echo &quot;Contents of array $1:&quot;
        for (( i=0 ; i&lt;${#Ta[*]} ; i++ ))
        do
            echo -e &quot;\tElement $i: ${Ta[$i]}&quot;
        done
        return 0
}

declare -a CUR_DIR
# For small arrays
ListDirectory &quot;${PWD}&quot; CUR_DIR
ListArray CUR_DIR

declare -a DIR_DIG
DigestFile CUR_DIR DIR_DIG
echo &quot;The new \&quot;name\&quot; (checksum) for ${CUR_DIR[9]} is ${DIR_DIG[0]}&quot;

declare -a DIR_ENT
# BIG_DIR # For really big arrays - use a temporary file in ramdisk
# BIG-DIR # ListDirectory -of &quot;${CUR_DIR[11]}/*&quot; &quot;/tmpfs/junk2&quot;
ListDirectory &quot;${CUR_DIR[11]}/*&quot; DIR_ENT

declare -a DIR_IDX
# BIG-DIR # IndexList -if &quot;/tmpfs/junk2&quot; DIR_IDX
IndexList DIR_ENT DIR_IDX

declare -a IDX_DIG
# BIG-DIR # DIR_ENT=( $(cat /tmpfs/junk2) )
# BIG-DIR # DigestFile -if /tmpfs/junk2 IDX_DIG
DigestFile DIR_ENT IDX_DIG
# Small (should) be able to parallize IndexList &amp; DigestFile
# Large (should) be able to parallize IndexList &amp; DigestFile &amp; the assignment
echo &quot;The \&quot;name\&quot; (checksum) for the contents of ${PWD} is ${IDX_DIG[0]}&quot;

declare -a FILE_LOC
LocateFile ${PWD} FILE_LOC
ListArray FILE_LOC

exit 0
</pre>
        </div>

        <p>Stephane Chazelas демонстрирует возможность объектно
        ориентированного подхода к программированию в
        Bash-сценариях.</p>

        <div
         class="EXAMPLE">
          <a
           name="OBJORIENTED"></a>

          <p><strong>Пример A-22. Объектно ориентированная база
          данных</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# obj-oriented.sh: Объектно ориентрованный подход к программированию в сценариях.
# Автор: Stephane Chazelas.


person.new()        # Очень похоже на объявление класса в C++.
{
  local obj_name=$1 name=$2 firstname=$3 birthdate=$4

  eval &quot;$obj_name.set_name() {
          eval \&quot;$obj_name.get_name() {
                   echo \$1
                 }\&quot;
        }&quot;

  eval &quot;$obj_name.set_firstname() {
          eval \&quot;$obj_name.get_firstname() {
                   echo \$1
                 }\&quot;
        }&quot;

  eval &quot;$obj_name.set_birthdate() {
          eval \&quot;$obj_name.get_birthdate() {
            echo \$1
          }\&quot;
          eval \&quot;$obj_name.show_birthdate() {
            echo \$(date -d \&quot;1/1/1970 0:0:\$1 GMT\&quot;)
          }\&quot;
          eval \&quot;$obj_name.get_age() {
            echo \$(( (\$(date +%s) - \$1) / 3600 / 24 / 365 ))
          }\&quot;
        }&quot;

  $obj_name.set_name $name
  $obj_name.set_firstname $firstname
  $obj_name.set_birthdate $birthdate
}

echo

person.new self Bozeman Bozo 101272413
# Создается экземпляр класса &quot;person.new&quot; (фактически -- вызов функции с аргументами).

self.get_firstname       #   Bozo
self.get_name            #   Bozeman
self.get_age             #   28
self.get_birthdate       #   101272413
self.show_birthdate      #   Sat Mar 17 20:13:33 MST 1973

echo

# typeset -f
# чтобы просмотреть перечень созданных функций.

exit 0
</pre>
        </div>
      </div>

      <div
       class="APPENDIX">
        <hr>

        <h1><a
         name="SEDAWK"></a>Приложение B. Маленький учебник по Sed и
        Awk</h1>

        <p><a
         name="SEDREF"></a></p>

        <p>В этом приложении содержится очень краткое описание приемов
        работы с утилитами обработки текста <strong
         class="COMMAND">sed</strong> и <strong
         class="COMMAND">awk</strong>. Здесь будут рассмотрены лишь
        несколько базовых команд, которых, в принципе, будет
        достаточно, чтобы научиться понимать простейшие конструкции sed
        и awk внутри сценариев на языке командной оболочки.</p>

        <p><strong
         class="COMMAND">sed</strong>: неинтерактивный редактор
        текстовых файлов</p>

        <p><strong
         class="COMMAND">awk</strong>: язык обработки шаблонов с
        C-подобным синтаксисом</p>

        <p>При всех своих различиях, эти две утилиты обладают похожим
        синтаксисом, они обе умеют работать с <a
         href="#REGEXREF">регулярными выражениями</a>, обе,
        по-умолчанию, читают данные с устройства <tt
         class="FILENAME">stdin</tt> и обе выводят результат обработки
        на устройство <tt
         class="FILENAME">stdout</tt>. Обе являются утилитами
        UNIX-систем, и прекрасно могут взаимодействовать между собой.
        Вывод от одной может быть перенаправлен, по конвейеру, на вход
        другой. Их комбинирование придает сценариям, на языке командной
        оболочки, мощь и гибкость языка Perl.</p>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Одно важное отличие состоит в том, что в случае с
                sed, сценарий легко может передавать дополнительные
                аргументы этой утилите, в то время, как в случае с awk
                (см. <a
                 href="#COLTOTALER">Пример 33-3</a> и <a
                 href="#COLTOTALER2">Пример 9-22</a>), это более
                сложная задача .</p>
              </td>
            </tr>
          </table>
        </div>

        <div
         class="SECT1">
          <hr>

          <h2
           class="SECT1"><a
           name="AEN14605"></a>B.1. Sed</h2>

          <p>Sed -- это неинтерактивный строчный редактор. Он принимает
          текст либо с устройства <tt
           class="FILENAME">stdin</tt>, либо из текстового файла,
          выполняет некоторые операции над строками и затем выводит
          результат на устройство <tt
           class="FILENAME">stdout</tt> или в файл. Как правило, в
          сценариях, sed используется в конвейерной обработке данных,
          совместно с другими командами и утилитами.</p>

          <p>Sed определяет, по заданному <span
           class="emphasis"><em
           class="EMPHASIS">адресному пространству</em></span>, над
          какими строками следует выполнить операции. <a
           name="AEN14612"
           href="#FTN.AEN14612"><span
           class="footnote">[66]</span></a> Адресное пространство строк
          задается либо их порядковыми номерами, либо шаблоном.
          Например, команда <tt
           class="REPLACEABLE"><em>3d</em></tt> заставит sed удалить
          третью строку, а команда <tt
           class="REPLACEABLE"><em>/windows/d</em></tt> означает, что
          все строки, содержащие <span
           class="QUOTE">&quot;windows&quot;</span>, должны быть
          удалены.</p>

          <p>Из всего разнообразия операций, мы остановимся на трех,
          используемых наиболее часто. Это <strong
           class="COMMAND">p</strong> -- печать (на <tt
           class="FILENAME">stdout</tt>), <strong
           class="COMMAND">d</strong> -- удаление и <strong
           class="COMMAND">s</strong> -- замена.</p>

          <div
           class="TABLE">
            <a
             name="AEN14623"></a>

            <p><strong>Таблица B-1. Основные операции sed</strong></p>

            <table
             border="1"
             class="CALSTABLE">
              <thead>
                <tr>
                  <th
                   align="left"
                   valign="top">Операция</th>

                  <th
                   align="left"
                   valign="top">Название</th>

                  <th
                   align="left"
                   valign="top">Описание</th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">[диапазон строк]/p</tt></td>

                  <td
                   align="left"
                   valign="top">print</td>

                  <td
                   align="left"
                   valign="top">Печать [указанного диапазона
                  строк]</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">[диапазон строк]/d</tt></td>

                  <td
                   align="left"
                   valign="top">delete</td>

                  <td
                   align="left"
                   valign="top">Удалить [указанный диапазон строк]</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">s/pattern1/pattern2/</tt></td>

                  <td
                   align="left"
                   valign="top">substitute</td>

                  <td
                   align="left"
                   valign="top">Заменить первое встреченное
                  соответствие шаблону pattern1, в строке, на
                  pattern2</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">[диапазон
                  строк]/s/pattern1/pattern2/</tt></td>

                  <td
                   align="left"
                   valign="top">substitute</td>

                  <td
                   align="left"
                   valign="top">Заменить первое встреченное
                  соответствие шаблону pattern1, на pattern2, в
                  указанном <tt
                   class="REPLACEABLE"><em>диапазоне
                  строк</em></tt></td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">[диапазон
                  строк]/y/pattern1/pattern2/</tt></td>

                  <td
                   align="left"
                   valign="top">transform</td>

                  <td
                   align="left"
                   valign="top">заменить любые символы из шаблона
                  pattern1 на соответствующие символы из pattern2, в
                  указанном <tt
                   class="REPLACEABLE"><em>диапазоне строк</em></tt>
                  (эквивалент команды <strong
                   class="COMMAND">tr</strong>)</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">g</tt></td>

                  <td
                   align="left"
                   valign="top">global</td>

                  <td
                   align="left"
                   valign="top">Операция выполняется над <span
                   class="emphasis"><em
                   class="EMPHASIS">всеми</em></span> найденными
                  соответствиями внутри каждой из заданных строк</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Без оператора <tt
                   class="OPTION">g</tt> (<span
                   class="emphasis"><em
                   class="EMPHASIS">global</em></span>), операция
                  замены будет производиться только для первого
                  найденного совпадения, с заданным шаблоном, в каждой
                  строке.</p>
                </td>
              </tr>
            </table>
          </div>

          <p>В отдельных случаях, операции sed необходимо заключать в
          кавычки.</p>
<pre
 class="PROGRAMLISTING">
sed -e &#39;/^$/d&#39; $filename
#  Ключ -e говорит о том, что далее следует строка, которая должна интерпретироваться
#+ как набор инструкций редактирования.
# (При передаче одной инструкции, ключ &quot;-e&quot; является необязательным.)
#  &quot;Строгие&quot; кавычки (&#39;&#39;) предотвращают интерпретацию символов регулярного выражения,
#+ как специальных символов, командным интерпретатором.
#
# Действия производятся над строками, содержащимися в файле $filename.
</pre>
          <br>
          <br>

          <p>В отдельных случаях, команды редактирования не работают в
          одиночных кавычках.</p>
<pre
 class="PROGRAMLISTING">
filename=file1.txt
pattern=BEGIN

  sed &quot;/^$pattern/d&quot; &quot;$filename&quot;  # Результат вполне предсказуем.
# sed &#39;/^$pattern/d&#39; &quot;$filename&quot;    дает иной результат.
#        В данном случае, в &quot;строгих&quot; кавычках (&#39; ... &#39;),
#+      не происходит подстановки значения переменной &quot;$pattern&quot;.
</pre>
          <br>
          <br>

          <div
           class="NOTE">
            <table
             class="NOTE"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/note.gif"
                 hspace="5"
                 alt="Note"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Sed использует ключ <tt
                   class="OPTION">-e</tt> для того, чтобы определить,
                  что следующая строка является инструкцией, или
                  набором инструкций, редактирования. Если инструкция
                  является единственной, то использование этого ключа
                  не является обязательным.</p>
                </td>
              </tr>
            </table>
          </div>
<pre
 class="PROGRAMLISTING">
sed -n &#39;/xzy/p&#39; $filename
# Ключ -n заставляет sed вывести только те строки, которые совпадают с указанным шаблоном.
# В противном случае (без ключа -n), будут выведены все строки.
# Здесь, ключ -e не является обязательным, поскольку здесь стоит единственная команда.
</pre>
          <br>
          <br>

          <div
           class="TABLE">
            <a
             name="AEN14681"></a>

            <p><strong>Таблица B-2. Примеры операций в sed</strong></p>

            <table
             border="1"
             class="CALSTABLE">
              <thead>
                <tr>
                  <th
                   align="left"
                   valign="top">Операция</th>

                  <th
                   align="left"
                   valign="top">Описание</th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">8d</tt></td>

                  <td
                   align="left"
                   valign="top">Удалить 8-ю строку.</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">/^$/d</tt></td>

                  <td
                   align="left"
                   valign="top">Удалить все пустые строки.</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">1,/^$/d</tt></td>

                  <td
                   align="left"
                   valign="top">Удалить все строки до первой пустой
                  строки, включительно.</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">/Jones/p</tt></td>

                  <td
                   align="left"
                   valign="top">Вывести строки, содержащие <span
                   class="QUOTE">&quot;Jones&quot;</span> (с ключом
                  <span
                   class="TOKEN">-n</span>).</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">s/Windows/Linux/</tt></td>

                  <td
                   align="left"
                   valign="top">В каждой строке, заменить первое
                  встретившееся слово <span
                   class="QUOTE">&quot;Windows&quot;</span> на слово
                  <span
                   class="QUOTE">&quot;Linux&quot;</span>.</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">s/BSOD/stability/g</tt></td>

                  <td
                   align="left"
                   valign="top">В каждой строке, заменить все
                  встретившиеся слова <span
                   class="QUOTE">&quot;BSOD&quot;</span> на <span
                   class="QUOTE">&quot;stability&quot;</span>.</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">s/ *$//</tt></td>

                  <td
                   align="left"
                   valign="top">Удалить все пробелы в конце каждой
                  строки.</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">s/00*/0/g</tt></td>

                  <td
                   align="left"
                   valign="top">Заменить все последовательности ведущих
                  нулей одним символом &quot;0&quot;.</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">/GUI/d</tt></td>

                  <td
                   align="left"
                   valign="top">Удалить все строки, содержащие <span
                   class="QUOTE">&quot;GUI&quot;</span>.</td>
                </tr>

                <tr>
                  <td
                   align="left"
                   valign="top"><tt
                   class="OPTION">s/GUI//g</tt></td>

                  <td
                   align="left"
                   valign="top">Удалить все найденные <span
                   class="QUOTE">&quot;GUI&quot;</span>, оставляя
                  остальную часть строки без изменений.</td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>Замена строки пустой строкой, эквивалентна удалению части
          строки, совпадающей с шаблоном. Остальная часть строки
          остается без изменений. Например, <tt
           class="USERINPUT"><strong>s/GUI//</strong></tt>, изменит
          следующую строку</p>
<pre
 class="SCREEN">
<tt
 class=
"USERINPUT"><strong>The most important parts of any application are its GUI and sound effects</strong></tt>
</pre>
          на 
<pre
 class="SCREEN">
<tt
 class=
"COMPUTEROUTPUT">The most important parts of any application are its  and sound effects</tt>
</pre>
          <br>
          <br>

          <p>Символ обратного слэша представляет символ перевода
          строки, как символ замены. В этом случае, замещающее
          выражение продолжается на следующей строке.</p>
<pre
 class="PROGRAMLISTING">
s/^  */\
/g
</pre>
          Эта инструкция заменит начальные пробелы в строке на символ
          перевода строки. Ожидаемый результат -- замена отступов в
          начале параграфа пустыми строками.<br>
          <br>

          <p>Указание диапазона строк, предшествующее одной, или более,
          инструкции может потребовать заключения инструкций в фигурные
          скобки, с соответствующими символами перевода строки.</p>
<pre
 class="PROGRAMLISTING">
/[0-9A-Za-z]/,/^$/{
/^$/d
}
</pre>
          В этом случае будут удалены только первые из нескольких,
          идущих подряд, пустых строк. Это может использоваться для
          установки однострочных интервалов в файле, оставляя, при
          этом, пустые строки между параграфами.<br>
          <br>

          <div
           class="TIP">
            <table
             class="TIP"
             width="100%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/tip.gif"
                 hspace="5"
                 alt="Tip"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Быстрый способ установки двойных межстрочных
                  интервалов в текстовых файлах -- <tt
                   class="USERINPUT"><strong>sed G
                  filename</strong></tt>.</p>
                </td>
              </tr>
            </table>
          </div>

          <p>Примеры использования sed в сценариях командной оболочки,
          вы найдете в:</p>

          <ol
           type="1">
            <li>
              <p><a
               href="#EX3">Пример 33-1</a></p>
            </li>

            <li>
              <p><a
               href="#EX4">Пример 33-2</a></p>
            </li>

            <li>
              <p><a
               href="#EX57">Пример 12-2</a></p>
            </li>

            <li>
              <p><a
               href="#RN">Пример A-3</a></p>
            </li>

            <li>
              <p><a
               href="#GRP">Пример 12-12</a></p>
            </li>

            <li>
              <p><a
               href="#COL">Пример 12-20</a></p>
            </li>

            <li>
              <p><a
               href="#BEHEAD">Пример A-13</a></p>
            </li>

            <li>
              <p><a
               href="#TREE">Пример A-19</a></p>
            </li>

            <li>
              <p><a
               href="#STRIPC">Пример 12-24</a></p>
            </li>

            <li>
              <p><a
               href="#FINDSTRING">Пример 10-9</a></p>
            </li>

            <li>
              <p><a
               href="#BASE">Пример 12-33</a></p>
            </li>

            <li>
              <p><a
               href="#MAILFORMAT">Пример A-2</a></p>
            </li>

            <li>
              <p><a
               href="#RND">Пример 12-10</a></p>
            </li>

            <li>
              <p><a
               href="#WF">Пример 12-8</a></p>
            </li>

            <li>
              <p><a
               href="#LIFESLOW">Пример A-11</a></p>
            </li>

            <li>
              <p><a
               href="#SELFDOCUMENT">Пример 17-11</a></p>
            </li>
          </ol>
          <br>
          <br>

          <p>Ссылки на дополнительные сведения о sed, вы найдете в
          разделе <a
           href="#BIBLIO"><em>Литература</em></a>.</p>
        </div>

        <div
         class="SECT1">
          <hr>

          <h2
           class="SECT1"><a
           name="AWK"></a>B.2. Awk</h2>

          <p><a
           name="AWKREF"></a></p>

          <p><strong
           class="COMMAND">Awk</strong> -- это полноценный язык
          обработки текстовой информации с синтаксисом, напоминающим
          синтаксис языка <strong
           class="COMMAND">C</strong>. Он обладает довольно широким
          набором возможностей, однако, мы рассмотрим лишь некоторые из
          них -- наиболее употребимые в сценариях командной
          оболочки.</p>

          <p>Awk &quot;разбивает&quot; каждую строку на отдельные <span
           class="emphasis"><em
           class="EMPHASIS">поля</em></span>. По-умолчанию, поля -- это
          последовательности символов, отделенные друг от друга <a
           href="#WHITESPACEREF">пробелами</a>, однако имеется
          возможность назначения других символов, в качестве
          разделителя полей. Awk анализирует и обрабатывает каждое поле
          в отдельности. Это делает его идеальным инструментом для
          работы со структурированными текстовыми файлами, осбенно с
          таблицами.</p>

          <p>Внутри сценариев командной оболочки, код awk, заключается
          в &quot;строгие&quot; (одиночные) кавычки и фигурные
          скобки.</p>
<pre
 class="PROGRAMLISTING">
awk &#39;{print $3}&#39; $filename
# Выводит содержимое 3-го поля из файла $filename на устройство stdout.

awk &#39;{print $1 $5 $6}&#39; $filename
# Выводит содержимое 1-го, 5-го и 6-го полей из файла $filename.
</pre>
          <br>
          <br>

          <p>Только что, мы рассмотрели действие команды <strong
           class="COMMAND">print</strong>. Еще, на чем мы остановимся
          -- это переменные. Awk работает с переменными подобно
          сценариям командной оболочки, но более гибко.</p>
<pre
 class="PROGRAMLISTING">
{ total += ${column_number} }
</pre>
          Эта команда добавит содержимое переменной <span
           class="emphasis"><em
           class="EMPHASIS">column_number</em></span> к переменной
          <span
           class="QUOTE">&quot;total&quot;</span>. Чтобы, в завершение
          вывести <span
           class="QUOTE">&quot;total&quot;</span>, можно использовать
          команду <strong
           class="COMMAND">END</strong>, которая открывает блок кода,
          отрабатывающий после того, как будут обработаны все входные
          данные. 
<pre
 class="PROGRAMLISTING">
END { print total }
</pre>
          <br>
          <br>

          <p>Команде <strong
           class="COMMAND">END</strong>, соответствует команда <strong
           class="COMMAND">BEGIN</strong>, которая открывает блок кода,
          отрабатывающий перед началом обработки входных данных.</p>

          <p>Примеры использования awk в сценариях командной оболочки,
          вы найдете в:</p>

          <ol
           type="1">
            <li>
              <p><a
               href="#EX44">Пример 11-10</a></p>
            </li>

            <li>
              <p><a
               href="#REDIR4">Пример 16-7</a></p>
            </li>

            <li>
              <p><a
               href="#STRIPC">Пример 12-24</a></p>
            </li>

            <li>
              <p><a
               href="#COLTOTALER">Пример 33-3</a></p>
            </li>

            <li>
              <p><a
               href="#COLTOTALER2">Пример 9-22</a></p>
            </li>

            <li>
              <p><a
               href="#COLTOTALER3">Пример 11-16</a></p>
            </li>

            <li>
              <p><a
               href="#PIDID">Пример 27-1</a></p>
            </li>

            <li>
              <p><a
               href="#CONSTAT">Пример 27-2</a></p>
            </li>

            <li>
              <p><a
               href="#FILEINFO">Пример 10-3</a></p>
            </li>

            <li>
              <p><a
               href="#BLOTOUT">Пример 12-42</a></p>
            </li>

            <li>
              <p><a
               href="#SEEDINGRANDOM">Пример 9-26</a></p>
            </li>

            <li>
              <p><a
               href="#IDELETE">Пример 12-3</a></p>
            </li>

            <li>
              <p><a
               href="#SUBSTRINGEX">Пример 9-12</a></p>
            </li>

            <li>
              <p><a
               href="#SUMPRODUCT">Пример 33-11</a></p>
            </li>

            <li>
              <p><a
               href="#USERLIST">Пример 10-8</a></p>
            </li>
          </ol>
          <br>
          <br>

          <p>Это все, что я хотел рассказать об awk. Дополнительные
          ссылки на информацию об awk, вы найдете в разделе <a
           href="#BIBLIO"><em>Литература</em></a>.</p>
        </div>
      </div>

      <div
       class="APPENDIX">
        <hr>

        <h1><a
         name="EXITCODES"></a>Приложение C. Коды завершения, имеющие
        предопределенный смысл</h1>

        <p><a
         name="EXITCODESREF"></a></p>

        <div
         class="TABLE">
          <a
           name="AEN14880"></a>

          <p><strong>Таблица C-1. <span
           class="QUOTE">&quot;Зарезервированные&quot;</span> коды
          завершения</strong></p>

          <table
           border="1"
           class="CALSTABLE">
            <thead>
              <tr>
                <th
                 align="left"
                 valign="top">Код завершения</th>

                <th
                 align="left"
                 valign="top">Смысл</th>

                <th
                 align="left"
                 valign="top">Пример</th>

                <th
                 align="left"
                 valign="top">Примечание</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">1</tt></td>

                <td
                 align="left"
                 valign="top">разнообразные ошибки</td>

                <td
                 align="left"
                 valign="top">let &quot;var1 = 1/0&quot;</td>

                <td
                 align="left"
                 valign="top">различные ошибки, такие как <span
                 class="QUOTE">&quot;деление на ноль&quot;</span> и
                пр.</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">2</tt></td>

                <td
                 align="left"
                 valign="top">согласно документации к Bash -- неверное
                использование встроенных команд</td>

                <td
                 align="left"
                 valign="top"> </td>

                <td
                 align="left"
                 valign="top">Встречаются довольно редко, обычно код
                завершения возвращается равным 1</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">126</tt></td>

                <td
                 align="left"
                 valign="top">вызываемая команда не может быть
                выполнена</td>

                <td
                 align="left"
                 valign="top"> </td>

                <td
                 align="left"
                 valign="top">возникает из-за проблем с правами доступа
                или когда вызван на исполнение неисполняемый файл</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">127</tt></td>

                <td
                 align="left"
                 valign="top"><span
                 class="QUOTE">&quot;команда не
                найдена&quot;</span></td>

                <td
                 align="left"
                 valign="top"> </td>

                <td
                 align="left"
                 valign="top">Проблема связана либо с переменной
                окружения <tt
                 class="VARNAME">$PATH</tt>, либо с неверным написанием
                имени команды</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">128</tt></td>

                <td
                 align="left"
                 valign="top">неверный аргумент команды <a
                 href="#EXITCOMMANDREF">exit</a></td>

                <td
                 align="left"
                 valign="top">exit 3.14159</td>

                <td
                 align="left"
                 valign="top">команда <strong
                 class="COMMAND">exit</strong> может принимать только
                целочисленные значения, в диапазоне 0 - 255</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">128+n</tt></td>

                <td
                 align="left"
                 valign="top">фатальная ошибка по сигналу <span
                 class="QUOTE">&quot;n&quot;</span></td>

                <td
                 align="left"
                 valign="top"><strong
                 class="COMMAND">kill -9</strong> <tt
                 class="VARNAME">$PPID</tt> сценария</td>

                <td
                 align="left"
                 valign="top"><tt
                 class="USERINPUT"><strong>$?</strong></tt> вернет 137
                (128 + 9)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">130</tt></td>

                <td
                 align="left"
                 valign="top">завершение по Control-C</td>

                <td
                 align="left"
                 valign="top"> </td>

                <td
                 align="left"
                 valign="top">Control-C -- это выход по сигналу 2, (130
                = 128 + 2, см. выше)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">255*</tt></td>

                <td
                 align="left"
                 valign="top">код завершения вне допустимого
                диапазона</td>

                <td
                 align="left"
                 valign="top">exit -1</td>

                <td
                 align="left"
                 valign="top"><strong
                 class="COMMAND">exit</strong> может принимать только
                целочисленные значения, в диапазоне 0 - 255</td>
              </tr>
            </tbody>
          </table>
        </div>

        <p>Согласно этой таблице, коды завершения 1 - 2, 126 - 165 и
        255 <a
         name="AEN14950"
         href="#FTN.AEN14950"><span
         class="footnote">[67]</span></a> имеют предопределенное
        значение, поэтому вам следует избегать употребления этих кодов
        для своих нужд. Завершение сценария с кодом возврата <strong
         class="COMMAND">exit 127</strong>, может привести в
        замешательство при поиске ошибок в сценарии (действительно ли
        он означает ошибку <span
         class="QUOTE">&quot;команда не найдена&quot;</span>? Или это
        предусмотренный программистом код завершения?). В большинстве
        случаев, программисты вставляют <strong
         class="COMMAND">exit 1</strong>, в качестве реакции на ошибку.
        Так как код завершения <span
         class="RETURNVALUE">1</span> подразумевает целый
        &quot;букет&quot; ошибок, то в данном случае трудно говорить о
        какой либо двусмысленности, хотя и об информативности --
        тоже.</p>

        <p>Не раз предпринимались попытки систематизировать коды
        завершения (см. <tt
         class="FILENAME">/usr/include/sysexits.h</tt>), но эта
        систематизация предназначена для программистов, пишущих на
        языках C и C++. Автор документа предлагает ограничить коды
        завершения, определяемые пользователем, диапазоном 64 - 113 (и,
        само собой разумеется -- 0, для обозначения успешного
        завершения), в соответствии со стандартом C/C++. Это сделало бы
        поиск ошибок более простым.</p>

        <p>Все сценарии, прилагаемые к данному документу, приведены в
        соответствие с этим стандартом, за исключением случаев, когда
        существуют отменяющие обстоятельства, например в <a
         href="#TMDIN">Пример 9-2</a>.</p>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Обращение к переменной <a
                 href="#XSTATVARREF">$?</a>, из командной строки, после
                завершения работы сценария, дает результат, в
                соответствии с таблицей, приведенной выше, но только
                для Bash или <span
                 class="emphasis"><em
                 class="EMPHASIS">sh</em></span>. Под управлением csh
                или <span
                 class="emphasis"><em
                 class="EMPHASIS">tcsh</em></span> значения могут в
                некоторых случаях отличаться.</p>
              </td>
            </tr>
          </table>
        </div>
      </div>

      <div
       class="APPENDIX">
        <hr>

        <h1><a
         name="IOREDIRINTRO"></a>Приложение D. Подробное введение в
        операции ввода-вывода и перенаправление ввода-вывода</h1>

        <p><span
         class="emphasis"><em
         class="EMPHASIS">написано Stephane Chazelas и дополнено
        автором документа</em></span></p>

        <p>Практически любая команда предполагает доступность 3-х <a
         href="#FDREF">файловых дескрипторов</a>. Первый -- <span
         class="emphasis"><em
         class="EMPHASIS">0</em></span> (стандвртный ввод, <tt
         class="FILENAME">stdin</tt>), доступный для чтения. И два
        других -- <span
         class="emphasis"><em
         class="EMPHASIS">1</em></span> (<tt
         class="FILENAME">stdout</tt>) и <span
         class="emphasis"><em
         class="EMPHASIS">2</em></span> (<tt
         class="FILENAME">stderr</tt>), доступные для записи.</p>

        <p>Запись, типа <tt
         class="USERINPUT"><strong>ls 2&gt;&amp;1</strong></tt>,
        означает временное перенаправление вывода, с устройства <tt
         class="FILENAME">stderr</tt> на устройство <tt
         class="FILENAME">stdout</tt>.</p>

        <p>В соответствии с соглашениями, команды принимают ввод из
        файла с дескриптором 0 (<tt
         class="FILENAME">stdin</tt>), выводят результат работы в файл
        с дескриптором 1 (<tt
         class="FILENAME">stdout</tt>), а сообщения об ошибках -- в
        файл с дескриптором 2 (<tt
         class="FILENAME">stderr</tt>). Если какой либо из этих трех
        дескрипторов окажется закрытым, то могут возникнуть
        определенные проблемы:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /etc/passwd &gt;&amp;-</strong></tt>
<tt
 class="COMPUTEROUTPUT">cat: standard output: Bad file descriptor</tt>
     
</pre>

        <p>К примеру, когда пользователь запускает <strong
         class="COMMAND">xterm</strong>, то он сначала выполняет
        процедуру инициализации, а затем, перед запуском командной
        оболочки, <strong
         class="COMMAND">xterm</strong> трижды открывает терминальные
        устройства (/dev/pts/&lt;n&gt;, или нечто подобное).</p>

        <p>После этого, командная оболочка наследует эти три
        дескриптора, и любая команда, запускаемая в этой оболочке, так
        же наследует их. Термин <a
         href="#IOREDIRREF">перенаправление</a> -- означает
        переназначение одного файлового дескриптора на другой (канал
        (конвейер) или что-то другое). Переназначение может быть
        выполнено локально (для отдельной команды, для группы команд,
        для подоболочки, для операторов <a
         href="#REDIRREF">while, if, case, for</a>...) или глобально (с
        помощью <a
         href="#EXECREF">exec</a>).</p>

        <p><tt
         class="USERINPUT"><strong>ls &gt; /dev/null</strong></tt> --
        означает запуск команды <strong
         class="COMMAND">ls</strong> с файловым дескриптором 1,
        присоединенным к устройству <tt
         class="FILENAME">/dev/null</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lsof -a -p $$ -d0,1,2</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">COMMAND PID     USER   FD   TYPE DEVICE SIZE NODE NAME
 bash    363 bozo        0u   CHR  136,1         3 /dev/pts/1
 bash    363 bozo        1u   CHR  136,1         3 /dev/pts/1
 bash    363 bozo        2u   CHR  136,1         3 /dev/pts/1</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>exec 2&gt; /dev/null</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lsof -a -p $$ -d0,1,2</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">COMMAND PID     USER   FD   TYPE DEVICE SIZE NODE NAME
 bash    371 bozo        0u   CHR  136,1         3 /dev/pts/1
 bash    371 bozo        1u   CHR  136,1         3 /dev/pts/1
 bash    371 bozo        2w   CHR    1,3       120 /dev/null</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>bash -c &#39;lsof -a -p $$ -d0,1,2&#39; | cat</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">COMMAND PID USER   FD   TYPE DEVICE SIZE NODE NAME
 lsof    379 root    0u   CHR  136,1         3 /dev/pts/1
 lsof    379 root    1w  FIFO    0,0      7118 pipe
 lsof    379 root    2u   CHR  136,1         3 /dev/pts/1</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;$(bash -c &#39;lsof -a -p $$ -d0,1,2&#39; 2&gt;&amp;1)&quot;</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">COMMAND PID USER   FD   TYPE DEVICE SIZE NODE NAME
 lsof    426 root    0u   CHR  136,1         3 /dev/pts/1
 lsof    426 root    1w  FIFO    0,0      7520 pipe
 lsof    426 root    2w  FIFO    0,0      7520 pipe</tt>
</pre>
        <br>
        <br>

        <p><tt
         class="USERINPUT"><strong>Упражнение:</strong></tt>
        Проанализируйте следующий сценарий.</p>
<pre
 class="PROGRAMLISTING">
#! /usr/bin/env bash

mkfifo /tmp/fifo1 /tmp/fifo2
while read a; do echo &quot;FIFO1: $a&quot;; done &lt; /tmp/fifo1 &amp;
exec 7&gt; /tmp/fifo1
exec 8&gt; &gt;(while read a; do echo &quot;FD8: $a, to fd7&quot;; done &gt;&amp;7)

exec 3&gt;&amp;1
(
 (
  (
   while read a; do echo &quot;FIFO2: $a&quot;; done &lt; /tmp/fifo2 | tee /dev/stderr | tee /dev/fd/4 | tee /dev/fd/5 | tee /dev/fd/6 &gt;&amp;7 &amp;
   exec 3&gt; /tmp/fifo2

   echo 1st, to stdout
   sleep 1
   echo 2nd, to stderr &gt;&amp;2
   sleep 1
   echo 3rd, to fd 3 &gt;&amp;3
   sleep 1
   echo 4th, to fd 4 &gt;&amp;4
   sleep 1
   echo 5th, to fd 5 &gt;&amp;5
   sleep 1                                                                                              
   echo 6th, through a pipe | sed &#39;s/.*/PIPE: &amp;, to fd 5/&#39; &gt;&amp;5                                          
   sleep 1                                                                                              
   echo 7th, to fd 6 &gt;&amp;6                                                                                
   sleep 1                                                                                              
   echo 8th, to fd 7 &gt;&amp;7
   sleep 1                                                                                              
   echo 9th, to fd 8 &gt;&amp;8                                                                                
                                                                                                        
  ) 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | while read a; do echo &quot;FD4: $a&quot;; done 1&gt;&amp;3 5&gt;&amp;- 6&gt;&amp;-                                
 ) 5&gt;&amp;1 &gt;&amp;3 | while read a; do echo &quot;FD5: $a&quot;; done 1&gt;&amp;3 6&gt;&amp;-
) 6&gt;&amp;1 &gt;&amp;3 | while read a; do echo &quot;FD6: $a&quot;; done 3&gt;&amp;-                                                 
                                                                                                        
rm -f /tmp/fifo1 /tmp/fifo2


# Выясните, куда переназначены файловые дескрипторы каждой команды и подоболочки.

exit 0
</pre>
        <br>
        <br>
      </div>

      <div
       class="APPENDIX">
        <hr>

        <h1><a
         name="LOCALIZATION"></a>Приложение E. Локализация</h1>

        <p>Возможность локализации сценариев Bash нигде в документации
        не описана.</p>

        <p>Локализованные сценарии выводят текст на том языке, который
        используется системой, в соответствии с настройками.
        Пользователь Linux, живущий в Берлине (Германия), будет видеть
        сообщения на немецком языке, в то время как другой
        пользователь, проживающий в Берлине штата Мэриленд (США) -- на
        английском.</p>

        <p>Для создания локализованых сценариев можно использовать
        следующий шаблон, предусматривающий вывод всех сообщений на
        языке пользователя (сообщения об ошибках, приглашения к вводу и
        т.п.).</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# localized.sh

E_CDERROR=65

error()
{
  printf &quot;$@&quot; &gt;&amp;2
  exit $E_CDERROR
}

cd $var || error $&quot;Can&#39;t cd to %s.&quot; &quot;$var&quot;
read -p $&quot;Enter the value: &quot; var
# ...
</pre>
        <br>
        <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>bash -D localized.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">&quot;Can&#39;t cd to %s.&quot;
&quot;Enter the value: &quot;</tt>
</pre>
        Это список всех текстовых сообщений, которые подлежат
        локализации. (Ключ <tt
         class="OPTION">-D</tt> выводит список строк в двойных
        кавычках, которым предшествует символ <span
         class="TOKEN">$</span>, без запуска сценария на
        исполнение.)<br>
        <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>bash --dump-po-strings localized.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">#: a:6
 msgid &quot;Can&#39;t cd to %s.&quot;
 msgstr &quot;&quot;
 #: a:7
 msgid &quot;Enter the value: &quot;
 msgstr &quot;&quot;</tt>
</pre>
        Ключ <tt
         class="OPTION">--dump-po-strings</tt> в Bash напоминает ключ
        <tt
         class="OPTION">-D</tt>, но выводит строки в формате <span
         class="QUOTE">&quot;po&quot;</span>, с помощью утилиты <a
         href="#GETTEXTREF">gettext</a>. <br>
        <br>

        <p>Теперь построим файл <tt
         class="FILENAME">language.po</tt>, для каждого языка, на
        которые предполагается перевести сообщения сценария.
        Например:</p>

        <p>Файл ru.po сделан переводчиком, в оригинальном документе
        локализация выполнена на примере французского языка</p>

        <p>ru.po:</p>
<pre
 class="PROGRAMLISTING">
#: a:6
msgid &quot;Can&#39;t cd to %s.&quot;
msgstr &quot;Невозможно перейти в каталог %s.&quot;
#: a:7
msgid &quot;Enter the value: &quot;
msgstr &quot;Введите число: &quot;
</pre>
        <br>
        <br>

        <p>Затем запустите <strong
         class="COMMAND">msgfmt</strong>.</p>

        <p><tt
         class="USERINPUT"><strong>msgfmt -o localized.sh.mo
        ru.po</strong></tt></p>

        <p>Перепишите получившийся файл <tt
         class="FILENAME">localized.sh.mo</tt> в каталог <tt
         class="FILENAME">/usr/share/locale/ru/LC_MESSAGES</tt> и
        добавьте в начало сценария строки:</p>
<pre
 class="PROGRAMLISTING">
TEXTDOMAINDIR=/usr/share/locale
TEXTDOMAIN=localized.sh
</pre>
        <br>
        <br>

        <p>Если система корректно настроена на русскую локаль, то
        пользователь, запустивший сценарий, будет видеть сообщения на
        русском языке.</p>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>В старых версиях Bash или в других командных
                оболочках, потребуется воспользоваться услугами утилиты
                <a
                 href="#GETTEXTREF">gettext</a>, с ключом <tt
                 class="OPTION">-s</tt>. В этом случае наш сценарий
                будет выглядеть так:</p>

                <p><a
                 name="GETTEXTEXAMPLE"></a></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# localized.sh

E_CDERROR=65

error() {
  local format=$1
  shift
  printf &quot;$(gettext -s &quot;$format&quot;)&quot; &quot;$@&quot; &gt;&amp;2
  exit $E_CDERROR
}
cd $var || error &quot;Can&#39;t cd to %s.&quot; &quot;$var&quot;
read -p &quot;$(gettext -s &quot;Enter the value: &quot;)&quot; var
# ...
</pre>
                <br>
                <br>
              </td>
            </tr>
          </table>
        </div>

        <p>А переменные <tt
         class="VARNAME">TEXTDOMAIN</tt> и <tt
         class="VARNAME">TEXTDOMAINDIR</tt>, необходимо будет
        экспортировать в окружение.</p>

        <p>---</p>

        <p>Автор этого приложения: Stephane Chazelas.</p>
      </div>

      <div
       class="APPENDIX">
        <hr>

        <h1><a
         name="HISTCOMMANDS"></a>Приложение F. История команд</h1>

        <p>Командная оболочка Bash предоставляет в распоряжение
        пользователя инструментарий командной строки, позволяющий
        управлять <span
         class="emphasis"><em
         class="EMPHASIS">историей команд</em></span>. История команд
        -- это, прежде всего, очень удобный инструмент, сокращающий
        ручной ввод.</p>

        <p>История команд Bash:</p>

        <ol
         type="1">
          <li>
            <p><strong
             class="COMMAND">history</strong></p>
          </li>

          <li>
            <p><strong
             class="COMMAND">fc</strong></p>
          </li>
        </ol>
        <br>
        <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>history</strong></tt>
<tt
 class="COMPUTEROUTPUT">1  mount /mnt/cdrom
2  cd /mnt/cdrom
3  ls
     ...</tt>
             
</pre>
        <br>
        <br>

        <p>Внутренние переменные Bash, связанные с историей команд:</p>

        <ol
         type="1">
          <li>
            <p>$HISTCMD</p>
          </li>

          <li>
            <p>$HISTCONTROL</p>
          </li>

          <li>
            <p>$HISTIGNORE</p>
          </li>

          <li>
            <p>$HISTFILE</p>
          </li>

          <li>
            <p>$HISTFILESIZE</p>
          </li>

          <li>
            <p>$HISTSIZE</p>
          </li>

          <li>
            <p>!!</p>
          </li>

          <li>
            <p>!$</p>
          </li>

          <li>
            <p>!#</p>
          </li>

          <li>
            <p>!N</p>
          </li>

          <li>
            <p>!-N</p>
          </li>

          <li>
            <p>!STRING</p>
          </li>

          <li>
            <p>!?STRING?</p>
          </li>

          <li>
            <p>^STRING^string^</p>
          </li>
        </ol>
        <br>
        <br>

        <p>К сожалению, инструменты истории команд, в Bash, совершенно
        бесполезны в сценариях.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# history.sh
# Попытка воспользоваться &#39;историей&#39; команд в сценарии.

history

# На экран ничего не выводится.
# История команд не работает в сценариях.
</pre>
        <br>
        <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>./history.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">(ничего не выводится)</tt>
             
</pre>
        <br>
        <br>
      </div>

      <div
       class="APPENDIX">
        <hr>

        <h1><a
         name="SAMPLE-BASHRC"></a>Приложение G. Пример файла <tt
         class="FILENAME">.bashrc</tt></h1>

        <p>Файл <tt
         class="FILENAME">~/.bashrc</tt> определяет поведение командной
        оболочки. Внимательное изучение этого примера поможет вам
        значительно продвинуться в понимании Bash.</p>

        <p><a
         href="mailto:emmanuel.rouat@wanadoo.fr"
         target="_top">Emmanuel Rouat</a> представил следующий, очень
        сложный, файл <tt
         class="FILENAME">.bashrc</tt>, написанный для операционной
        системы Linux. Предложения и замечания приветствуются.</p>

        <p>Внимательно изучите этот файл. Отдельные участки этого файла
        вы свободно можете использовать в своем собственном <tt
         class="FILENAME">.bashrc</tt> или, даже в своих сценариях!</p>

        <div
         class="EXAMPLE">
          <a
           name="BASHRC"></a>

          <p><strong>Пример G-1. Пример файла <tt
           class="FILENAME">.bashrc</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#===============================================================
#
# ЛИЧНЫЙ ФАЙЛ $HOME/.bashrc для bash-2.05a (или выше)
#
# Время последней модификации: Втр Апр 15 20:32:34 CEST 2003
#
# Этот файл содержит настройки интерактивной командной оболочки.
# Здесь размещены определения псевдонимов, функций
# и других элементов Bash, таких как prompt (приглашение к вводу).
#
# Изначально, этот файл был создан в операционной системе Solaris,
# но позднее был переделан под Redhat
# --&gt; Модифицирован под Linux.
# Большая часть кода, который находится здесь, была взята из
# Usenet (или Интернет).
# Этот файл содержит слишком много определений -- помните, это всего лишь пример.
#
#
#===============================================================

# --&gt; Комментарии, добавленные автором HOWTO.
# --&gt; И дополнены автором сценария Emmanuel Rouat :-)

#-----------------------------------
# Глобальные определения
#-----------------------------------

if [ -f /etc/bashrc ]; then
        . /etc/bashrc   # --&gt; Прочитать настройки из /etc/bashrc, если таковой имеется.
fi

#-------------------------------------------------------------
# Настройка переменной $DISPLAY (если еще не установлена)
# Это срабатывает под linux - в вашем случае все может быть по другому....
# Проблема в том, что различные типы терминалов
# дают разные ответы на запрос &#39;who am i&#39;......
# я не нашел &#39;универсального&#39; метода
#-------------------------------------------------------------

function get_xserver ()
{
    case $TERM in
        xterm )
            XSERVER=$(who am i | awk &#39;{print $NF}&#39; | tr -d &#39;)&#39;&#39;(&#39; )
            XSERVER=${XSERVER%%:*}
            ;;
        aterm | rxvt)
        # добавьте здесь свой код.....
            ;;
    esac
}

if [ -z ${DISPLAY:=&quot;&quot;} ]; then
    get_xserver
    if [[ -z ${XSERVER}  || ${XSERVER} == $(hostname) || ${XSERVER} == &quot;unix&quot; ]]; then
        DISPLAY=&quot;:0.0&quot;          # для локального хоста
    else
        DISPLAY=${XSERVER}:0.0  # для удаленного хоста
    fi
fi

export DISPLAY

#---------------
# Некоторые настройки
#---------------

ulimit -S -c 0          # Запрет на создание файлов coredump
set -o notify
set -o noclobber
set -o ignoreeof
set -o nounset
#set -o xtrace          # полезно для отладки

# Разрешающие настройки:
shopt -s cdspell
shopt -s cdable_vars
shopt -s checkhash
shopt -s checkwinsize
shopt -s mailwarn
shopt -s sourcepath
shopt -s no_empty_cmd_completion  # только для bash&gt;=2.04
shopt -s cmdhist
shopt -s histappend histreedit histverify
shopt -s extglob

# Запрещающие настройки:
shopt -u mailwarn
unset MAILCHECK         # Я не желаю, чтобы командная оболочка сообщала мне о прибытии почты


export TIMEFORMAT=$&#39;\nreal %3R\tuser %3U\tsys %3S\tpcpu %P\n&#39;
export HISTIGNORE=&quot;&amp;:bg:fg:ll:h&quot;
export HOSTFILE=$HOME/.hosts    # Поместить список удаленных хостов в файл ~/.hosts



#-----------------------
# Greeting, motd etc...
#-----------------------

# Для начала определить некоторые цвета:
red=&#39;\e[0;31m&#39;
RED=&#39;\e[1;31m&#39;
blue=&#39;\e[0;34m&#39;
BLUE=&#39;\e[1;34m&#39;
cyan=&#39;\e[0;36m&#39;
CYAN=&#39;\e[1;36m&#39;
NC=&#39;\e[0m&#39;              # No Color (нет цвета)
# --&gt; Прекрасно. Имеет тот же эффект, что и &quot;ansi.sys&quot; в DOS.

# Лучше выглядит на черном фоне.....
echo -e &quot;${CYAN}This is BASH ${RED}${BASH_VERSION%.*}${CYAN} - DISPLAY on ${RED}$DISPLAY${NC}\n&quot;
date
if [ -x /usr/games/fortune ]; then
    /usr/games/fortune -s     # сделает наш день более интересным.... :-)
fi

function _exit()        # функция, запускающаяся при выходе из оболочки
{
    echo -e &quot;${RED}Аста ла виста, бэби ${NC}&quot;
}
trap _exit EXIT

#---------------
# Prompt
#---------------

if [[ &quot;${DISPLAY#$HOST}&quot; != &quot;:0.0&quot; &amp;&amp;  &quot;${DISPLAY}&quot; != &quot;:0&quot; ]]; then
    HILIT=${red}   # на удаленной системе: prompt будет частично красным
else
    HILIT=${cyan}  # на локальной системе: prompt будет частично циановым
fi

#  --&gt; Замените \W на \w в функциях ниже
#+ --&gt; чтобы видеть в оболочке полный путь к текущему каталогу.

function fastprompt()
{
    unset PROMPT_COMMAND
    case $TERM in
        *term | rxvt )
            PS1=&quot;${HILIT}[\h]$NC \W &gt; \[\033]0;\${TERM} [\u@\h] \w\007\]&quot; ;;
        linux )
            PS1=&quot;${HILIT}[\h]$NC \W &gt; &quot; ;;
        *)
            PS1=&quot;[\h] \W &gt; &quot; ;;
    esac
}

function powerprompt()
{
    _powerprompt()
    {
        LOAD=$(uptime|sed -e &quot;s/.*: \([^,]*\).*/\1/&quot; -e &quot;s/ //g&quot;)
    }

    PROMPT_COMMAND=_powerprompt
    case $TERM in
        *term | rxvt  )
            PS1=&quot;${HILIT}[\A \$LOAD]$NC\n[\h \#] \W &gt; \[\033]0;\${TERM} [\u@\h] \w\007\]&quot; ;;
        linux )
            PS1=&quot;${HILIT}[\A - \$LOAD]$NC\n[\h \#] \w &gt; &quot; ;;
        * )
            PS1=&quot;[\A - \$LOAD]\n[\h \#] \w &gt; &quot; ;;
    esac
}

powerprompt     # это prompt по-умолчанию - может работать довольно медленно
                # Если это так, то используйте fastprompt....

#===============================================================
#
# ПСЕВДОНИМЫ И ФУНКЦИИ
#
# Возможно некоторые из функций, приведенных здесь, окажутся для вас слишком большими,
# но на моей рабочей станции установлено 512Mb ОЗУ, так что.....
# Если пожелаете уменьшить размер этого файла, то можете оформить эти функции
# в виде отдельных сценариев.
#
# Большинство функций были взяты, почти без переделки, из примеров
# к bash-2.04.
#
#===============================================================

#-------------------
# Псевдонимы
#-------------------

alias rm=&#39;rm -i&#39;
alias cp=&#39;cp -i&#39;
alias mv=&#39;mv -i&#39;
# -&gt; Предотвращает случайное удаление файлов.
alias mkdir=&#39;mkdir -p&#39;

alias h=&#39;history&#39;
alias j=&#39;jobs -l&#39;
alias r=&#39;rlogin&#39;
alias which=&#39;type -all&#39;
alias ..=&#39;cd ..&#39;
alias path=&#39;echo -e ${PATH//:/\\n}&#39;
alias print=&#39;/usr/bin/lp -o nobanner -d $LPDEST&#39;   # Предполагается, что LPDEST определен
alias pjet=&#39;enscript -h -G -fCourier9 -d $LPDEST&#39;  # Печать через enscript
alias background=&#39;xv -root -quit -max -rmode 5&#39;    # Положить картинку в качестве фона
alias du=&#39;du -kh&#39;
alias df=&#39;df -kTh&#39;

# Различные варианты &#39;ls&#39; (предполагается, что установлена GNU-версия ls)
alias la=&#39;ls -Al&#39;               # показать скрытые файлы
alias ls=&#39;ls -hF --color&#39;       # выделить различные типы файлов цветом
alias lx=&#39;ls -lXB&#39;              # сортировка по расширению
alias lk=&#39;ls -lSr&#39;              # сортировка по размеру
alias lc=&#39;ls -lcr&#39;              # сортировка по времени изменения
alias lu=&#39;ls -lur&#39;              # сортировка по времени последнего обращения
alias lr=&#39;ls -lR&#39;               # рекурсивный обход подкаталогов
alias lt=&#39;ls -ltr&#39;              # сортировка по дате
alias lm=&#39;ls -al |more&#39;         # вывод через &#39;more&#39;
alias tree=&#39;tree -Csu&#39;          # альтернатива &#39;ls&#39;

# подготовка &#39;less&#39;
alias more=&#39;less&#39;
export PAGER=less
export LESSCHARSET=&#39;latin1&#39;
export LESSOPEN=&#39;|/usr/bin/lesspipe.sh %s 2&gt;&amp;-&#39; # если существует lesspipe.sh
export LESS=&#39;-i -N -w  -z-4 -g -e -M -X -F -R -P%t?f%f \
:stdin .?pb%pb\%:?lbLine %lb:?bbByte %bb:-...&#39;

# проверка правописания - настоятельно рекомендую :-)
alias xs=&#39;cd&#39;
alias vf=&#39;cd&#39;
alias moer=&#39;more&#39;
alias moew=&#39;more&#39;
alias kk=&#39;ll&#39;

#----------------
# добавим немножко &quot;приятностей&quot;
#----------------

function xtitle ()
{
    case &quot;$TERM&quot; in
        *term | rxvt)
            echo -n -e &quot;\033]0;$*\007&quot; ;;
        *)
            ;;
    esac
}

# псевдонимы...
alias top=&#39;xtitle Processes on $HOST &amp;&amp; top&#39;
alias make=&#39;xtitle Making $(basename $PWD) ; make&#39;
alias ncftp=&quot;xtitle ncFTP ; ncftp&quot;

# .. и функции
function man ()
{
    for i ; do
        xtitle The $(basename $1|tr -d .[:digit:]) manual
        command man -F -a &quot;$i&quot;
    done
}

function ll(){ ls -l &quot;$@&quot;| egrep &quot;^d&quot; ; ls -lXB &quot;$@&quot; 2&gt;&amp;-| egrep -v &quot;^d|total &quot;; }
function te()  # &quot;обертка&quot; вокруг xemacs/gnuserv
{
    if [ &quot;$(gnuclient -batch -eval t 2&gt;&amp;-)&quot; == &quot;t&quot; ]; then
        gnuclient -q &quot;$@&quot;;
    else
        ( xemacs &quot;$@&quot; &amp;);
    fi
}

#-----------------------------------
# Функции для работы с файлами и строками:
#-----------------------------------

# Поиск файла по шаблону:
function ff() { find . -type f -iname &#39;*&#39;$*&#39;*&#39; -ls ; }
# Поиск файла по шаблону в $1 и запуск команды в $2 с ним:
function fe() { find . -type f -iname &#39;*&#39;$1&#39;*&#39; -exec &quot;${2:-file}&quot; {} \;  ; }
# поиск строки по файлам:
function fstr()
{
    OPTIND=1
    local case=&quot;&quot;
    local usage=&quot;fstr: поиск строки в файлах.
Порядок использования: fstr [-i] \&quot;шаблон\&quot; [\&quot;шаблон_имени_файла\&quot;] &quot;
    while getopts :it opt
    do
        case &quot;$opt&quot; in
        i) case=&quot;-i &quot; ;;
        *) echo &quot;$usage&quot;; return;;
        esac
    done
    shift $(( $OPTIND - 1 ))
    if [ &quot;$#&quot; -lt 1 ]; then
        echo &quot;$usage&quot;
        return;
    fi
    local SMSO=$(tput smso)
    local RMSO=$(tput rmso)
    find . -type f -name &quot;${2:-*}&quot; -print0 | xargs -0 grep -sn ${case} &quot;$1&quot; 2&gt;&amp;- | \
sed &quot;s/$1/${SMSO}\0${RMSO}/gI&quot; | more
}

function cuttail() # удалить последние n строк в файле, по-умолчанию 10
{
    nlines=${2:-10}
    sed -n -e :a -e &quot;1,${nlines}!{P;N;D;};N;ba&quot; $1
}

function lowercase()  # перевести имя файла в нижний регистр
{
    for file ; do
        filename=${file##*/}
        case &quot;$filename&quot; in
        */*) dirname==${file%/*} ;;
        *) dirname=.;;
        esac
        nf=$(echo $filename | tr A-Z a-z)
        newname=&quot;${dirname}/${nf}&quot;
        if [ &quot;$nf&quot; != &quot;$filename&quot; ]; then
            mv &quot;$file&quot; &quot;$newname&quot;
            echo &quot;lowercase: $file --&gt; $newname&quot;
        else
            echo &quot;lowercase: имя файла $file не было изменено.&quot;
        fi
    done
}

function swap()         # меняет 2 файла местами
{
    local TMPFILE=tmp.$$
    mv &quot;$1&quot; $TMPFILE
    mv &quot;$2&quot; &quot;$1&quot;
    mv $TMPFILE &quot;$2&quot;
}


#-----------------------------------
# Функции для работы с процессами/системой:
#-----------------------------------

function my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }
function pp() { my_ps f | awk &#39;!/awk/ &amp;&amp; $0~var&#39; var=${1:-&quot;.*&quot;} ; }

# Эта функция является грубым аналогом &#39;killall&#39; в linux
# но не эквивалентна (насколько я знаю) &#39;killall&#39; в Solaris
function killps()   # &quot;Прибить&quot; процесс по его имени
{
    local pid pname sig=&quot;-TERM&quot;   # сигнал, рассылаемый по-умолчанию
    if [ &quot;$#&quot; -lt 1 ] || [ &quot;$#&quot; -gt 2 ]; then
        echo &quot;Порядок использования: killps [-SIGNAL] шаблон_имени_процесса&quot;
        return;
    fi
    if [ $# = 2 ]; then sig=$1 ; fi
    for pid in $(my_ps| awk &#39;!/awk/ &amp;&amp; $0~pat { print $1 }&#39; pat=${!#} ) ; do
        pname=$(my_ps | awk &#39;$1~var { print $5 }&#39; var=$pid )
        if ask &quot;Послать сигнал $sig процессу $pid &lt;$pname&gt;?&quot;
            then kill $sig $pid
        fi
    done
}

function my_ip() # IP адрес
{
    MY_IP=$(/sbin/ifconfig ppp0 | awk &#39;/inet/ { print $2 } &#39; | sed -e s/addr://)
    MY_ISP=$(/sbin/ifconfig ppp0 | awk &#39;/P-t-P/ { print $3 } &#39; | sed -e s/P-t-P://)
}

function ii()   # Дополнительные сведения о системе
{
    echo -e &quot;\nВы находитесь на ${RED}$HOST&quot;
    echo -e &quot;\nДополнительная информация:$NC &quot; ; uname -a
    echo -e &quot;\n${RED}В системе работают пользователи:$NC &quot; ; w -h
    echo -e &quot;\n${RED}Дата:$NC &quot; ; date
    echo -e &quot;\n${RED}Время, прошедшее с момента последней перезагрузки :$NC &quot; ; uptime
    echo -e &quot;\n${RED}Память :$NC &quot; ; free
    my_ip 2&gt;&amp;- ;
    echo -e &quot;\n${RED}IP адрес:$NC&quot; ; echo ${MY_IP:-&quot;Соединение не установлено&quot;}
    echo -e &quot;\n${RED}Адрес провайдера (ISP):$NC&quot; ; echo ${MY_ISP:-&quot;Соединение не установлено&quot;}
    echo
}

# Разные утилиты:

function repeat()       # повторить команду n раз
{
    local i max
    max=$1; shift;
    for ((i=1; i &lt;= max ; i++)); do  # --&gt; C-подобный синтаксис
        eval &quot;$@&quot;;
    done
}

function ask()
{
    echo -n &quot;$@&quot; &#39;[y/n] &#39; ; read ans
    case &quot;$ans&quot; in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}

#=========================================================================
#
# ПРОГРАММНЫЕ ДОПОЛНЕНИЯ - ТОЛЬКО НАЧИНАЯ С ВЕРСИИ BASH-2.04
# Большая часть дополнений взята из докуентации к bash 2.05  и из
# пакета &#39;Bash completion&#39; (http://www.caliban.org/bash/index.shtml#completion)
# автор -- Ian McDonalds
# Фактически, у вас должен стоять bash-2.05a
#
#=========================================================================

if [ &quot;${BASH_VERSION%.*}&quot; \&lt; &quot;2.05&quot; ]; then
    echo &quot;Вам необходимо обновиться до версии 2.05&quot;
    return
fi

shopt -s extglob        # необходимо
set +o nounset          # иначе некоторые дополнения не будут работать

complete -A hostname   rsh rcp telnet rlogin r ftp ping disk
complete -A export     printenv
complete -A variable   export local readonly unset
complete -A enabled    builtin
complete -A alias      alias unalias
complete -A function   function
complete -A user       su mail finger

complete -A helptopic  help
complete -A shopt      shopt
complete -A stopped -P &#39;%&#39; bg
complete -A job -P &#39;%&#39;     fg jobs disown

complete -A directory  mkdir rmdir
complete -A directory   -o default cd

# Архивация
complete -f -o default -X &#39;*.+(zip|ZIP)&#39;  zip
complete -f -o default -X &#39;!*.+(zip|ZIP)&#39; unzip
complete -f -o default -X &#39;*.+(z|Z)&#39;      compress
complete -f -o default -X &#39;!*.+(z|Z)&#39;     uncompress
complete -f -o default -X &#39;*.+(gz|GZ)&#39;    gzip
complete -f -o default -X &#39;!*.+(gz|GZ)&#39;   gunzip
complete -f -o default -X &#39;*.+(bz2|BZ2)&#39;  bzip2
complete -f -o default -X &#39;!*.+(bz2|BZ2)&#39; bunzip2
# Postscript,pdf,dvi.....
complete -f -o default -X &#39;!*.ps&#39;  gs ghostview ps2pdf ps2ascii
complete -f -o default -X &#39;!*.dvi&#39; dvips dvipdf xdvi dviselect dvitype
complete -f -o default -X &#39;!*.pdf&#39; acroread pdf2ps
complete -f -o default -X &#39;!*.+(pdf|ps)&#39; gv
complete -f -o default -X &#39;!*.texi*&#39; makeinfo texi2dvi texi2html texi2pdf
complete -f -o default -X &#39;!*.tex&#39; tex latex slitex
complete -f -o default -X &#39;!*.lyx&#39; lyx
complete -f -o default -X &#39;!*.+(htm*|HTM*)&#39; lynx html2ps
# Multimedia
complete -f -o default -X &#39;!*.+(jp*g|gif|xpm|png|bmp)&#39; xv gimp
complete -f -o default -X &#39;!*.+(mp3|MP3)&#39; mpg123 mpg321
complete -f -o default -X &#39;!*.+(ogg|OGG)&#39; ogg123



complete -f -o default -X &#39;!*.pl&#39;  perl perl5

# Эти &#39;универсальные&#39; дополнения работают тогда, когда команды вызываются
# с, так называемыми, &#39;длинными ключами&#39;, например: &#39;ls --all&#39; вместо &#39;ls -a&#39;

_get_longopts ()
{
    $1 --help | sed  -e &#39;/--/!d&#39; -e &#39;s/.*--\([^[:space:].,]*\).*/--\1/&#39;| \
grep ^&quot;$2&quot; |sort -u ;
}

_longopts_func ()
{
    case &quot;${2:-*}&quot; in
        -*)     ;;
        *)      return ;;
    esac

    case &quot;$1&quot; in
        \~*)    eval cmd=&quot;$1&quot; ;;
        *)      cmd=&quot;$1&quot; ;;
    esac
    COMPREPLY=( $(_get_longopts ${1} ${2} ) )
}
complete  -o default -F _longopts_func configure bash
complete  -o default -F _longopts_func wget id info a2ps ls recode


_make_targets ()
{
    local mdef makef gcmd cur prev i

    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    # Если аргумент prev это -f, то вернуть возможные варианты имен файлов.
    # будем великодушны и вернем несколько вариантов
    # `makefile Makefile *.mk&#39;
    case &quot;$prev&quot; in
        -*f)    COMPREPLY=( $(compgen -f $cur ) ); return 0;;
    esac

    # Если запрошены возможные ключи, то вернуть ключи posix
    case &quot;$cur&quot; in
        -)      COMPREPLY=(-e -f -i -k -n -p -q -r -S -s -t); return 0;;
    esac

    # попробовать передать make `makefile&#39; перед тем как попробовать передать `Makefile&#39;
    if [ -f makefile ]; then
        mdef=makefile
    elif [ -f Makefile ]; then
        mdef=Makefile
    else
        mdef=*.mk
    fi

    # прежде чем просмотреть &quot;цели&quot;, убедиться, что имя makefile было задано
    # ключом -f
    for (( i=0; i &lt; ${#COMP_WORDS[@]}; i++ )); do
        if [[ ${COMP_WORDS[i]} == -*f ]]; then
            eval makef=${COMP_WORDS[i+1]}
            break
        fi
    done

        [ -z &quot;$makef&quot; ] &amp;&amp; makef=$mdef

    # Если задан шаблон поиска, то ограничиться
    # этим шаблоном
    if [ -n &quot;$2&quot; ]; then gcmd=&#39;grep &quot;^$2&quot;&#39; ; else gcmd=cat ; fi

    # если мы не желаем использовать *.mk, то необходимо убрать cat и использовать
    # test -f $makef с перенаправлением ввода
    COMPREPLY=( $(cat $makef 2&gt;/dev/null | awk &#39;BEGIN {FS=&quot;:&quot;} /^[^.#   ][^=]*:/ {print $1}&#39; | tr -s &#39; &#39; &#39;\012&#39; | sort -u | eval $gcmd ) )
}

complete -F _make_targets -X &#39;+($*|*.[cho])&#39; make gmake pmake


# cvs(1) completion
_cvs ()
{
    local cur prev
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    if [ $COMP_CWORD -eq 1 ] || [ &quot;${prev:0:1}&quot; = &quot;-&quot; ]; then
        COMPREPLY=( $( compgen -W &#39;add admin checkout commit diff \
        export history import log rdiff release remove rtag status \
        tag update&#39; $cur ))
    else
        COMPREPLY=( $( compgen -f $cur ))
    fi
    return 0
}
complete -F _cvs cvs

_killall ()
{
    local cur prev
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}

    # получить список процессов
    COMPREPLY=( $( /usr/bin/ps -u $USER -o comm  | \
        sed -e &#39;1,1d&#39; -e &#39;s#[]\[]##g&#39; -e &#39;s#^.*/##&#39;| \
        awk &#39;{if ($0 ~ /^&#39;$cur&#39;/) print $0}&#39; ))

    return 0
}

complete -F _killall killall killps


# Функция обработки мета-команд
# В настоящее время недостаточно отказоустойчива (например, mount и umount
# обрабатываются некорректно), но все еще актуальна. Автор Ian McDonald, изменена мной.

_my_command()
{
    local cur func cline cspec

    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}

    if [ $COMP_CWORD = 1 ]; then
        COMPREPLY=( $( compgen -c $cur ) )
    elif complete -p ${COMP_WORDS[1]} &amp;&gt;/dev/null; then
        cspec=$( complete -p ${COMP_WORDS[1]} )
        if [ &quot;${cspec%%-F *}&quot; != &quot;${cspec}&quot; ]; then
            # complete -F &lt;function&gt;
            #
            # COMP_CWORD and COMP_WORDS() доступны на запись,
            # так что мы можем установить их перед тем,
            # как передать их дальше

            # уменьшить на 1 текущий номер лексемы
            COMP_CWORD=$(( $COMP_CWORD - 1 ))
            # получить имя функции
            func=${cspec#*-F }
            func=${func%% *}
            # получить командную строку, исключив первую команду
            cline=&quot;${COMP_LINE#$1 }&quot;
            # разбить на лексемы и поместить в массив
                COMP_WORDS=( $cline )
            $func $cline
        elif [ &quot;${cspec#*-[abcdefgjkvu]}&quot; != &quot;&quot; ]; then
            # complete -[abcdefgjkvu]
            #func=$( echo $cspec | sed -e &#39;s/^.*\(-[abcdefgjkvu]\).*$/\1/&#39; )
            func=$( echo $cspec | sed -e &#39;s/^complete//&#39; -e &#39;s/[^ ]*$//&#39; )
            COMPREPLY=( $( eval compgen $func $cur ) )
        elif [ &quot;${cspec#*-A}&quot; != &quot;$cspec&quot; ]; then
            # complete -A &lt;type&gt;
            func=${cspec#*-A }
        func=${func%% *}
        COMPREPLY=( $( compgen -A $func $cur ) )
        fi
    else
        COMPREPLY=( $( compgen -f $cur ) )
    fi
}


complete -o default -F _my_command nohup exec eval trace truss strace sotruss gdb
complete -o default -F _my_command command type which man nice

# Локальные переменные:
# mode:shell-script
# sh-shell:bash
# Конец:
</pre>
        </div>
      </div>

      <div
       class="APPENDIX">
        <hr>

        <h1><a
         name="DOSBATCH"></a>Приложение H. Преобразование пакетных
        (*.bat) файлов DOS в сценарии командной оболочки</h1>

        <p><a
         name="DOSBATCH1"></a></p>

        <p>Большое число программистов начинало изучать скриптовые
        языки на PC, работающих под управлением DOS. Даже на этом
        &quot;калеке&quot; удавалось создавать неплохие сценарии, хотя
        это и требовало значительных усилий. Иногда еще возникает
        потребность в переносе пекетных файлов DOS на платформу UNIX, в
        виде сценариев командной оболочки. Обычно это не сложно,
        поскольку набор операторов, доступных в DOS, представляет из
        себя ограниченное подмножество эквивалентных команд, доступных
        в командной оболочке.</p>

        <div
         class="TABLE">
          <a
           name="AEN15143"></a>

          <p><strong>Таблица H-1. Ключевые слова/переменные/операторы
          пакетных файлов DOS и их аналоги командной
          оболочки</strong></p>

          <table
           border="1"
           class="CALSTABLE">
            <thead>
              <tr>
                <th
                 align="left"
                 valign="top">Операторы пакетных файлов</th>

                <th
                 align="left"
                 valign="top">Эквивалентные команды в UNIX</th>

                <th
                 align="left"
                 valign="top">Описание</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">%</tt></td>

                <td
                 align="left"
                 valign="top">$</td>

                <td
                 align="left"
                 valign="top">префикс аргументов командной строки</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">/</tt></td>

                <td
                 align="left"
                 valign="top">-</td>

                <td
                 align="left"
                 valign="top">признак ключа (опции)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">\</tt></td>

                <td
                 align="left"
                 valign="top">/</td>

                <td
                 align="left"
                 valign="top">разделитель имен каталогов в пути</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">==</tt></td>

                <td
                 align="left"
                 valign="top">=</td>

                <td
                 align="left"
                 valign="top">(равно) сравнение строк</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">!==!</tt></td>

                <td
                 align="left"
                 valign="top">!=</td>

                <td
                 align="left"
                 valign="top">(не равно) сравнение строк</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">|</tt></td>

                <td
                 align="left"
                 valign="top">|</td>

                <td
                 align="left"
                 valign="top">конвейер (канал)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">@</tt></td>

                <td
                 align="left"
                 valign="top">set <tt
                 class="OPTION">+v</tt></td>

                <td
                 align="left"
                 valign="top">не выводить текущую команду</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">*</tt></td>

                <td
                 align="left"
                 valign="top">*</td>

                <td
                 align="left"
                 valign="top"><span
                 class="QUOTE">&quot;шаблонный символ&quot;</span> в
                имени файла</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">&gt;</tt></td>

                <td
                 align="left"
                 valign="top">&gt;</td>

                <td
                 align="left"
                 valign="top">перенаправление (с удалением
                существующего файла)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">&gt;&gt;</tt></td>

                <td
                 align="left"
                 valign="top">&gt;&gt;</td>

                <td
                 align="left"
                 valign="top">перенаправление (с добавлением в конец
                существующего файла)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">&lt;</tt></td>

                <td
                 align="left"
                 valign="top">&lt;</td>

                <td
                 align="left"
                 valign="top">перенаправление ввода <tt
                 class="FILENAME">stdin</tt></td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">%VAR%</tt></td>

                <td
                 align="left"
                 valign="top">$VAR</td>

                <td
                 align="left"
                 valign="top">переменная окружения</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">REM</tt></td>

                <td
                 align="left"
                 valign="top">#</td>

                <td
                 align="left"
                 valign="top">комментарий</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">NOT</tt></td>

                <td
                 align="left"
                 valign="top">!</td>

                <td
                 align="left"
                 valign="top">отрицание последующего условия</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">NUL</tt></td>

                <td
                 align="left"
                 valign="top"><tt
                 class="FILENAME">/dev/null</tt></td>

                <td
                 align="left"
                 valign="top"><span
                 class="QUOTE">&quot;черная дыра&quot;</span> для того,
                чтобы &quot;спрятать&quot; вывод команды</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">ECHO</tt></td>

                <td
                 align="left"
                 valign="top">echo</td>

                <td
                 align="left"
                 valign="top">вывод (в Bash имеет большое число
                опций)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">ECHO.</tt></td>

                <td
                 align="left"
                 valign="top">echo</td>

                <td
                 align="left"
                 valign="top">вывод пустой строки</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">ECHO OFF</tt></td>

                <td
                 align="left"
                 valign="top">set <tt
                 class="OPTION">+v</tt></td>

                <td
                 align="left"
                 valign="top">не выводить последующие команды</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">FOR %%VAR IN (LIST) DO</tt></td>

                <td
                 align="left"
                 valign="top">for var in [list]; do</td>

                <td
                 align="left"
                 valign="top">цикл <span
                 class="QUOTE">&quot;for&quot;</span></td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">:LABEL</tt></td>

                <td
                 align="left"
                 valign="top">эквивалент отсутствует (нет
                необходимости)</td>

                <td
                 align="left"
                 valign="top">метка</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">GOTO</tt></td>

                <td
                 align="left"
                 valign="top">эквивалент отсутствует (используйте
                функции)</td>

                <td
                 align="left"
                 valign="top">переход по заданной метке</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">PAUSE</tt></td>

                <td
                 align="left"
                 valign="top">sleep</td>

                <td
                 align="left"
                 valign="top">пауза, или ожидание, в течение заданного
                времени</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">CHOICE</tt></td>

                <td
                 align="left"
                 valign="top">case или select</td>

                <td
                 align="left"
                 valign="top">выбор из меню</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">IF</tt></td>

                <td
                 align="left"
                 valign="top">if</td>

                <td
                 align="left"
                 valign="top">условный оператор if</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">IF EXIST <tt
                 class="REPLACEABLE"><em>FILENAME</em></tt></tt></td>

                <td
                 align="left"
                 valign="top">if [ -e filename ]</td>

                <td
                 align="left"
                 valign="top">проверка существования файла</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">IF !%N==!</tt></td>

                <td
                 align="left"
                 valign="top">if [ -z &quot;$N&quot; ]</td>

                <td
                 align="left"
                 valign="top">Проверка: параметр <span
                 class="QUOTE">&quot;N&quot;</span> отсутствует</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">CALL</tt></td>

                <td
                 align="left"
                 valign="top">source или . (оператор
                &quot;точка&quot;)</td>

                <td
                 align="left"
                 valign="top"><span
                 class="QUOTE">&quot;подключение&quot;</span> другого
                сценария</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">COMMAND /C</tt></td>

                <td
                 align="left"
                 valign="top">source или . (оператор
                &quot;точка&quot;)</td>

                <td
                 align="left"
                 valign="top"><span
                 class="QUOTE">&quot;подключение&quot;</span> другого
                сценария (то же, что и CALL)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">SET</tt></td>

                <td
                 align="left"
                 valign="top">export</td>

                <td
                 align="left"
                 valign="top">установить переменную окружения</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">SHIFT</tt></td>

                <td
                 align="left"
                 valign="top">shift</td>

                <td
                 align="left"
                 valign="top">сдвиг списка аргументов уомандной строки
                влево</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">SGN</tt></td>

                <td
                 align="left"
                 valign="top">-lt или -gt</td>

                <td
                 align="left"
                 valign="top">знак (целого числа)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">ERRORLEVEL</tt></td>

                <td
                 align="left"
                 valign="top">$?</td>

                <td
                 align="left"
                 valign="top">код завершения</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">CON</tt></td>

                <td
                 align="left"
                 valign="top"><tt
                 class="FILENAME">stdin</tt></td>

                <td
                 align="left"
                 valign="top"><span
                 class="QUOTE">&quot;консоль&quot;</span> (<tt
                 class="FILENAME">stdin</tt>)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">PRN</tt></td>

                <td
                 align="left"
                 valign="top"><tt
                 class="FILENAME">/dev/lp0</tt></td>

                <td
                 align="left"
                 valign="top">устройство принтера</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">LPT1</tt></td>

                <td
                 align="left"
                 valign="top"><tt
                 class="FILENAME">/dev/lp0</tt></td>

                <td
                 align="left"
                 valign="top">устройство принтера</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">COM1</tt></td>

                <td
                 align="left"
                 valign="top"><tt
                 class="FILENAME">/dev/ttyS0</tt></td>

                <td
                 align="left"
                 valign="top">первый последовательный порт</td>
              </tr>
            </tbody>
          </table>
        </div>

        <p>Пакетные файлы обычно содержат вызовы команд DOS. Они должны
        быть заменены эквивалентными командами UNIX.</p>

        <div
         class="TABLE">
          <a
           name="AEN15350"></a>

          <p><strong>Таблица H-2. Команды DOS и их эквиваленты в
          UNIX</strong></p>

          <table
           border="1"
           class="CALSTABLE">
            <thead>
              <tr>
                <th
                 align="left"
                 valign="top">Команды DOS</th>

                <th
                 align="left"
                 valign="top">Эувивалент в UNIX</th>

                <th
                 align="left"
                 valign="top">Описание</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">ASSIGN</tt></td>

                <td
                 align="left"
                 valign="top">ln</td>

                <td
                 align="left"
                 valign="top">ссылка на файл или каталог</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">ATTRIB</tt></td>

                <td
                 align="left"
                 valign="top">chmod</td>

                <td
                 align="left"
                 valign="top">изменить атрибуты файла (права
                доступа)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">CD</tt></td>

                <td
                 align="left"
                 valign="top">cd</td>

                <td
                 align="left"
                 valign="top">сменить каталог</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">CHDIR</tt></td>

                <td
                 align="left"
                 valign="top">cd</td>

                <td
                 align="left"
                 valign="top">сменить каталог</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">CLS</tt></td>

                <td
                 align="left"
                 valign="top">clear</td>

                <td
                 align="left"
                 valign="top">очистить экран</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">COMP</tt></td>

                <td
                 align="left"
                 valign="top">diff, comm, cmp</td>

                <td
                 align="left"
                 valign="top">сравнить файлы</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">COPY</tt></td>

                <td
                 align="left"
                 valign="top">cp</td>

                <td
                 align="left"
                 valign="top">скопировать файл</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">Ctl-C</tt></td>

                <td
                 align="left"
                 valign="top">Ctl-C</td>

                <td
                 align="left"
                 valign="top">прервать исполнение сценария</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">Ctl-Z</tt></td>

                <td
                 align="left"
                 valign="top">Ctl-D</td>

                <td
                 align="left"
                 valign="top">EOF (конец-файла)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">DEL</tt></td>

                <td
                 align="left"
                 valign="top">rm</td>

                <td
                 align="left"
                 valign="top">удалить файл(ы)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">DELTREE</tt></td>

                <td
                 align="left"
                 valign="top">rm -rf</td>

                <td
                 align="left"
                 valign="top">удалить каталог с подкаталогами</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">DIR</tt></td>

                <td
                 align="left"
                 valign="top">ls -l</td>

                <td
                 align="left"
                 valign="top">вывести содержимое каталога</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">ERASE</tt></td>

                <td
                 align="left"
                 valign="top">rm</td>

                <td
                 align="left"
                 valign="top">удалить файл(ы)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">EXIT</tt></td>

                <td
                 align="left"
                 valign="top">exit</td>

                <td
                 align="left"
                 valign="top">завершить текущий процесс</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">FC</tt></td>

                <td
                 align="left"
                 valign="top">comm, cmp</td>

                <td
                 align="left"
                 valign="top">сравнить файлы</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">FIND</tt></td>

                <td
                 align="left"
                 valign="top">grep</td>

                <td
                 align="left"
                 valign="top">найти строку в файлах</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">MD</tt></td>

                <td
                 align="left"
                 valign="top">mkdir</td>

                <td
                 align="left"
                 valign="top">создать каталог</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">MKDIR</tt></td>

                <td
                 align="left"
                 valign="top">mkdir</td>

                <td
                 align="left"
                 valign="top">создать каталог</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">MORE</tt></td>

                <td
                 align="left"
                 valign="top">more</td>

                <td
                 align="left"
                 valign="top">постраничный вывод</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">MOVE</tt></td>

                <td
                 align="left"
                 valign="top">mv</td>

                <td
                 align="left"
                 valign="top">переместить</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">PATH</tt></td>

                <td
                 align="left"
                 valign="top">$PATH</td>

                <td
                 align="left"
                 valign="top">путь поиска исполняемых файлов</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">REN</tt></td>

                <td
                 align="left"
                 valign="top">mv</td>

                <td
                 align="left"
                 valign="top">переименовать (переместить)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">RENAME</tt></td>

                <td
                 align="left"
                 valign="top">mv</td>

                <td
                 align="left"
                 valign="top">переименовать (переместить)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">RD</tt></td>

                <td
                 align="left"
                 valign="top">rmdir</td>

                <td
                 align="left"
                 valign="top">удалить каталог</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">RMDIR</tt></td>

                <td
                 align="left"
                 valign="top">rmdir</td>

                <td
                 align="left"
                 valign="top">удалить каталог</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">SORT</tt></td>

                <td
                 align="left"
                 valign="top">sort</td>

                <td
                 align="left"
                 valign="top">отсортировать файл</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">TIME</tt></td>

                <td
                 align="left"
                 valign="top">date</td>

                <td
                 align="left"
                 valign="top">вывести системное время</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">TYPE</tt></td>

                <td
                 align="left"
                 valign="top">cat</td>

                <td
                 align="left"
                 valign="top">вывести содержимое файла на <tt
                 class="FILENAME">stdout</tt></td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">XCOPY</tt></td>

                <td
                 align="left"
                 valign="top">cp</td>

                <td
                 align="left"
                 valign="top">(расширенная команда) скопировать
                файл</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Фактически, команды и операторы командной оболочки
                UNIX имеют огромное количество дополнительных опций,
                расширяющих их функциональность, по сравнению с их
                эквивалентами в DOS. В большинстве своем, пакетные
                файлы DOS предполагают наличие вспомогательных утилит,
                таких как <strong
                 class="COMMAND">ask.com</strong> (&quot;увечный&quot;
                аналог UNIX-вого <a
                 href="#READREF">read</a>).</p>

                <p>DOS поддерживает крайне ограниченный набор шаблонных
                символов, учавствующих в операциях <a
                 href="#GLOBBINGREF">подстановки имен файлов</a>,
                распознавая только два символа -- <span
                 class="TOKEN">*</span> и <span
                 class="TOKEN">?</span>.</p>
              </td>
            </tr>
          </table>
        </div>

        <p>Преобразование пакетных файлов DOS в сценарии командной
        оболочки, обычно не вызывает затруднений, а результат такого
        преобразования читается гораздо лучше, чем оригинал.</p>

        <div
         class="EXAMPLE">
          <a
           name="VIEWDAT"></a>

          <p><strong>Пример H-1. VIEWDATA.BAT: пакетный файл
          DOS</strong></p>
<pre
 class="PROGRAMLISTING">
REM VIEWDATA

REM INSPIRED BY AN EXAMPLE IN &quot;DOS POWERTOOLS&quot;
REM                           BY PAUL SOMERSON


@ECHO OFF

IF !%1==! GOTO VIEWDATA
REM  IF NO COMMAND-LINE ARG...
FIND &quot;%1&quot; C:\BOZO\BOOKLIST.TXT
GOTO EXIT0
REM  PRINT LINE WITH STRING MATCH, THEN EXIT.

:VIEWDATA
TYPE C:\BOZO\BOOKLIST.TXT | MORE
REM  SHOW ENTIRE FILE, 1 PAGE AT A TIME.

:EXIT0
</pre>
        </div>

        <p>Результат преобразования в сценарий командной оболочки,
        немного улучшенный.</p>

        <div
         class="EXAMPLE">
          <a
           name="VIEWDATA"></a>

          <p><strong>Пример H-2. viewdata.sh: Результат преобразования
          VIEWDATA.BAT в сценарий командной оболочки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Результат преобразования пакетного файла VIEWDATA.BAT в сценарий командной оболочки.

DATAFILE=/home/bozo/datafiles/book-collection.data
ARGNO=1

# @ECHO OFF       Эта команда здесь не нужна.

if [ $# -lt &quot;$ARGNO&quot; ]    # IF !%1==! GOTO VIEWDATA
then
  less $DATAFILE          # TYPE C:\MYDIR\BOOKLIST.TXT | MORE
else
  grep &quot;$1&quot; $DATAFILE     # FIND &quot;%1&quot; C:\MYDIR\BOOKLIST.TXT
fi

exit 0                    # :EXIT0

# операторы перехода GOTO, метки и прочий &quot;мусор&quot; больше не нужны.
# Результат преобразования стал короче, чище и понятнее,
</pre>
        </div>

        <p>На сайте Тэда Дэвиса (Ted Davis) <a
         href="http://www.maem.umr.edu/~batch/"
         target="_top">Shell Scripts on the PC</a>, вы найдете большое
        число руководств по созданию пакетных файлов в DOS.
        Определенно, его изобретательность будет вам полезна, при
        создании ваших сценариев.</p>
      </div>

      <div
       class="APPENDIX">
        <hr>

        <h1><a
         name="EXERCISES"></a>Приложение I. Упражнения</h1>

        <div
         class="SECT1">
          <h2
           class="SECT1"><a
           name="SCRIPTANALYSIS"></a>I.1. Анализ сценариев</h2>

          <p>Просмотрите следующие сценарии. Попробуйте запустить их,
          затем объясните -- что они делают. Расставьте комментарии,
          затем попробуйте записать их в более компактном виде.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

MAX=10000


  for((nr=1; nr&lt;$MAX; nr++))
  do

    let &quot;t1 = nr % 5&quot;
    if [ &quot;$t1&quot; -ne 3 ]
    then
      continue
    fi

    let &quot;t2 = nr % 7&quot;
    if [ &quot;$t2&quot; -ne 4 ]
    then
      continue
    fi

    let &quot;t3 = nr % 9&quot;
    if [ &quot;$t3&quot; -ne 5 ]
    then
      continue
    fi

  break   # Что произойдет, если закомментировать эту строку? Почему?

  done

  echo &quot;Число = $nr&quot;


exit 0
</pre>
          <br>
          <br>

          <p>---</p>

          <p>Читатель прислал следующий кусок кода.</p>
<pre
 class="PROGRAMLISTING">
while read LINE
do
  echo $LINE
done &lt; `tail -f /var/log/messages`
</pre>
          Он предполагал написать сценарий, который отслеживал бы
          изменения в системном журнале <tt
           class="FILENAME">/var/log/messages</tt>. К сожалению, этот
          код &quot;зависает&quot; и не делает ничего полезного.
          Почему? Найдите ошибку и исправьте ее (подсказка: вместо
          операции <a
           href="#REDIRREF">перенаправления <tt
           class="FILENAME">stdin</tt> в цикл</a>, попробуйте
          использовать <a
           href="#PIPEREF">конвейерную обработку</a>).<br>
          <br>

          <p>---</p>

          <p>Просмотрите сценарий <a
           href="#LIFESLOW">Пример A-11</a>, попробуйте изменить его
          таким образом, чтобы он выглядел проще и логичнее. Удалите
          все &quot;лишние&quot; переменные и попытайтесь
          оптимизировать сценарий по скорости исполнения.</p>

          <p>Измените сценарий таким образом, чтобы он мог принимать
          начальную установку &quot;поколения 0&quot; из любого
          текстового файла. Сценарий должен считать первые <tt
           class="VARNAME">$ROW*$COL</tt> символов, и на место гласных
          вставлять &quot;живые особи&quot;. Подсказка: не забудьте
          преобразовать пробелы в символы подчеркивания.</p>
        </div>

        <div
         class="SECT1">
          <hr>

          <h2
           class="SECT1"><a
           name="WRITINGSCRIPTS"></a>I.2. Создание сценариев</h2>

          <p><a
           name="WRITINGSCRIPTS1"></a></p>

          <p>Напишите сценарии для выполнения повседневных задач.</p>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="EXEASY1"></a>Простые задания</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">Содержимое домашнего
              каталога</strong></dt>

              <dd>
                <p>Выполните рекурсивный обход домашнего каталога и
                сохраните информацию в файл. Сожмите файл. Попросите
                пользователя вставить дискету и нажать клавишу <strong
                 class="KEYCAP">ENTER</strong>. Запишите сжатый файл на
                дискету.</p>
              </dd>

              <dt><strong
               class="COMMAND">Замена цикла <a
               href="#FORLOOPREF1">for</a> циклами <a
               href="#WHILELOOPREF">while</a> и <a
               href="#UNTILLOOPREF">until</a></strong></dt>

              <dd>
                <p>Замените <span
                 class="emphasis"><em
                 class="EMPHASIS">циклы for</em></span> в <a
                 href="#EX22">Пример 10-1</a> на <span
                 class="emphasis"><em
                 class="EMPHASIS">while</em></span>. Подсказка:
                запишите данные в <a
                 href="#ARRAYREF">массив</a> и пройдите в цикле по
                элементам массива.</p>

                <p>Выполнив эту <span
                 class="QUOTE">&quot;тяжелую работу&quot;</span>,
                замените циклы, в этом примере, на циклы <span
                 class="emphasis"><em
                 class="EMPHASIS">until</em></span> .</p>
              </dd>

              <dt><strong
               class="COMMAND">Изменение межстрочного интервала в
              текстовом файле</strong></dt>

              <dd>
                <p>Напишите сценарий, который будет читать текст из
                заданного файла, и выводить, построчно, на <tt
                 class="FILENAME">stdout</tt>, добавляя при этом
                дополнительные пустые строки так, чтобы в результате
                получился вывод с <span
                 class="emphasis"><em
                 class="EMPHASIS">двойным межстрочным
                интервалом</em></span>.</p>

                <p>Добавьте код, который будет выполнять проверку
                наличия файла, передаваемого как аргумент.</p>

                <p>Когда сценарий будет отлажен, измените его так,
                чтобы он выводил текстовый файл с <span
                 class="emphasis"><em
                 class="EMPHASIS">тройным межстрочным
                интервалом</em></span>.</p>

                <p>И наконец, напишите сценарий, который будет удалять
                пустые строки из заданного файла.</p>
              </dd>

              <dt><strong
               class="COMMAND">Вывод
              &quot;задом-на-перед&quot;</strong></dt>

              <dd>
                <p>Напишите сценарий, который будет выводить себя на
                <tt
                 class="FILENAME">stdout</tt>, но <span
                 class="emphasis"><em
                 class="EMPHASIS">в обратном порядке</em></span>.</p>
              </dd>

              <dt><strong
               class="COMMAND">Автоматическое
              разархивирование</strong></dt>

              <dd>
                <p>Для каждого файла, из заданного списка, сценарий
                должен определить тип архиватора, которым был создан
                тот или иной файл (с помощью утилиты <a
                 href="#FILEREF">file</a>). Затем сценарий должен
                выполнить соответствующую команду разархивации (<strong
                 class="COMMAND">gunzip</strong>, <strong
                 class="COMMAND">bunzip2</strong>, <strong
                 class="COMMAND">unzip</strong>, <strong
                 class="COMMAND">uncompress</strong> или что-то иное).
                Если файл не является архивом, то сценарий должен
                оповестить пользователя об этом и ничего не делать с
                этим файлом.</p>
              </dd>

              <dt><strong
               class="COMMAND">Уникальный идентификатор
              системы</strong></dt>

              <dd>
                <p>Сценарий должен сгенерировать <span
                 class="QUOTE">&quot;уникальный&quot;</span> 6-ти
                разрядный шестнадцатиричный идентификатор системы.
                <span
                 class="emphasis"><em
                 class="EMPHASIS">Не</em></span> пользуйтесь дефектной
                утилитой <a
                 href="#HOSTIDREF">hostid</a>. Подсказка: <strong
                 class="COMMAND"><a
                 href="#MD5SUMREF">md5sum</a> <tt
                 class="FILENAME">/etc/passwd</tt></strong>, затем
                отберите первые 6 цифр.</p>
              </dd>

              <dt><strong
               class="COMMAND">Резервное копирование</strong></dt>

              <dd>
                <p>Сценарий должен создать архив (<tt
                 class="FILENAME">*.tar.gz</tt>) всех файлов в домашнем
                каталоге пользователя (<tt
                 class="FILENAME">/home/user-name</tt>), которые
                изменялись в течение последних 24 часов. Подсказка:
                воспользуйтесь утилитой <a
                 href="#FINDREF">find</a>.</p>
              </dd>

              <dt><strong
               class="COMMAND">Простые числа</strong></dt>

              <dd>
                <p>Сценарий должен вывести (на stdout) все простые
                числа, в диапазоне от 60000 до 63000. Вывод должен быть
                отформатирован по столбцам (подсказка: воспользуйтесь
                командой <a
                 href="#PRINTFREF">printf</a>).</p>
              </dd>

              <dt><strong
               class="COMMAND">Лототрон</strong></dt>

              <dd>
                <p>Сценарий должен имитировать работу лототрона --
                извлекать 5 случайных неповторяющихся чисел в диапазоне
                1 - 50. Сценарий должен предусматривать как вывод на
                <tt
                 class="FILENAME">stdout</tt>, так и запись чисел в
                файл, кроме того, вместе с числами должны выводиться
                дата и время генерации данного набора.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="EXMEDIUM1"></a>Задания повышенной
            сложности</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">Управление дисковым
              пространством</strong></dt>

              <dd>
                <p>Сценарий должен отыскать в домашнем каталоге
                пользователя <tt
                 class="FILENAME">/home/username</tt> файлы, имеющие
                размер больше 100K. Каждый раз предоставляя
                пользователю возможность удалить или сжать этот файл,
                затем переходить к поиску следующего файла.</p>
              </dd>

              <dt><strong
               class="COMMAND">Безопасное удаление</strong></dt>

              <dd>
                <p>Напишите сценарий <span
                 class="QUOTE">&quot;безопасного&quot;</span> удаления
                файлов -- <tt
                 class="FILENAME">srm.sh</tt>. Файлы, с именами,
                передаваемыми этому сценарию, не должны удаляться,
                вместо этого, файлы следует сжать утилитой <a
                 href="#GZIPREF">gzip</a>, если они еще не сжаты (не
                забывайте про утилиту <a
                 href="#FILEREF">file</a>), и переместить в каталог <tt
                 class="FILENAME">/home/username/trash</tt>. При
                старте, сценарий должен удалять из каталога <span
                 class="QUOTE">&quot;trash&quot;</span> файлы, которые
                были созданы более 48 часов тому назад.</p>
              </dd>

              <dt><strong
               class="COMMAND">Размен монет</strong></dt>

              <dd>
                <p>Как более рационально собрать сумму в $1.68,
                используя только монеты, с номиналом не выше 25c? Это
                будет шесть 25-ти центовых монет, одна десятицентовая,
                одна пятицентовая и три монеты достоинством в 1
                цент.</p>

                <p>Учитывая возможность произвольного ввода суммы в
                долларах и центах ($*.??), найдите такую комбинацию,
                которая требовала бы наименьшее число монет. Если вы
                проживаете не в США, то можете использовать свою
                денежную единицу и номиналы монет. Подсказка: взгляните
                на <a
                 href="#EX61">Пример 22-4</a>.</p>
              </dd>

              <dt><strong
               class="COMMAND">Корни квадратного
              уравнения</strong></dt>

              <dd>
                <p>Напишите сценарий, который находил бы корни <span
                 class="QUOTE">&quot;квадратного &quot;</span>
                уравнения, вида: <span
                 class="emphasis"><em
                 class="EMPHASIS">Ax^2 + Bx + C = 0</em></span>.
                Сценарий должен получать коэффициенты уравнения <tt
                 class="USERINPUT"><strong>A</strong></tt>, <tt
                 class="USERINPUT"><strong>B</strong></tt> и <tt
                 class="USERINPUT"><strong>C</strong></tt>, как
                аргументы командной строки, и находить корни, с
                точностью до четвертого знака после запятой.</p>

                <p>Подсказка: воспользуйтесь <a
                 href="#BCREF">bc</a>, для нахождения решения по хорошо
                известной формуле: <span
                 class="emphasis"><em
                 class="EMPHASIS">x = ( -B +/- sqrt( B^2 - 4AC ) ) /
                2A</em></span>.</p>
              </dd>

              <dt><strong
               class="COMMAND">Сумма чисел</strong></dt>

              <dd>
                <p>Найдите сумму всех пятизначных чисел (в диапазоне
                10000 - 99999), которые содержат <span
                 class="emphasis"><em
                 class="EMPHASIS">точно две</em></span> цифры из
                следующего набора: { 4, 5, 6 }.</p>

                <p>Примеры чисел, удовлетворяющих данному условию:
                42057, 74638 и 89515.</p>
              </dd>

              <dt><strong
               class="COMMAND">Счастливый билет</strong></dt>

              <dd>
                <p>&quot;Счастливым&quot; считается такой билет, в
                котором последовательное сложение цифр номера дает
                число 7. Например, 62431 -- номер
                &quot;счастливого&quot; билета (6 + 2 + 4 + 3 + 1 = 16,
                1 + 6 = 7). Найдите все &quot;счастливые&quot; номера,
                располагающиеся в диапазоне 1000 - 10000.</p>
              </dd>

              <dt><strong
               class="COMMAND">Синтаксический анализ</strong></dt>

              <dd>
                <p>Проанализируйте файл <tt
                 class="FILENAME">/etc/passwd</tt> и выведите его
                содержимое в табличном виде.</p>
              </dd>

              <dt><strong
               class="COMMAND">Просмотр файла с данными</strong></dt>

              <dd>
                <p>Некоторые базы данных и электронные таблицы
                используют формат CSV (<span
                 class="emphasis"><em
                 class="EMPHASIS">comma-separated values</em></span>),
                для хранения данных в файлах. Зачастую, эти файлы
                должны анализироваться другими приложениями.</p>

                <p>Пусть файл содержит следующие данные:</p>
<pre
 class="PROGRAMLISTING">
Jones,Bill,235 S. Williams St.,Denver,CO,80221,(303) 244-7989
Smith,Tom,404 Polk Ave.,Los Angeles,CA,90003,(213) 879-5612
...
</pre>
                Прочитайте данные и выведите их на <tt
                 class="FILENAME">stdout</tt> в виде колонок с
                заголовками.<br>
                <br>
              </dd>

              <dt><strong
               class="COMMAND">Выравнивание</strong></dt>

              <dd>
                <p>Текст вводится с устройства <tt
                 class="FILENAME">stdin</tt> или из файла. Его
                необходимо вывести на <tt
                 class="FILENAME">stdout</tt>, с выравниванием по
                ширине, используя задаваемую пользователем ширину
                строк.</p>
              </dd>

              <dt><strong
               class="COMMAND">Список рассылки</strong></dt>

              <dd>
                <p>Напишите сценарий, который использовал бы команду <a
                 href="#COMMMAIL1">mail</a>, для управления простым
                списком рассылки. Сценарий должен брать текст
                ежемесячного информационного бюллетеня из заданного
                файла, список адресатов из другого файла и выполнять
                рассылку новостей по электронной почте.</p>
              </dd>

              <dt><strong
               class="COMMAND">Пароли</strong></dt>

              <dd>
                <p>Сгенерируйте псевдослучайные 8-ми символьные пароли,
                используя символы из диапазона [0-9], [A-Z], [a-z].
                Каждый пароль должен содержать не менее 2-х цифр.</p>
              </dd>
            </dl>
          </div>

          <div
           class="VARIABLELIST">
            <p><strong><a
             name="EXDIFFICULT1"></a>Сложные задания</strong></p>

            <dl>
              <dt><strong
               class="COMMAND">Регистрация обращений к
              файлам</strong></dt>

              <dd>
                <p>Попробуйте отследить все попытки обращения к файлам
                в каталоге <tt
                 class="FILENAME">/etc</tt>, в течение дня. Сведения,
                которые включают в себя время обращения, имя файла, имя
                пользователя (если имели место какие либо изменения в
                файлах, то они тоже должны быть отмечены), запишите в
                виде аккуратно отформатированных записей в логфайл.</p>
              </dd>

              <dt><strong
               class="COMMAND">Удаление комментариев</strong></dt>

              <dd>
                <p>Удалите все комментарии из сценария, имя которого
                задается с командной строки. При этом, строка <span
                 class="QUOTE">&quot;#! /bin/bash&quot;</span> не
                должна удаляться.</p>
              </dd>

              <dt><strong
               class="COMMAND">Преобразование в HTML</strong></dt>

              <dd>
                <p>Преобразуйте заданный текстовый файл в HTML формат.
                Этот сценарий должен автоматически вставлять
                необходимые теги HTML в тело файла.</p>
              </dd>

              <dt><strong
               class="COMMAND">Удаление тегов HTML</strong></dt>

              <dd>
                <p>Удалите все теги HTML из заданного HTML файла, затем
                переформатируйте его так, чтобы строки не были короче
                60 и длиннее 75 символов. Предусмотрите оформление
                параграфов. Преобразуйте таблицы HTML в их
                приблизительный текстовый эквивалент.</p>
              </dd>

              <dt><strong
               class="COMMAND">Преобразование XML файлов</strong></dt>

              <dd>
                <p>Преобразуйте файл из формата XML в формат HTML и в
                простой текстовый файл.</p>
              </dd>

              <dt><a
               name="CSPAMMERS"></a><strong
               class="COMMAND">Борьба со спамом</strong></dt>

              <dd>
                <p>Напишите сценарий, который анализировал бы входящие
                почтовые сообщения на принадлежность к спаму и
                отыскивал бы в DNS имена узлов сети, по IP адресам из
                заголовка письма. Сценарий должен отправлять найденые
                спамерские сообщения ответственным за спам провайдерам
                (ISP). Естественно, вы должны отфильтровать <span
                 class="emphasis"><em
                 class="EMPHASIS">свой собственный IP
                адрес</em></span>, чтобы не случилось так, что вы
                жалуетесь на самого себя.</p>

                <p>По мере необходимости, используйте соответствующие
                <a
                 href="#COMMUNINFO1">команды для работы с
                сетью</a>.</p>
              </dd>

              <dt><strong
               class="COMMAND">Азбука Морзе</strong></dt>

              <dd>
                <p>Преобразуйте текстовый файл в код Морзе. Символы из
                файла должны быть представлены в виде, соответствующих
                им, кодов Морзе, состоящих из точек и тире, и
                разделенных пробелами. Например, <span
                 class="QUOTE">&quot;script&quot;</span> ===&gt; <span
                 class="QUOTE">&quot;... _._. ._. .. .__.
                _&quot;</span>.</p>
              </dd>

              <dt><strong
               class="COMMAND">Шестнадцатиричный дамп</strong></dt>

              <dd>
                <p>Выведите, в виде шестнадцатиричного дампа,
                содержимое бинарного файла, передаваемого в сценарий,
                как аргумент командной строки. Вывод должен
                производиться в четкой табличной форме, первое поле
                таблицы -- адрес, далее должны следовать 8 полей,
                содержащие 4-х байтовые шестнадцатиричные числа, а
                завершать строку должно поле, содержащее эквивалентное
                отображение 8-ми предшествующих полей, в виде
                ASCII-символов.</p>
              </dd>

              <dt><strong
               class="COMMAND">Эмуляция сдвигового
              регистра</strong></dt>

              <dd>
                <p>Используя <a
                 href="#STACKEX">Пример 25-9</a>, как образец, напишите
                сценарий, который эмулировал бы 64-х битный сдвиговый
                регистр в виде <a
                 href="#ARRAYREF">массива</a>. Реализуйте функции <span
                 class="emphasis"><em
                 class="EMPHASIS">загрузки</em></span> значения в
                регистр, <span
                 class="emphasis"><em
                 class="EMPHASIS">сдвиг влево</em></span> и <span
                 class="emphasis"><em
                 class="EMPHASIS">сдвиг вправо</em></span>. В
                заключение, напишите функцию, которая интерпретировала
                бы содержимое &quot;регистра&quot; как восемь 8-ми
                битных символов ASCII.</p>
              </dd>

              <dt><strong
               class="COMMAND">Детерминант (определитель)</strong></dt>

              <dd>
                <p>Найдите детерминант (определитель) матрицы 4 x
                4.</p>
              </dd>

              <dt><strong
               class="COMMAND">Анаграммы</strong></dt>

              <dd>
                <p>Сценарий должен запросить у пользователя 4-х
                символьное слово, и найти анаграммы для этого слова.
                Например, анаграммы к слову <span
                 class="emphasis"><em
                 class="EMPHASIS">word</em></span>: <span
                 class="emphasis"><em
                 class="EMPHASIS">do or rod row word</em></span>. Для
                поиска анаграмм можете использовать файл <tt
                 class="FILENAME">/usr/share/dict/linux.words</tt>.</p>
              </dd>

              <dt><strong
               class="COMMAND">Индекс сложности текста</strong></dt>

              <dd>
                <p><span
                 class="QUOTE">&quot;Индекс сложности
                текста&quot;</span> оценивает трудность понимания
                текста, как некое число, которое грубо соответствует
                количеству лет обучения в общеобразовательной школе.
                Например, индекс равный 8-ми говорит о том, что текст
                доступен для понимания человеку, окончившему 8-й класс
                общеобразовательной школы.</p>

                <p>Вычисление индекса ведется по следующему
                алгоритму.</p>

                <ol
                 type="1">
                  <li>
                    <p>Выберите кусок текста, длиной не менее 100
                    слов.</p>
                  </li>

                  <li>
                    <p>Сосчитайте количество предложений.</p>
                  </li>

                  <li>
                    <p>Найдите среднее число слов в предложении.</p>

                    <p>СРЕДНЕЕ_ЧИСЛО_СЛОВ = ОБЩЕЕ_ЧИСЛО_СЛОВ /
                    ЧИСЛО_ПРЕДЛОЖЕНИЙ</p>
                  </li>

                  <li>
                    <p>Сосчитайте количество <span
                     class="QUOTE">&quot;трудных&quot;</span> слов --
                    которые содержат не менее 3-х слогов. Разделите это
                    число на общее количество слов, в результате вы
                    получите пропорцию сложных слов.</p>

                    <p>ПРОПОРЦИЯ_СЛОЖНЫХ_СЛОВ = ЧИСЛО_ДЛИННЫХ_СЛОВ /
                    ОБЩЕЕ_ЧИСЛО_СЛОВ</p>
                  </li>

                  <li>
                    <p>Индекс сложности текста рассчитывается как сумма
                    двух этих чисел, умноженная на 0.4 и округленная до
                    ближайшего целого.</p>

                    <p>ИНДЕКС_СЛОЖНОСТИ = int ( 0.4 * (
                    СРЕДНЕЕ_ЧИСЛО_СЛОВ + ПРОПОРЦИЯ_СЛОЖНЫХ_СЛОВ ) )</p>
                  </li>
                </ol>

                <p>4-й пункт -- самый сложный. Существуют различные
                алгоритмы подсчета слогов в словах. В данном же случае,
                вы можете ограничиться подсчетом сочетаний
                &quot;гласный-согласный&quot;.</p>

                <p>Строго говоря, при расчете индекса сложности не
                следует считать составные слова и имена собственные как
                <span
                 class="QUOTE">&quot;сложные&quot;</span> слова, но это
                слишком усложнит сценарий.</p>
              </dd>

              <dt><strong
               class="COMMAND">Вычисление числа пи по алгоритму
              &quot;Игла Баффона&quot;</strong></dt>

              <dd>
                <p>В 18 веке, французский математик де Баффон (de
                Buffon) проделывал эксперимент, который заключался в
                бросании иглы, длиной <span
                 class="QUOTE">&quot;n&quot;</span>, на деревянный пол,
                собраный из длинных и узких досок. Ширина всех досок
                пола одинакова и равна <span
                 class="QUOTE">&quot;d&quot;</span>. Оказалось, что
                отношение общего числа бросков, к числу бросков, когда
                игла ложилась на щель, кратно числу пи.</p>

                <p>Пользуясь <a
                 href="#CANNON">Пример 12-35</a>, напишите сценарий,
                который использовал бы метод Монте Карло для эмуляции
                &quot;Иглы Баффона&quot;. Для простоты примите длину
                иглы раной ширине досок, <span
                 class="emphasis"><em
                 class="EMPHASIS">n = d</em></span>.</p>

                <p>Подсказка: особое значение здесь имеют переменные,
                которые будут вычисляться как расстояние от центра иглы
                до ближайшей щели и величина угла между иглой и щелью.
                Для выполнения расчетов можно воспользоваться утилитой
                <a
                 href="#BCREF">bc</a>.</p>
              </dd>

              <dt><strong
               class="COMMAND">Шифрование по алгоритму
              Playfair</strong></dt>

              <dd>
                <p>Напишите сценарий, реализующий алгоритм шифрования
                Playfair (Wheatstone).</p>

                <p>В соответствии с этим алгоритмом, текст шифруется
                путем замены каждой 2-х символьной последовательности
                -- <span
                 class="QUOTE">&quot;диграммы&quot;</span>.
                Традиционно, в качестве ключа, используется матрица
                символов алфавита 5 x 5.</p>
<pre
 class="PROGRAMLISTING">
   C O D E S
   A B F G H
   I K L M N
   P Q R T U
   V W X Y Z
            
</pre>
                Матрица содержит все символы алфавита, за исключением
                символа &quot;J&quot;, который представляет символ
                &quot;I&quot;. Первая строка матрицы -- произвольно
                выбранное слово, в данном случае -- &quot;CODES&quot;,
                далее следуют символы алфавита, исключая те, которые
                входят в состав первой строки.<br>
                <br>

                <p>Шифрование производится по следующему алгоритму: для
                начала, текст сообщения разбивается на диграммы (группы
                по 2 символа). Если в диграмму попадают два одинаковых
                символа, то второй символ удаляется, и формируется
                новая диграмма. Если в последней группе остается один
                символ, то такая &quot;неполная&quot; диграмма
                дополняется &quot;пустым&quot; символом, обычно
                &quot;X&quot;.</p>
<pre
 class="PROGRAMLISTING">
THIS IS A TOP SECRET MESSAGE

TH IS IS AT OP SE CR ET ME SA GE
            
</pre>
                Каждая диграмма может подпадать под одно из следующих
                определений:.<br>
                <br>

                <p>1) Оба символа находятся в одной строке ключа.
                Тогда, каждый из них заменяется символом, стоящим
                справа в той же строке. Если это последний символ
                строки ключа, то он заменяется первым символом в той же
                строке ключа.</p>

                <p>2) Оба символа находятся в одном столбце ключа.
                Тогда каждый из них заменяется на символ, стоящий ниже,
                в этом же столбце. Если это последний символ в столбце
                ключа, то он заменяется первым символом в том же
                столбце ключа.</p>

                <p>3) Символы диграммы стоят в вершинах прямоугольника.
                Тогда каждый из них заменяется символом из соседнего,
                по горизонтали, угла.</p>

                <p>Диграмма &quot;TH&quot; соответствует 3-му
                определению.</p>
<pre
 class="PROGRAMLISTING">
G H
M N
T U           (Прямоугольник с вершинами &quot;T&quot; и &quot;H&quot;)

T --&gt; U
H --&gt; G

            
</pre>
                <br>
                <br>

                <p>Диграмма &quot;SE&quot; соответствует 1-му
                определению.</p>
<pre
 class="PROGRAMLISTING">
C O D E S     (Строка содержит оба символа &quot;S&quot; и &quot;E&quot;)

S --&gt; C  (замена на первый символ в строке ключа)
E --&gt; S
            
</pre>
                <br>
                <br>

                <p>
Дешифрация выполняется обратной процедурой, для
                случаев 1 и 2 -- замена символом стоящим левее/выше.
                Для случая 3 -- аналогично шифрации, т.е. заменяется
                символом из соседнего, по горизонтали, угла. Helen
                Fouche Gaines, в своей классической работе
                &quot;Elementary Cryptoanalysis&quot; (1939), приводит
                подробное описание алгоритма Playfair и методы его
                реализации.</p>

                <p>Этот сценарий должен иметь три основных раздела</p>

                <ol
                 type="I">
                  <li>
                    <p>Генерация <span
                     class="QUOTE">&quot;ключевой матрицы&quot;</span>,
                    основывающейся на слове, которое вводит
                    пользователь.</p>
                  </li>

                  <li>
                    <p>Шифрование <span
                     class="QUOTE">&quot;плоского&quot;</span> текста
                    сообщения.</p>
                  </li>

                  <li>
                    <p>Дешифрование зашифрованного текста.</p>
                  </li>
                </ol>

                <p>Широкое применение, в этом сценарии, найдут <a
                 href="#ARRAYREF">массивы</a> и <a
                 href="#FUNCTIONREF">функции</a>.</p>
              </dd>
            </dl>
          </div>

          <p>--</p>

          <p>Пожалуйста, не присылайте автору свои варианты решения
          упражнений. Если вы хотите впечатлить его своим умом и
          сообразительностью -- присылайте обнаруженные вами ошибки и
          предложения по улучшению этой книги.</p>
        </div>
      </div>

      <div
       class="APPENDIX">
        <hr>

        <h1><a
         name="COPYRIGHT"></a>Приложение J. Авторские права</h1>

        <p>Авторские права на книгу <span
         class="QUOTE">&quot;Advanced Bash-Scripting
        Guide&quot;</span>, принадлежат Менделю Куперу (Mendel Cooper).
        Этот документ может распространяться исключительно на условиях
        Open Publication License (версия 1.0 или выше), <a
         href="%20http://www.opencontent.org/openpub/"
         target="_top">http://www.opencontent.org/openpub/</a>.
        Соблюдение следующих пунктов лицензии обязательно.</p>

        <ol
         type="1">
          <li>
            <p>Распространение существенно измененных версий этого
            документа, запрещено без явного разрешения держателя
            прав.</p>
          </li>

          <li>
            <p>Запрещено распространение твердых (бумажных) копий
            книги, или ее производных, без явного согласия держателя
            прав.</p>
          </li>
        </ol>

        <p><span
         class="emphasis"><em
         class="EMPHASIS">Пункт 1</em></span>, выше, явно запрещает
        вставлять в текст документа логотипы компаний или навигационные
        элементы, за исключением</p>

        <ol
         type="1">
          <li>
            <p>Некоммерческих организаций, таких как <a
             href="http://www.tldp.org"
             target="_top">Linux Documentation Project</a> и <a
             href="http://ibiblio.org"
             target="_top">Sunsite</a>.</p>
          </li>

          <li>
            <p>Не <span
             class="QUOTE">&quot;запятнавших&quot;</span> себя
            дистрибутивостроителей Linux, таких как Debian, Red Hat,
            Mandrake и других.</p>
          </li>
        </ol>

        <p>Практически, вы можете свободно распространять <span
         class="emphasis"><em
         class="EMPHASIS">неизмененную</em></span> электронную версию
        этой книги. Вы должны получить явное разрешение автора на
        распространение измененных версий книги или ее производных.
        Цель этого ограничения состоит в том, чтобы сохранить
        художественную целостность данного документа и предотвратить
        появление побочных <span
         class="QUOTE">&quot;ветвей&quot;</span>.</p>

        <p>Это очень либеральные условия и они не должны препятствовать
        законному распространению и использованию этой книги. Автор
        особенно поощряет использование этой книги в учебных целях.</p>

        <p>Права на коммерческое распространение книги могут быть
        получены у <a
         href="mailto:thegrendel@theriver.com"
         target="_top">автора</a>.</p>

        <p>Автор произвел этот документ в соответствии с буквой и духом
        <a
         href="http://www.tldp.org/manifesto.html"
         target="_top">LDP Manifesto</a>.</p>

        <p>Hyun Jin Cha завершил <a
         href=
        "http://kldp.org/HOWTO/html/Adv-Bash-Scr-HOWTO/index.html"
         target="_top">перевод на Корейский язык</a> версию 1.0.11 этой
        книги. Переводы на Испанский, Португальский, Французский,
        Немецкий, Итальянский и Китайский языки находятся на стадии
        реализации. Если вы изъявите желание перевести этот документ на
        другой язык, то можете свободно выполнить этот перевод,
        основываясь на условиях, заявленных выше. В этом случае, автор
        хотел бы, чтобы его поставили в известность.</p>

        <table
         class="SIDEBAR"
         border="1"
         cellpadding="5">
          <tr>
            <td>
              <div
               class="SIDEBAR">
                <a
                 name="AEN15890"></a>

                <p>Linux -- это торговая марка, принадлежащая Линусу
                Торвальдсу (Linus Torvalds).</p>

                <p>Unix и UNIX -- это торговая марка, принадлежащая
                Open Group.</p>

                <p>MS Windows -- это торговая марка, принадлежащая
                Microsoft Corp.</p>

                <p>Все другие коммерческие торговые марки, упомянутые в
                данном документе, принадлежат их владельцам.</p>
              </div>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN123"
         href="#AEN123"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Их так же называют <a
           href="#BUILTINREF">встроенными</a> конструкциями языка
          командной оболочки shell.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN165"
         href="#AEN165"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Многие особенности <span
           class="emphasis"><em
           class="EMPHASIS">ksh88</em></span> и даже <span
           class="emphasis"><em
           class="EMPHASIS">ksh93</em></span> перекочевали в Bash.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN172"
         href="#AEN172"><span
         class="footnote">[3]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>В соответствии с соглашениями, имена файлов с
          shell-скриптами, такими как Bourne shell и совместимыми,
          имеют расширение <tt
           class="FILENAME">.sh</tt>. Все стартовые скрипты, которые вы
          найдете в <tt
           class="FILENAME">/etc/rc.d</tt>, следуют этому
          соглашению.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN199"
         href="#AEN199"><span
         class="footnote">[4]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Некоторые разновидности UNIX (основанные на 4.2BSD)
          требуют, чтобы эта последовательность состояла из 4-х байт,
          за счет добавления пробела после <span
           class="TOKEN">!</span>, <tt
           class="USERINPUT"><strong>#! /bin/sh</strong></tt>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN207"
         href="#AEN207"><span
         class="footnote">[5]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>В shell-скриптах последовательность <span
           class="TOKEN">#!</span> должна стоять самой первой и задает
          интерпретатор (<strong
           class="COMMAND">sh</strong> или <strong
           class="COMMAND">bash</strong>). Интерпретатор, в свою
          очередь, воспринимает эту строку как комментарий, поскольку
          она начинается с символа <span
           class="TOKEN">#</span>.</p>

          <p>Если в сценарии имеются еще такие же строки, то они
          воспринимаются как обычный комментарий.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo &quot;Первая часть сценария.&quot;
a=1

#!/bin/bash
# Это *НЕ* означает запуск нового сценария.

echo &quot;Вторая часть сценария.&quot;
echo $a  # Значение переменной $a осталось равно 1.
</pre>
          <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN220"
         href="#AEN220"><span
         class="footnote">[6]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Эта особенность позволяет использовать различные
          хитрости.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/rm
# Самоуничтожающийся сценарий.

# Этот скрипт ничего не делает -- только уничтожает себя.

WHATEVER=65

echo &quot;Эта строка никогда не будет напечатана.&quot;

exit $WHATEVER  # Не имеет смысла, поскольку работа сценария завершается не здесь.
</pre>
          <br>
          <br>

          <p>Попробуйте запустить файл <tt
           class="FILENAME">README</tt> с сигнатурой <tt
           class="USERINPUT"><strong>#!/bin/more</strong></tt>
          (предварительно не забудьте сделать его исполняемым).</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN230"
         href="#AEN230"><span
         class="footnote">[7]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="strong"><strong
           class="EMPHASIS">P</strong></span>ortable <span
           class="strong"><strong
           class="EMPHASIS">O</strong></span>perating <span
           class="strong"><strong
           class="EMPHASIS">S</strong></span>ystem <span
           class="bold"><strong
           class="EMPHASIS">I</strong></span>nterface, попытка
          стандартизации UNI<span
           class="strong"><strong
           class="EMPHASIS">X</strong></span>-подобных операционных
          систем.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN253"
         href="#AEN253"><span
         class="footnote">[8]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Внимание: вызов Bash-скрипта с помощью команды <tt
           class="USERINPUT"><strong>sh scriptname</strong></tt>
          отключает специфичные для Bash расширения, что может привести
          к появлению ошибки и аварийному завершению работы
          сценария.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN266"
         href="#AEN266"><span
         class="footnote">[9]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Сценарий должен иметь как право на исполнение, так и право
          на <span
           class="emphasis"><em
           class="EMPHASIS">чтение</em></span>, поскольку shell должен
          иметь возможность прочитать скрипт.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN278"
         href="#AEN278"><span
         class="footnote">[10]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Почему бы не запустить сценарий просто набрав название
          файла <tt
           class="USERINPUT"><strong>scriptname</strong></tt>, если
          сценарий находится в текущем каталоге? Дело в том, что из
          соображений безопасности, путь к текущему каталогу <span
           class="QUOTE">&quot;.&quot;</span> не включен в переменную
          окружения <a
           href="#PATHREF">$PATH</a>. Поэтому необходимо явно указывать
          путь к текущему каталогу, в котором находится сценарий, т.е.
          <tt
           class="USERINPUT"><strong>./scriptname</strong></tt>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN901"
         href="#AEN901"><span
         class="footnote">[11]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Интерпретатор, встретив фигурные скобки, раскрывает их и
          возвращает полученный список команд, которые затем и
          исполняет.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN947"
         href="#AEN947"><span
         class="footnote">[12]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Исключение: блок кода, являющийся частью конвейера, <span
           class="emphasis"><em
           class="EMPHASIS">может</em></span> быть запущен в дочернем
          процессе (<a
           href="#SUBSHELLSREF">subshell-е</a>).</p>
<pre
 class="PROGRAMLISTING">
ls | { read firstline; read secondline; }
# Ошибка! Вложенный блок будет запущен в дочернем процессе,
# таким образом, вывод команды &quot;ls&quot; не может быть записан в переменные
# находящиеся внутри блока.
echo &quot;Первая строка: $firstline; вторая строка: $secondline&quot;  # Не работает!

# Спасибо S.C.
</pre>
          <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN1772"
         href="#AEN1772"><span
         class="footnote">[13]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Аргумент <tt
           class="REPLACEABLE"><em>$0</em></tt> устанавливается
          вызывающим процессом. В соответствии с соглашениями, этот
          параметр содержит имя файла скрипта. См. страницы руководства
          для <strong
           class="COMMAND">execv</strong> (man execv).</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN1882"
         href="#AEN1882"><span
         class="footnote">[14]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Символ <span
           class="QUOTE">&quot;!&quot;</span>, помещенный в двойные
          кавычки, порождает сообщение об ошибке, если команда вводится
          <span
           class="emphasis"><em
           class="EMPHASIS">с командной строки</em></span>. Вероятно
          это связано с тем, что этот символ интерпретируется как
          попытка обращения к <a
           href="#HISTCOMMANDS">истории команд</a>. Однако внутри
          сценариев такой прием проблем не вызывает.</p>

          <p>Не менее любопытно поведение символа <span
           class="QUOTE">&quot;\&quot;</span>, употребляемого внутри
          двойных кавычек.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo hello\!</strong></tt>
<tt
 class="COMPUTEROUTPUT">hello!</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo &quot;hello\!&quot;</strong></tt>
<tt
 class="COMPUTEROUTPUT">hello\!</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo -e x\ty</strong></tt>
<tt
 class="COMPUTEROUTPUT">xty</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo -e &quot;x\ty&quot;</strong></tt>
<tt
 class="COMPUTEROUTPUT">x       y</tt>
             
</pre>
          (Спасибо Wayne Pollock за пояснения.) <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN1906"
         href="#AEN1906"><span
         class="footnote">[15]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="QUOTE">&quot;Разбиение на слова&quot;</span>, в
          данном случае это означает разделение строки символов на
          некоторое число аргументов.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN2488"
         href="#AEN2488"><span
         class="footnote">[16]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>С флагом <span
           class="emphasis"><em
           class="EMPHASIS">suid</em></span>, на двоичных исполняемых
          файлах, надо быть очень осторожным, поскольку это может быть
          небезопасным. Установка флага <span
           class="emphasis"><em
           class="EMPHASIS">suid</em></span> на файлы-сценарии не имеет
          никакого эффекта.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN2508"
         href="#AEN2508"><span
         class="footnote">[17]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>В современных UNIX-системах, &quot;sticky bit&quot; больше
          не используется для файлов, только для каталогов.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN2722"
         href="#AEN2722"><span
         class="footnote">[18]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Как указывает S.C., даже заключение строки в кавычки, при
          построении сложных условий проверки, может оказаться
          недостаточным. <tt
           class="USERINPUT"><strong>[ -n &quot;$string&quot; -o
          &quot;$a&quot; = &quot;$b&quot; ]</strong></tt> в некоторых
          версиях Bash такая проверка может вызвать сообщение об
          ошибке, если строка <tt
           class="VARNAME">$string</tt> пустая. Безопаснее, в смысле
          отказоустойчивости, было бы добавить какой-либо символ к,
          возможно пустой, строке: <tt
           class="USERINPUT"><strong>[ &quot;x$string&quot; != x -o
          &quot;x$a&quot; = &quot;x$b&quot; ]</strong></tt> (символ
          <span
           class="QUOTE">&quot;x&quot;</span> не учитывается).</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN3728"
         href="#AEN3728"><span
         class="footnote">[19]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>PID текущего процесса хранится в переменной <tt
           class="VARNAME">$$</tt>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN4011"
         href="#AEN4011"><span
         class="footnote">[20]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Слова <span
           class="QUOTE">&quot;аргумент&quot;</span> и <span
           class="QUOTE">&quot;параметр&quot;</span> очень часто
          используются как синонимы. В тексте данного документа, они
          применяются для обозначения одного и того же понятия, будь то
          аргумент, передаваемый скрипту из командной строки или
          входной параметр функции.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN4257"
         href="#AEN4257"><span
         class="footnote">[21]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Применяется к аргументам командной строки или входным
          параметрам <a
           href="#FUNCTIONREF">функций</a>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN4520"
         href="#AEN4520"><span
         class="footnote">[22]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Если $parameter &quot;пустой&quot;,в неинтерактивных
          сценариях, то это будет приводить к завершению с <a
           href="#EXITCODESREF">кодом возврата <span
           class="RETURNVALUE">127</span></a> (<span
           class="QUOTE">&quot;command not found&quot;</span>).</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN5175"
         href="#AEN5175"><span
         class="footnote">[23]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Эти команды являются <a
           href="#BUILTINREF">встроенными командами</a> языка сценариев
          командной оболочки (shell), в то время как <a
           href="#WHILELOOPREF">while</a>, <a
           href="#CASEESAC1">case</a> и т.п. -- являются <a
           href="#KEYWORDREF">зарезервированными словами</a>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN5395"
         href="#AEN5395"><span
         class="footnote">[24]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Исключение из правил -- команда <a
           href="#TIMREF">time</a>, которая в официальной документации
          к Bash называется ключевым словом.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN5877"
         href="#AEN5877"><span
         class="footnote">[25]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Опция -- это аргумент, который управляет поведением
          сценария и может быть либо включен, либо выключен. Аргумент,
          который объединяет в себе несколько опций (ключей),
          определяет поведение сценария в соответствии с отдельными
          опциями, объединенными в данном аргументе..</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN6343"
         href="#AEN6343"><span
         class="footnote">[26]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Как правило, исходные тексты подобных библиотек, на языке
          C, располагаются в каталоге <tt
           class=
          "FILENAME">/usr/share/doc/bash-?.??/functions</tt>.</p>

          <p>Обратите внимание: ключ <tt
           class="OPTION">-f</tt> команды <strong
           class="COMMAND">enable</strong> может отсутствовать в
          некоторых системах.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN6361"
         href="#AEN6361"><span
         class="footnote">[27]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Тот же эффект можно получить с помощью <a
           href="#DECLAREREF">typeset -fu</a>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN6567"
         href="#AEN6567"><span
         class="footnote">[28]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Скрытыми считаются файлы, имена которых начинаются с
          точки, например, <tt
           class="FILENAME">~/.Xdefaults</tt>. Такие файлы не выводятся
          простой командой <strong
           class="COMMAND">ls</strong>, и не могут быть удалены
          командой <strong
           class="COMMAND">rm -rf *</strong>. Как правило, скрытыми
          делаются конфигурационные файлы в домашнем каталоге
          пользователя.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN7520"
         href="#AEN7520"><span
         class="footnote">[29]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Это верно только для GNU-версии команды <strong
           class="COMMAND">tr</strong>, поведение этой команды, в
          коммерческих UNIX-системах, может несколько отличаться.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN7816"
         href="#AEN7816"><span
         class="footnote">[30]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Команда <strong
           class="COMMAND">tar czvf archive_name.tar.gz *</strong>
          <span
           class="emphasis"><em
           class="EMPHASIS">включит</em></span> в архив все скрытые
          файлы (имена которых начинаются с точки) из <span
           class="emphasis"><em
           class="EMPHASIS">вложенных подкаталогов</em></span>. Это
          недокументированная <span
           class="QUOTE">&quot;особенность&quot;</span> GNU-версии
          <strong
           class="COMMAND">tar</strong>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN8616"
         href="#AEN8616"><span
         class="footnote">[31]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Она реализует алгоритм симметричного блочного шифрования,
          в противоположность алгоритмам шифрования с <span
           class="QUOTE">&quot;открытым ключом&quot;</span>, из которых
          широко известен <strong
           class="COMMAND">pgp</strong>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN8859"
         href="#AEN8859"><span
         class="footnote">[32]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><a
           name="DAEMONREF"></a></p>

          <p><span
           class="emphasis"><em
           class="EMPHASIS">Демон</em></span> -- это некий фоновый
          процесс, не привязанный ни к одной из терминальных сессий.
          Демоны предназначены для выполнения определенного круга задач
          либо через заданные промежутки времени, либо по наступлению
          какого либо события.</p>

          <p>Слово <span
           class="QUOTE">&quot;демон&quot;</span> (<span
           class="QUOTE">&quot;daemon&quot;</span>), в греческой
          мифологии, употреблялось для обозначения призраков, духов,
          чего-то мистического, сверхестественного. В мире UNIX -- под
          словом демон подразумевается процесс, который
          &quot;тихо&quot; и &quot;незаметно&quot; выполняет свою
          работу.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9380"
         href="#AEN9380"><span
         class="footnote">[33]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Фактически -- это сценарий, заимствованный из дистрибутива
          Debian Linux.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9455"
         href="#AEN9455"><span
         class="footnote">[34]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="emphasis"><em
           class="EMPHASIS">Очередь печати</em></span> -- это группа
          заданий <span
           class="QUOTE">&quot;ожидающих вывода&quot;</span> на
          принтер.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9514"
         href="#AEN9514"><span
         class="footnote">[35]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Эта тема прекрасно освещена в статье, которую написал Andy
          Vaught, <a
           href=
          "http://www2.linuxjournal.com/lj-issues/issue41/2156.html"
           target="_top">Introduction to Named Pipes</a>, в сентябре
          1997 для <a
           href="http://www.linuxjournal.com"
           target="_top">Linux Journal</a>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9546"
         href="#AEN9546"><span
         class="footnote">[36]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>EBCDIC (произносится как <span
           class="QUOTE">&quot;ebb-sid-ic&quot;</span>) -- это
          аббревиатура от Extended Binary Coded Decimal Interchange
          Code (Расширенный Двоично-Десятичный Код Обмена Информацией).
          Это формат представления данных от IBM, не нашедший широкого
          применения. Не совсем обычное применение опции <tt
           class="OPTION">conv=ebcdic</tt> -- это использовать <strong
           class="COMMAND">dd</strong> для быстрого и легкого, но
          слабого, шифрования текстовых файлов.</p>
<pre
 class="PROGRAMLISTING">
cat $file | dd conv=swab,ebcdic &gt; $file_encrypted
# Зашифрованный файл будет выглядеть как &quot;абракадабра&quot;.
# опция swab добавлена для внесения большей неразберихи.

cat $file_encrypted | dd conv=swab,ascii &gt; $file_plaintext
# Декодирование.
</pre>
          <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9671"
         href="#AEN9671"><span
         class="footnote">[37]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="emphasis"><em
           class="EMPHASIS">макроопределение</em></span> -- это
          идентификатор, символическая константа, которая представляет
          некоторую последовательность команд, операций и
          параметров.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9791"
         href="#AEN9791"><span
         class="footnote">[38]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Команда <strong
           class="COMMAND">userdel</strong> завершится неудачей, если
          удаляемый пользователь в этот момент работает с системой</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN10873"
         href="#AEN10873"><span
         class="footnote">[39]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Дополнительную информацию по записи компакт-дисков, вы
          найдете в статье Алекса Уизера (Alex Wither): <a
           href=
          "http://www2.linuxjournal.com/lj-issues/issue66/3335.html"
           target="_top">Creating CDs</a>, в октябрьском выпуске
          журнала <a
           href="http://www.linuxjournal.com"
           target="_top">Linux Journal</a> за 1999 год.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11062"
         href="#AEN11062"><span
         class="footnote">[40]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Утилита <a
           href="#MKE2FSREF">mke2fs</a>, с ключом <tt
           class="OPTION">-c</tt>, так же производит поиск поврежденных
          блоков.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11188"
         href="#AEN11188"><span
         class="footnote">[41]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Пользователи небольших, десктопных Linux-систем
          предпочитают утилиты попроще, например <strong
           class="COMMAND">tar</strong>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11247"
         href="#AEN11247"><span
         class="footnote">[42]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>NAND -- логическая операция <span
           class="QUOTE">&quot;И-НЕ&quot;</span>. В общих чертах она
          напоминает вычитание.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11451"
         href="#AEN11451"><span
         class="footnote">[43]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="emphasis"><em
           class="EMPHASIS">Замещающая команда</em></span> может быть
          внешней системной командой, внутренней (встроенной) командой
          или даже функцией в сценарии.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11633"
         href="#AEN11633"><span
         class="footnote">[44]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="emphasis"><em
           class="EMPHASIS">дескриптор файла</em></span> -- это просто
          число, по которому система идентифицирует открытые файлы.
          Рассматривайте его как упрощенную версию указателя на
          файл.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11642"
         href="#AEN11642"><span
         class="footnote">[45]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>При использрвании <tt
           class="REPLACEABLE"><em>дескриптора с номером 5</em></tt>
          могут возникать проблемы. Когда Bash порождает дочерний
          процесс, например командой <a
           href="#EXECREF">exec</a>, то дочерний процесс наследует
          дескриптор 5 как &quot;открытый&quot; (см. архив почты Чета
          Рамея (Chet Ramey), <a
           href=
          "http://www.geocrawler.com/archives/3/342/1996/1/0/1939805/"
           target="_top">SUBJECT: RE: File descriptor 5 is held
          open</a>) Поэтому, лучше не использовать этот дескриптор.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11909"
         href="#AEN11909"><span
         class="footnote">[46]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>В качестве простейшего регулярного выражения можно
          привести строку, не содержащую никаких метасимволов.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11937"
         href="#AEN11937"><span
         class="footnote">[47]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Поскольку с помощью <a
           href="#SEDREF">sed</a>, <a
           href="#AWKREF">awk</a> и <a
           href="#GREPREF">grep</a> обрабатывают одиночные строки, то
          обычно символ перевода строки не принимается во внимание. В
          тех же случаях, когда производится разбор многострочного
          текста, метасимвол &quot;точка&quot; будет соответствовать
          символу перевода строки.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

sed -e &#39;N;s/.*/[&amp;]/&#39; &lt;&lt; EOF   # Встроенный документ
line1
line2
EOF
# OUTPUT:
# [line1
# line2]



echo

awk &#39;{ $0=$1 &quot;\n&quot; $2; if (/line.1/) {print}}&#39; &lt;&lt; EOF
line 1
line 2
EOF
# OUTPUT:
# line
# 1


# Спасибо S.C.

exit 0
</pre>
          <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12295"
         href="#AEN12295"><span
         class="footnote">[48]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Подстановка таких имен файлов <span
           class="emphasis"><em
           class="EMPHASIS">возможна</em></span>, но только при
          условии, что символ точки будет явно присутствовать в
          шаблоне.</p>
<pre
 class="PROGRAMLISTING">
~/[.]bashrc    # Не будет соответствовать имени ~/.bashrc
~/?bashrc      # То же самое.
               # Метасимволы не могут соответствовать символу точки при подстановке имен файлов.

~/.[b]ashrc    # Имя ~./bashrc будет соответствовать данному шаблону
~/.ba?hrc      # Аналогично.
~/.bashr*      # Аналогично.

# Установка ключа &quot;dotglob&quot; отключает такое поведение интерпретатора.
# Спасибо S.C.
</pre>
          <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12454"
         href="#AEN12454"><span
         class="footnote">[49]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Имеет тот же эффект, что и <a
           href="#NAMEDPIPEREF">именованные каналы</a> (временный
          файл), фактически, именованные каналы некогда использовались
          в операциях подстановки процессов.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12558"
         href="#AEN12558"><span
         class="footnote">[50]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Механизм <a
           href="#IVRREF">косвенных ссылок</a> на переменные (см. <a
           href="#EX78">Пример 34-2</a>) слишком неудобен для передачи
          аргументов по ссылке.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

ITERATIONS=3  # Количество вводимых значений.
icount=1

my_read () {
  # При вызове my_read varname,
  # выводит предыдущее значение в квадратных скобках,
  # затем просит ввести новое значение.

  local local_var

  echo -n &quot;Введите говое значение переменной &quot;
  eval &#39;echo -n &quot;[$&#39;$1&#39;] &quot;&#39;  # Прежнее значение.
  read local_var
  [ -n &quot;$local_var&quot; ] &amp;&amp; eval $1=\$local_var

  # Последовательность &quot;And-list&quot;: если &quot;local_var&quot; не пуста, то ее значение переписывается в &quot;$1&quot;.
}

echo

while [ &quot;$icount&quot; -le &quot;$ITERATIONS&quot; ]
do
  my_read var
  echo &quot;Значение #$icount = $var&quot;
  let &quot;icount += 1&quot;
  echo
done


# Спасибо Stephane Chazelas за этот поучительный пример.

exit 0
</pre>
          <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12587"
         href="#AEN12587"><span
         class="footnote">[51]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Команда <strong
           class="COMMAND">return</strong> -- это <a
           href="#BUILTINREF">встроенная</a> команда Bash.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12669"
         href="#AEN12669"><span
         class="footnote">[52]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><a
           name="RECURSIONREF"></a> <a
           href="#MAYERREF">Herbert Mayer</a> определяет <span
           class="emphasis"><em
           class="EMPHASIS">рекурсию</em></span>, как <span
           class="QUOTE">&quot;...описание алгоритма с помощью более
          простой версии того же самого алгоритма...&quot;</span>
          Рекурсивной называется функция, которая вызывает самого
          себя.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12675"
         href="#AEN12675"><span
         class="footnote">[53]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Слишком глубокая рекурсия может вызвать крах сценария.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

recursive_function ()
{
(( $1 &lt; $2 )) &amp;&amp; recursive_function $(( $1 + 1 )) $2;
#  Увеличивать 1-й параметр до тех пор,
#+ пока он не станет равным, или не превысит, второму параметру.
}

recursive_function 1 50000  # Глубина рекурсии = 50,000!
# Само собой -- Segmentation fault.

#  Рекурсия такой глубины может &quot;обрушить&quot; даже программу, написанную на C,
#+ по исчерпании памяти, выделенной под сегмент стека.

# Спасибо S.C.

exit 0  # Этот сценарий завершает работу не здесь, а в результате ошибки Segmentation fault.
</pre>
          <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12698"
         href="#AEN12698"><span
         class="footnote">[54]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Однако, псевдонимы могут &quot;раскручивать&quot;
          позиционные параметры.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12906"
         href="#AEN12906"><span
         class="footnote">[55]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Это не относится к таким оболочкам, как <strong
           class="COMMAND">csh</strong>, <strong
           class="COMMAND">tcsh</strong> и другим, которые не являются
          производными от классической Bourne shell (<strong
           class="COMMAND">sh</strong>).</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12955"
         href="#AEN12955"><span
         class="footnote">[56]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Каталог <tt
           class="FILENAME">/dev</tt> содержит специальные файлы --
          точки монтирования физических и виртуальных устройств. Они
          занимают незначительное пространство на диске.</p>

          <p>Некоторые из устройств, такие как <tt
           class="FILENAME">/dev/null</tt>, <tt
           class="FILENAME">/dev/zero</tt> или <tt
           class="FILENAME">/dev/urandom</tt> -- являются виртуальными.
          Они не являются файлами физических устройств, система
          эмулирует эти устройства программным способом.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12973"
         href="#AEN12973"><span
         class="footnote">[57]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="emphasis"><em
           class="EMPHASIS">Блочное устройство</em></span> читает и/или
          пишет данные целыми блоками, в отличие от <span
           class="emphasis"><em
           class="EMPHASIS">символьных устройств</em></span>, которые
          читают и/или пишут данные по одному символу. Примером
          блочного устройства может служить жесткий диск, CD-ROM.
          Примером символьного устройства -- клавиатура.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13009"
         href="#AEN13009"><span
         class="footnote">[58]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Отдельные системные команды, такие как <a
           href="#PROCINFOREF">procinfo</a>, <a
           href="#FREEREF">free</a>, <a
           href="#VMSTATREF">vmstat</a>, <a
           href="#LSDEVREF">lsdev</a> и <a
           href="#UPTIMEREF">uptime</a> делают это именно таким
          образом.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13102"
         href="#AEN13102"><span
         class="footnote">[59]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><a
           href="http://bashdb.sourceforge.net"
           target="_top">Bash debugger</a> (автор: Rocky Bernstein)
          частично возмещает этот недостаток.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13188"
         href="#AEN13188"><span
         class="footnote">[60]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>В соответствии с соглашениями, сигнал с номером <tt
           class="REPLACEABLE"><em>0</em></tt> соответствует команде <a
           href="#EXITCOMMANDREF">exit</a>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13453"
         href="#AEN13453"><span
         class="footnote">[61]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Установка этого бита на файлы сценариев не имеет никакого
          эффекта.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13625"
         href="#AEN13625"><span
         class="footnote">[62]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>ANSI -- аббревиатура от American National Standards
          Institute.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13892"
         href="#AEN13892"><span
         class="footnote">[63]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>См. статью Marius van Oers, <a
           href=
          "http://www.virusbtn.com/magazine/archives/200204/malshell.xml"
           target="_top">Unix Shell Scripting Malware</a>, а также
          ссылку на <span
           class="emphasis"><em
           class="EMPHASIS">Denning</em></span> в разделе <a
           href="#BIBLIOREF">Литература</a>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13946"
         href="#AEN13946"><span
         class="footnote">[64]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Chet Ramey обещал ввести в Bash ассоциативные массивы (они
          хорошо знакомы программистам, работающим с языком Perl) в
          одном из следующих релизов Bash.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13971"
         href="#AEN13971"><span
         class="footnote">[65]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Кто может -- тот делает. Кто не может... тот получает
          сертификат MCSE.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN14612"
         href="#AEN14612"><span
         class="footnote">[66]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Если адресное пространство не указано, то, по-умолчанию, к
          обработке принимаются <span
           class="emphasis"><em
           class="EMPHASIS">все</em></span> строки.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN14950"
         href="#AEN14950"><span
         class="footnote">[67]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Указание кода завершения за пределами установленного
          диапазона, приводит к возврату ошибочных кодов. Например,
          <strong
           class="COMMAND">exit 3809</strong> вернет код завершения,
          равный <span
           class="ERRORCODE">225</span>.</p>
        </td>
      </tr>
    </table>
  </body>
</html>

