<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <meta
     name="generator"
     content=
    "HTML Tidy for Linux/x86 (vers 1st July 2002), see www.w3.org">

    <title>Advanced Bash-Scripting Guide - Часть 4</title>
    <meta
     http-equiv="Content-Type"
     content="text/html; charset=koi8-r">
    <meta
     name="GENERATOR"
     content="Modular DocBook HTML Stylesheet Version 1.7">
  </head>
        <h1
         class="TITLE"><a
         name="AEN2"></a>Advanced Bash-Scripting Guide - Часть 4</h1>
  <body
   class="BOOK"
   bgcolor="#FFFFFF"
   text="#000000"
   link="#0000FF"
   vlink="#840084"
   alink="#0000FF">
      <div
       class="TOC">
        

                  <dt>12.3. <a
                   href="#TIMEDATE">Команды для работы с датой и
                  временем</a></dt>

                  <dt>12.4. <a
                   href="#TEXTPROC">Команды обработки текста</a></dt>

                  <dt>12.5. <a
                   href="#FILEARCHIV">Команды для работы с файлами и
                  архивами</a></dt>

                  <dt>12.6. <a
                   href="#COMMUNICATIONS">Команды для работы с
                  сетью</a></dt>

                  <dt>12.7. <a
                   href="#TERMINALCCMDS">Команды управления
                  терминалом</a></dt>

                  <dt>12.8. <a
                   href="#MATHC">Команды выполнения математических
                  операций</a></dt>
	 
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Удаление файлов в текущем каталоге, чьи имена содержат недопустимые символы.

for filename in *
do
badname=`echo &quot;$filename&quot; | sed -n /[\+\{\;\&quot;\\\=\?~\(\)\&lt;\&gt;\&amp;\*\|\$]/p`
# Недопустимые символы в именах файлов:     + { ; &quot; \ = ? ~ ( ) &lt; &gt; &amp; * | $
rm $badname 2&gt;/dev/null    # Сообщения об ошибках &quot;выстреливаются&quot; в никуда.
done

# Теперь &quot;позаботимся&quot; о файлах, чьи имена содержат пробельные символы.
find . -name &quot;* *&quot; -exec rm -f {} \;
# На место &quot;{}&quot;, find подставит полное имя файла.
# Символ &#39;\&#39; указывает на то, что &#39;;&#39; интерпретируется как обычный символ, а не как конец команды.

exit 0

#---------------------------------------------------------------------
# Строки, приведенные ниже, не будут выполнены, т.к. выше стоит команда &quot;exit&quot;.

# Альтернативный вариант сценария:
find . -name &#39;*[+{;&quot;\\=?~()&lt;&gt;&amp;*|$ ]*&#39; -exec rm -f &#39;{}&#39; \;
exit 0
# (Спасибо S.C.)
</pre>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="IDELETE"></a>

                    <p><strong>Пример 12-3. Удаление файла по его
                    номеру <span
                     class="emphasis"><em
                     class="EMPHASIS">inode</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# idelete.sh: Удаление файла по номеру inode.

#  Этот прием используется в тех случаях, когда имя файла начинается с недопустимого символа,
#+ например, ? или -.

ARGCOUNT=1                      # Имя файла должно быть передано в сценарий.
E_WRONGARGS=70
E_FILE_NOT_EXIST=71
E_CHANGED_MIND=72

if [ $# -ne &quot;$ARGCOUNT&quot; ]
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_WRONGARGS
fi

if [ ! -e &quot;$1&quot; ]
then
  echo &quot;Файл \&quot;&quot;$1&quot;\&quot; не найден.&quot;
  exit $E_FILE_NOT_EXIST
fi

inum=`ls -i | grep &quot;$1&quot; | awk &#39;{print $1}&#39;`
# inum = номер inode (index node) файла
# Каждый файл имеет свой inode, где хранится информация о физическом расположении файла.

echo; echo -n &quot;Вы совершенно уверены в том, что желаете удалить \&quot;$1\&quot; (y/n)? &quot;
# Ключ &#39;-v&#39; в команде &#39;rm&#39; тоже заставит команду вывести подобный запрос.
read answer
case &quot;$answer&quot; in
[nN]) echo &quot;Передумали?&quot;
      exit $E_CHANGED_MIND
      ;;
*)    echo &quot;Удаление файла \&quot;$1\&quot;.&quot;;;
esac

find . -inum $inum -exec rm {} \;
echo &quot;Файл &quot;\&quot;$1&quot;\&quot; удален!&quot;

exit 0
</pre>
                  </div>

                  <p>Дополнительные примеры по использованию команды
                  <strong
                   class="COMMAND">find</strong> вы найдете в <a
                   href="#EX48">Пример 12-22</a>, <a
                   href="#EX58">Пример 3-4</a> и <a
                   href="#FINDSTRING">Пример 10-9</a>. В страницах
                  справочного ркуоводства (man find) вы найдете более
                  подробную информацию об этой достаточно сложной и
                  мощной команде.</p>
                </dd>

                <dt><strong
                 class="COMMAND">xargs</strong></dt>

                <dd>
                  <p>Команда передачи аргументов указанной команде. Она
                  разбивает поток аргументов на отдельные составляющие
                  и поочередно передает их заданной команде для
                  обработки. Эта команда может рассматриваться как
                  мощная замена обратным одиничным кавычкам. Зачастую,
                  когда команды, заключенные в обратные одиночные
                  кавычки, завершаются с ошибкой <span
                   class="ERRORNAME">too many arguments</span> (слишком
                  много аргументов), использование <strong
                   class="COMMAND">xargs</strong> позволяет обойти это
                  ограничение. Обычно, <strong
                   class="COMMAND">xargs</strong> считывает список
                  аргументов со стандартного устройства ввода <tt
                   class="FILENAME">stdin</tt> или из канала
                  (конвейера), но может считывать информацию и из
                  файла.</p>

                  <p>Если команда не задана, то по-умолчанию
                  выполняется <a
                   href="#ECHOREF">echo</a>. При передаче аргументов по
                  конвейеру, <strong
                   class="COMMAND">xargs</strong> допускает наличие
                  пробельных символов и символов перевода строки,
                  которые затем автоматически отбрасываются.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 0
-rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file1
-rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file2</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l | xargs</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">total 0 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file1 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file2</tt>
             
</pre>
                  <br>
                  <br>

                  <p><tt
                   class="USERINPUT"><strong>ls | xargs -p -l
                  gzip</strong></tt> -- упакует с помощью <a
                   href="#GZIPREF">gzip</a> все файлы в текущем
                  каталоге, выводя запрос на подтверждение для каждого
                  файла.</p>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p><strong
                           class="COMMAND">xargs</strong> имеет очень
                          любопытный ключ <tt
                           class="OPTION">-n <tt
                           class="REPLACEABLE"><em>NN</em></tt></tt>,
                          который ограничивает количество передаваемых
                          аргументов за один &quot;присест&quot; числом
                          <tt
                           class="REPLACEABLE"><em>NN</em></tt>.</p>

                          <p><tt
                           class="USERINPUT"><strong>ls | xargs -n 8
                          echo</strong></tt> -- выведет список файлов
                          текущего каталога в <tt
                           class="LITERAL">8</tt> колонок.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Еще одна полезная опция -- <tt
                           class="OPTION">-0</tt>, в комбинации с
                          <strong
                           class="COMMAND">find -print0</strong> или
                          <strong
                           class="COMMAND">grep -lZ</strong> позволяет
                          обрабатывать аргументы, содержащие пробелы и
                          кавычки.</p>

                          <p><tt
                           class="USERINPUT"><strong>find / -type f
                          -print0 | xargs -0 grep -liwZ GUI | xargs -0
                          rm -f</strong></tt></p>

                          <p><tt
                           class="USERINPUT"><strong>grep -rliwZ GUI /
                          | xargs -0 rm -f</strong></tt></p>

                          <p>Обе вышеприведенные команды удалят все
                          файлы, содержащие в своем имени комбинацию
                          символов <span
                           class="QUOTE">&quot;GUI&quot;</span>. <span
                           class="emphasis"><em
                           class="EMPHASIS">(Спасибо
                          S.C.)</em></span></p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX41"></a>

                    <p><strong>Пример 12-4. Использование команды xargs
                    для мониторинга системного журнала</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Создание временного файла мониторинга в текщем каталоге,
# куда переписываются несколько последних строк из /var/log/messages.

# Обратите внимание: если сценарий запускается обычным пользователем,
# то файл /var/log/messages должен быть доступен на чтение этому пользователю.
#         #root chmod 644 /var/log/messages

LINES=5

( date; uname -a ) &gt;&gt;logfile
# Время и информация о системе
echo --------------------------------------------------------------------- &gt;&gt;logfile
tail -$LINES /var/log/messages | xargs |  fmt -s &gt;&gt;logfile
echo &gt;&gt;logfile
echo &gt;&gt;logfile

exit 0

# Упражнение:
# --------
#  Измените сценарий таким образом, чтобы он мог отслеживать изменения в /var/log/messages
#+ с интервалом в 20 минут.
#  Подсказка: воспользуйтесь командой &quot;watch&quot;.
</pre>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX42"></a>

                    <p><strong>Пример 12-5. copydir, копирование файлов
                    из текущего каталога в другое место, с помощью
                    xargs</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Копирует все файлы из текущего каталога
# в каталог, указанный в командной строке.

if [ -z &quot;$1&quot; ]   # Выход, если каталог назначения не задан.
then
  echo &quot;Порядок использования: `basename $0` directory-to-copy-to&quot;
  exit 65
fi

ls . | xargs -i -t cp ./{} $1
# Этот сценария является точным эквивалентом
#    cp * $1
# если в именах файлов не содержатся пробельные символы.

exit 0
</pre>
                  </div>
                </dd>

                <dt><a
                 name="EXPRREF"></a><tt
                 class="USERINPUT"><strong>expr</strong></tt></dt>

                <dd>
                  <p>Универсальный обработчик выражений: вычисляет
                  заданное выражение (аргументы должны отделяться
                  пробелами). Выражения могут быть арифметическими,
                  логическими или строковыми.</p>

                  <div
                   class="VARIABLELIST">
                    <dl>
                      <dt><tt
                       class="USERINPUT"><strong>expr 3 +
                      5</strong></tt></dt>

                      <dd>
                        <p>возвратит <tt
                         class="LITERAL">8</tt></p>
                      </dd>

                      <dt><tt
                       class="USERINPUT"><strong>expr 5 %
                      3</strong></tt></dt>

                      <dd>
                        <p>возвратит 2</p>
                      </dd>

                      <dt><tt
                       class="USERINPUT"><strong>expr 5 \*
                      3</strong></tt></dt>

                      <dd>
                        <p>возвратит 15</p>

                        <p>В арифметических выражениях, оператор
                        умножения обязательно должен экранироваться
                        обратным слэшем.</p>
                      </dd>

                      <dt><tt
                       class="USERINPUT"><strong>y=`expr $y +
                      1`</strong></tt></dt>

                      <dd>
                        <p>Операция инкремента переменной, то же самое,
                        что и <tt
                         class="USERINPUT"><strong>let
                        y=y+1</strong></tt>, или <tt
                         class=
                        "USERINPUT"><strong>y=$(($y+1))</strong></tt>.
                        Пример <a
                         href="#ARITHEXPREF">подстановки арифметических
                        выражений</a>.</p>
                      </dd>

                      <dt><a
                       name="EXPEXTRSUB"></a><tt
                       class="USERINPUT"><strong>z=`expr substr $string
                      $position $length`</strong></tt></dt>

                      <dd>
                        <p>Извлекает подстроку длиной $length символов,
                        начиная с позиции $position.</p>
                      </dd>
                    </dl>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX45"></a>

                    <p><strong>Пример 12-6. Пример работы с
                    expr</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Демонстрация некоторых приемов работы с командой &#39;expr&#39;
# =======================================

echo

# Арифметические операции
# -------------- --------

echo &quot;Арифметические операции&quot;
echo
a=`expr 5 + 3`
echo &quot;5 + 3 = $a&quot;

a=`expr $a + 1`
echo
echo &quot;a + 1 = $a&quot;
echo &quot;(инкремент переменной)&quot;

a=`expr 5 % 3`
# остаток от деления (деление по модулю)
echo
echo &quot;5 mod 3 = $a&quot;

echo
echo

# Логические операции
# ---------- --------

#  Возвращает 1 если выражение истинноо, 0 -- если ложно,
#+ в противоположность соглашениям, принятым в Bash.

echo &quot;Логические операции&quot;
echo

x=24
y=25
b=`expr $x = $y`         # Сравнение.
echo &quot;b = $b&quot;            # 0  ( $x -ne $y )
echo

a=3
b=`expr $a \&gt; 10`
echo &#39;b=`expr $a \&gt; 10`, поэтому...&#39;
echo &quot;Если a &gt; 10, то b = 0 (ложь)&quot;
echo &quot;b = $b&quot;            # 0  ( 3 ! -gt 10 )
echo

b=`expr $a \&lt; 10`
echo &quot;Если a &lt; 10, то b = 1 (истина)&quot;
echo &quot;b = $b&quot;            # 1  ( 3 -lt 10 )
echo
# Обратите внимание на необходимость экранирования операторов.

b=`expr $a \&lt;= 3`
echo &quot;Если a &lt;= 3, то b = 1 (истина)&quot;
echo &quot;b = $b&quot;            # 1  ( 3 -le 3 )
# Существует еще оператор &quot;\&gt;=&quot; (больше или равно).


echo
echo

# Операции сравнения
# -------- ---------

echo &quot;Операции сравнения&quot;
echo
a=zipper
echo &quot;a is $a&quot;
if [ `expr $a = snap` ]
then
   echo &quot;a -- это не zipper&quot;
fi

echo
echo



# Операции со строками
# -------- -- --------

echo &quot;Операции со строками&quot;
echo

a=1234zipper43231
echo &quot;Строка над которой производятся операции: \&quot;$a\&quot;.&quot;

# length: длина строки
b=`expr length $a`
echo &quot;длина строки \&quot;$a\&quot; равна $b.&quot;

# index: позиция первого символа подстроки в строке
b=`expr index $a 23`
echo &quot;Позиция первого символа \&quot;2\&quot; в строке \&quot;$a\&quot; : \&quot;$b\&quot;.&quot;

# substr: извлечение подстроки, начиная с заданной позиции, указанной длины
b=`expr substr $a 2 6`
echo &quot;Подстрока в строке \&quot;$a\&quot;, начиная с позиции 2,\
и длиной в 6 символов: \&quot;$b\&quot;.&quot;


#  При выполнении поиска по шаблону, по-умолчанию поиск
#+ начинается с ***начала*** строки.
#
#        Использование регулярных выражений
b=`expr match &quot;$a&quot; &#39;[0-9]*&#39;`               #  Подсчет количества цифр.
echo Количество цифр с начала строки \&quot;$a\&quot; : $b.
b=`expr match &quot;$a&quot; &#39;\([0-9]*\)&#39;`           #  Обратите внимание на экранирование круглых скобок
#                   ==      ==
echo &quot;Цифры, стоящие в начале строки \&quot;$a\&quot; : \&quot;$b\&quot;.&quot;

echo

exit 0
</pre>
                  </div>

                  <div
                   class="IMPORTANT">
                    <table
                     class="IMPORTANT"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/important.gif"
                         hspace="5"
                         alt="Important"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Вместо оператора <strong
                           class="COMMAND">match</strong> можно
                          использовать оператор <a
                           href="#NULLREF">:</a>. Например, команда <tt
                           class="USERINPUT"><strong>b=`expr $a :
                          [0-9]*`</strong></tt> является точным
                          эквивалентом для <tt
                           class="USERINPUT"><strong>b=`expr match $a
                          [0-9]*`</strong></tt> в примере,
                          рассмотренном выше.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo
echo &quot;Операции над строками с использованием конструкции \&quot;expr \$string : \&quot; &quot;
echo &quot;========================================================================&quot;
echo

a=1234zipper5FLIPPER43231

echo &quot;Строка, над которой выполняются операции: \&quot;`expr &quot;$a&quot; : &#39;\(.*\)&#39;`\&quot;.&quot;
#     Экранирование круглых скобок в шаблоне                    ==  ==


#  Если скобки не экранировать...
#+ то &#39;expr&#39; преобразует строковый операнд в целое число.

echo &quot;Длина строки \&quot;$a\&quot; равна `expr &quot;$a&quot; : &#39;.*&#39;`.&quot;   # Длина строки

echo &quot;Количество цифр с начала строки \&quot;$a\&quot; равно `expr &quot;$a&quot; : &#39;[0-9]*&#39;`.&quot;

# ------------------------------------------------------------------------- #

echo

echo &quot;Цифры, стоящие в начале строки \&quot;$a\&quot; : `expr &quot;$a&quot; : &#39;\([0-9]*\)&#39;`.&quot;
#                                                             ==      ==
echo &quot;Первые 7 символов в строке \&quot;$a\&quot; : `expr &quot;$a&quot; : &#39;\(.......\)&#39;`.&quot;
#     ======                                          ==       ==
# Опять же, необходимо экранировать круглые скобки в шаблоне.
#
echo &quot;Последние 7 символов в строке \&quot;$a\&quot; : `expr &quot;$a&quot; : &#39;.*\(.......\)&#39;`.&quot;
#     =========                  оператор конца строки     ^^
#  (фактически означает переход через любое количество символов, пока
#+  не будет найдена требуемая подстрока)

echo

exit 0
</pre>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>
              </dl>
            </div>

            <p>Этот пример демонстрирует необходимость <span
             class="emphasis"><em
             class="EMPHASIS">экранирования оператора группировки -- \(
            ... \)</em></span> в <a
             href="#REGEXREF">регулярных выражениях</a>, при поиске по
            шаблону командой <strong
             class="COMMAND">expr</strong>.</p>

            <p><a
             href="#PERLREF">Perl</a>, <a
             href="#SEDREF">sed</a> и <a
             href="#AWKREF">awk</a> имеют в своем распоряжении более
            мощный аппарат анализа строк. Коротенький скрипт на <strong
             class="COMMAND">sed</strong> или <strong
             class="COMMAND">awk</strong>, внутри сценария (см. <a
             href="#WRAPPER">Section 33.2</a>) -- значительно более
            привлекательная альтернатива использованию <strong
             class="COMMAND">expr</strong> при анализе строк.</p>

            <p>Дополнительные примеры, по обработке строк, вы найдете в
            <a
             href="#STRING-MANIPULATION">Section 9.2</a>.</p>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="TIMEDATE"></a>12.3. Команды для работы с датой и
            временем</h2>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="TDLISTING1"></a>Время/дата и измерение интервалов
              времени</strong></p>

              <dl>
                <dt><a
                 name="DATEREF"></a><strong
                 class="COMMAND">date</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">date</strong> без параметров выводит
                  дату и время на стандартное устройство вывода <tt
                   class="FILENAME">stdout</tt>. Она становится гораздо
                  интереснее при использовании дополнительных ключей
                  форматирования вывода.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX51"></a>

                    <p><strong>Пример 12-7. Команда date</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Примеры использования команды &#39;date&#39;

echo &quot;Количество дней, прошедших с начала года: `date +%j`.&quot;
# Символ &#39;+&#39; обязателен при использовании форматирующего аргумента
# %j,  возвращающего количество дней, прошедших с начала года.

echo &quot;Количество секунд, прошедших с 01/01/1970 : `date +%s`.&quot;
#  %s количество секунд, прошедших с начала &quot;эпохи UNIX&quot;,
#+ но насколько этот ключ полезен?

prefix=temp
suffix=`eval date +%s`  # Ключ &quot;+%s&quot; характерен для GNU-версии &#39;date&#39;.
filename=$prefix.$suffix
echo $filename
#  Прекрасный способ получения &quot;уникального&quot; имени для временного файла,
#+ даже лучше, чем с использованием $$.

# Дополнительную информацию вы найдете в &#39;man date&#39;.

exit 0
</pre>
                  </div>

                  <p>Ключ <tt
                   class="OPTION">-u</tt> дает UTC время (Universal
                  Coordinated Time -- время по Гринвичу).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>date</strong></tt>
<tt
 class="COMPUTEROUTPUT">Fri Mar 29 21:07:39 MST 2002</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>date -u</strong></tt>
<tt
 class="COMPUTEROUTPUT">Sat Mar 30 04:07:42 UTC 2002</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">zdump</strong></dt>

                <dd>
                  <p>Отображает время для указанной временной зоны.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>zdump EST</strong></tt>
<tt
 class="COMPUTEROUTPUT">EST  Tue Sep 18 22:09:22 2001 EST</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="TIMREF"></a><strong
                 class="COMMAND">time</strong></dt>

                <dd>
                  <p>Выводит подробную статистику по исполнению
                  некоторой команды.</p>

                  <p><tt
                   class="USERINPUT"><strong>time ls -l /</strong></tt>
                  даст нечто подобное:</p>
<pre
 class="SCREEN">
<tt
 class=
"COMPUTEROUTPUT">0.00user 0.01system 0:00.05elapsed 16%CPU (0avgtext+0avgdata 0maxresident)k
 0inputs+0outputs (149major+27minor)pagefaults 0swaps</tt>
</pre>
                  <br>
                  <br>

                  <p>См. так же очень похожую команду <a
                   href="#TIMESREF">times</a>, обсуждавшуюся в
                  предыдущем разделе.</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Начиная с <a
                           href="#BASH2REF">версии 2.0</a> Bash,
                          команда <strong
                           class="COMMAND">time</strong> стала
                          зарезервированным словом интерпретатора, с
                          несколько измененным поведением в
                          конвейере.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><a
                 name="TOUCHREF"></a><strong
                 class="COMMAND">touch</strong></dt>

                <dd>
                  <p>Утилита устанавливает время последнего
                  обращения/изменения файла в текущее системное время
                  или в заданное время, но так же может использоваться
                  для создания нового пустого файла. Команда <tt
                   class="USERINPUT"><strong>touch zzz</strong></tt>
                  создаст новый пустой файл с именем <tt
                   class="FILENAME">zzz</tt>, если перед этим файл <tt
                   class="FILENAME">zzz</tt> отсутствовал. Кроме того,
                  такие пустые файлы могут использоваться для
                  индикации, например, времени последнего изменения в
                  проекте.</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Эквивалентом команды <strong
                           class="COMMAND">touch</strong> могут служить
                          <tt
                           class="USERINPUT"><strong>: &gt;&gt;
                          newfile</strong></tt> или <tt
                           class="USERINPUT"><strong>&gt;&gt;
                          newfile</strong></tt> (для обычных
                          файлов).</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><a
                 name="ATREF"></a><strong
                 class="COMMAND">at</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">at</strong> -- используется для
                  запуска заданий в заданное время. В общих чертах она
                  напоминает <a
                   href="#CRONREF">crond</a>, однако, <strong
                   class="COMMAND">at</strong> используется для
                  однократного запуска набора команд.</p>

                  <p><tt
                   class="USERINPUT"><strong>at 2pm January
                  15</strong></tt> -- попросит ввести набор команд,
                  которые необходимо запустить в указанное время. Эти
                  команды должны быть совместимыми со сценариями
                  командной оболочки. Ввод завершается нажатием
                  комбинации клавиш <a
                   href="#CTLDREF">Ctl-D</a>.</p>

                  <p>Ключ <tt
                   class="OPTION">-f</tt> или операция перенаправления
                  ввода (<span
                   class="TOKEN">&lt;</span>), заставляет <strong
                   class="COMMAND">at</strong> прочитать список команд
                  из файла. Этот файл должен представлять из себя
                  обычный сценарий, на языке командной оболочки и, само
                  собой разумеется, такой сценарий должен быть
                  неинтерактивным. Может использоваться совместно с
                  командой <a
                   href="#RUNPARTSREF">run-parts</a> для запуска
                  различных наборов сценариев.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>at 2:30 am Friday &lt; at-jobs.list</strong></tt>
<tt
 class="COMPUTEROUTPUT">job 2 at 2000-10-27 02:30</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">batch</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">batch</strong>, управляющая запуском
                  заданий, напоминает команду <strong
                   class="COMMAND">at</strong>, но запускает список
                  команд только тогда, когда загруженность системы
                  упадет ниже <tt
                   class="LITERAL">.8</tt>. Подобно команде <strong
                   class="COMMAND">at</strong>, с ключом <tt
                   class="OPTION">-f</tt>, может считывать набор команд
                  из файла.</p>
                </dd>

                <dt><strong
                 class="COMMAND">cal</strong></dt>

                <dd>
                  <p>Выводит на <tt
                   class="FILENAME">stdout</tt> аккуратно
                  отформатированный календарь на текущий месяц. Может
                  выводить календарь за определенный год.</p>
                </dd>

                <dt><strong
                 class="COMMAND">sleep</strong></dt>

                <dd>
                  <p>Приостанавливает исполнение сценария на заданное
                  количество секунд, ничего не делая. Может
                  использоваться для синхронизации процессов,
                  запущенных в фоне, проверяя наступление ожидаемого
                  события так часто, как это необходимо. Например, <a
                   href="#ONLINE">Пример 29-6</a>.</p>
<pre
 class="PROGRAMLISTING">
sleep 3
# Пауза, длительностью в 3 секунды.
</pre>
                  <br>
                  <br>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Команда <strong
                           class="COMMAND">sleep</strong> по-умолчанию
                          принимает количество секунд, но ей можно
                          передать и количество часов и минут и даже
                          дней.</p>
<pre
 class="PROGRAMLISTING">
sleep 3 h
# Приостановка на 3 часа!
</pre>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Для запуска команд через заданные
                          интервалы времени лучше использовать <a
                           href="#WATCHREF">watch</a> .</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">usleep</strong></dt>

                <dd>
                  <p><span
                   class="emphasis"><em
                   class="EMPHASIS">Microsleep</em></span> (здесь
                  символ <span
                   class="QUOTE">&quot;u&quot;</span> должен читаться
                  как буква греческого алфавита -- <span
                   class="QUOTE">&quot;мю&quot;</span>, или префикс
                  микро). Это то же самое, что и <strong
                   class="COMMAND">sleep</strong>, только интервал
                  времени задается в микросекундах. Может
                  использоваться для очень тонкой синхронизации
                  процессов.</p>
<pre
 class="PROGRAMLISTING">
usleep 30
# Приостановка на 30 микросекунд.
</pre>
                  <br>
                  <br>

                  <p>Эта команда является частью пакета <span
                   class="emphasis"><em
                   class="EMPHASIS">initscripts/rc-scripts</em></span>
                  в дистрибутиве Red Hat.</p>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Команда <strong
                           class="COMMAND">usleep</strong> не
                          обеспечивает особую точность соблюдения
                          интервалов, и поэтому она не подходит для
                          применений, критичных ко времени.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">hwclock</strong>, <strong
                 class="COMMAND">clock</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">hwclock</strong> используется для
                  получения доступа или коррекции аппаратных часов
                  компьютера. С некоторыми ключами требует наличия
                  привилегий root. Сенарий <tt
                   class="FILENAME">/etc/rc.d/rc.sysinit</tt>
                  использует команду <strong
                   class="COMMAND">hwclock</strong> для установки
                  системного времени во время загрузки.</p>

                  <p>Команда <strong
                   class="COMMAND">clock</strong> -- это синоним
                  команды <strong
                   class="COMMAND">hwclock</strong>.</p>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="TEXTPROC"></a>12.4. Команды обработки текста</h2>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="TPCOMMANDLISTING1"></a></strong></p>

              <dl>
                <dt><a
                 name="SORTREF"></a><strong
                 class="COMMAND">sort</strong></dt>

                <dd>
                  <p>Сортирует содержимое файла, часто используется как
                  промежуточный фильтр в конвейерах. Эта команда
                  сортирует поток текста в порядке убывания или
                  возрастания, в зависимости от заданных опций. Ключ
                  <tt
                   class="OPTION">-m</tt> используется для сортировки и
                  объединения входных файлов. В <span
                   class="emphasis"><em
                   class="EMPHASIS">странице info</em></span>
                  перечислено большое количество возможных вариантов
                  ключей. См. <a
                   href="#FINDSTRING">Пример 10-9</a>, <a
                   href="#SYMLINKS">Пример 10-10</a> и <a
                   href="#MAKEDICT">Пример A-9</a>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">tsort</strong></dt>

                <dd>
                  <p>Топологическая сортировка, считывает пары строк,
                  разделенных пробельными символами, и выполняет
                  сортировку, в зависимости от заданного шаблона.</p>
                </dd>

                <dt><a
                 name="UNIQREF"></a><strong
                 class="COMMAND">uniq</strong></dt>

                <dd>
                  <p>Удаляет повторяющиеся строки из отсортированного
                  файла. Эту команду часто можно встретить в конвейере
                  с командой <a
                   href="#SORTREF">sort</a>.</p>
<pre
 class="PROGRAMLISTING">
cat list-1 list-2 list-3 | sort | uniq &gt; final.list
# Содержимое файлов,
# сортируется,
# затем удаляются повторяющиеся строки,
# и результат записывается в выходной файл.
</pre>
                  <br>
                  <br>

                  <p>Ключ <tt
                   class="OPTION">-c</tt> выводит количество
                  повторяющихся строк.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat testfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">Эта строка встречается только один раз.
Эта строка встречается дважды.
Эта строка встречается дважды.
Эта строка встречается трижды.
Эта строка встречается трижды.
Эта строка встречается трижды.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uniq -c testfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">1 Эта строка встречается только один раз.
2 Эта строка встречается дважды.
3 Эта строка встречается трижды.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>sort testfile | uniq -c | sort -nr</strong></tt>
<tt
 class="COMPUTEROUTPUT">3 Эта строка встречается трижды.
2 Эта строка встречается дважды.
1 Эта строка встречается только один раз.</tt>
             
</pre>
                  <br>
                  <br>

                  <p>Команда <tt
                   class="USERINPUT"><strong>sort INPUTFILE | uniq -c |
                  sort -nr</strong></tt> выводит <span
                   class="emphasis"><em
                   class="EMPHASIS">статистику
                  встречаемости</em></span> строк в файле <tt
                   class="FILENAME">INPUTFILE</tt> (ключ <tt
                   class="OPTION">-nr</tt>, в команде <strong
                   class="COMMAND">sort</strong>, означает сортировку в
                  порядке убывания). Этот шаблон может с успехом
                  использоваться при анализе файлов системного журнала,
                  словарей и везде, где необходимо проанализировать
                  лексическую структуру документа.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="WF"></a>

                    <p><strong>Пример 12-8. Частота встречаемости
                    отдельных слов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# wf.sh: &quot;Сырой&quot; анализ частоты встречаемости слова в текстовом файле.


ARGS=1
E_BADARGS=65
E_NOFILE=66

if [ $# -ne &quot;$ARGS&quot; ]  # Файл для анализа задан?
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

if [ ! -f &quot;$1&quot; ]       # Проверка существования файла.
then
  echo &quot;Файл \&quot;$1\&quot; не найден.&quot;
  exit $E_NOFILE
fi



########################################################
# main ()
sed -e &#39;s/\.//g&#39;  -e &#39;s/ /\
/g&#39; &quot;$1&quot; | tr &#39;A-Z&#39; &#39;a-z&#39; | sort | uniq -c | sort -nr
#                           =========================
#                         Подсчет количества вхождений

#  Точки и пробелы заменяются
#+ символами перевода строки,
#+ затем символы переводятся в нижний регистр
#+ и наконец подсчитывается количество вхождений,
#+ и выполняется сортировка по числу вхождений.
########################################################

# Упражнения:
# ---------
# 1) Добавьте команду &#39;sed&#39; для отсечения других знаков пунктуации, например, запятых.
# 2) Добавьте удаление лишних пробелов и других пробельных символов.
# 3) Добавьте дополнительную сортировку так, чтобы слова с одинаковой частотой встречаемости
#+   сортировались бы в алфавитном порядке.

exit 0
</pre>
                  </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat testfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">Эта строка встречается только один раз.
Эта строка встречается дважды.
Эта строка встречается дважды.
Эта строка встречается трижды.
Эта строка встречается трижды.
Эта строка встречается трижды.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>./wf.sh testfile</strong></tt>
 <tt
 class="COMPUTEROUTPUT">      6 Эта
       6 встречается
       6 строка
       3 трижды
       2 дважды
       1 только
       1 один
       1 раз
                        </tt> 
              
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="EXPANDREF"></a><strong
                 class="COMMAND">expand</strong>, <strong
                 class="COMMAND">unexpand</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">expand</strong> преобразует символы
                  табуляции в пробелы. Часто используется в конвейерной
                  обработке текста.</p>

                  <p>Команда <strong
                   class="COMMAND">unexpand</strong> преобразует
                  пробелы в символы табуляции. Т.е. она является
                  обратной по отношению к команде <strong
                   class="COMMAND">expand</strong>.</p>
                </dd>

                <dt><a
                 name="CUTREF"></a><strong
                 class="COMMAND">cut</strong></dt>

                <dd>
                  <p>Предназначена для извлечения отдельных полей из
                  текстовых файлов. Напоминает команду <tt
                   class="USERINPUT"><strong>print $N</strong></tt> в
                  <a
                   href="#AWKREF">awk</a>, но более ограничена в своих
                  возможностях. В простейших случаях может быть
                  неплохой заменой <strong
                   class="COMMAND">awk</strong> в сценариях. Особую
                  значимость, для команды <strong
                   class="COMMAND">cut</strong>, представляют ключи <tt
                   class="OPTION">-d</tt> (разделитель полей) и <tt
                   class="OPTION">-f</tt> (номер(а) поля(ей)).</p>

                  <p>Использование команды <strong
                   class="COMMAND">cut</strong> для получения списка
                  смонтированных файловых систем:</p>
<pre
 class="PROGRAMLISTING">
cat /etc/mtab | cut -d &#39; &#39; -f1,2
</pre>
                  <br>
                  <br>

                  <p>Использование команды <strong
                   class="COMMAND">cut</strong> для получения версии ОС
                  и ядра:</p>
<pre
 class="PROGRAMLISTING">
uname -a | cut -d&quot; &quot; -f1,3,11,12
</pre>
                  <br>
                  <br>

                  <p>Использование команды <strong
                   class="COMMAND">cut</strong> для извлечения
                  заголовков сообщений из электронных писем:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep &#39;^Subject:&#39; read-messages | cut -c10-80</strong></tt>
<tt
 class="COMPUTEROUTPUT">Re: Linux suitable for mission-critical apps?
 MAKE MILLIONS WORKING AT HOME3
 Spam complaint
 Re: Spam complaint</tt>
</pre>
                  <br>
                  <br>

                  <p>Использование команды <strong
                   class="COMMAND">cut</strong> при разборе текстового
                  файла:</p>
<pre
 class="PROGRAMLISTING">
# Список пользователей в /etc/passwd.

FILENAME=/etc/passwd

for user in $(cut -d: -f1 $FILENAME)
do
  echo $user
done

# Спсибо Oleg Philon за этот пример.
</pre>
                  <br>
                  <br>

                  <p><tt
                   class="USERINPUT"><strong>cut -d &#39; &#39; -f2,3
                  filename</strong></tt> эквивалентно <tt
                   class="USERINPUT"><strong>awk -F&#39;[ ]&#39; &#39;{
                  print $2, $3 }&#39; filename</strong></tt></p>

                  <p>См. также <a
                   href="#BASE">Пример 12-33</a>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">paste</strong></dt>

                <dd>
                  <p>Используется для объединения нескольких файлов в
                  один многоколоночный файл.</p>
                </dd>

                <dt><strong
                 class="COMMAND">join</strong></dt>

                <dd>
                  <p>Может рассматриваться как команда, родственная
                  команде <strong
                   class="COMMAND">paste</strong>. Эта мощная утилита
                  позволяет объединять два файла по общему полю, что
                  представляет собой упрощенную версию реляционной базы
                  данных.</p>

                  <p>Команда <strong
                   class="COMMAND">join</strong> оперирует только двумя
                  файлами и объедияет только те строки, которые имеют
                  общее поле (обычно числовое), результат объединения
                  выводится на <tt
                   class="FILENAME">stdout</tt>. Объединяемые файлы
                  должны быть отсортированы по ключевому полю.</p>
<pre
 class="PROGRAMLISTING">
File: 1.data

100 Shoes
200 Laces
300 Socks
</pre>
                  <br>
                  <br>
<pre
 class="PROGRAMLISTING">
File: 2.data

100 $40.00
200 $1.00
300 $2.00
</pre>
                  <br>
                  <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>join 1.data 2.data</strong></tt>
<tt
 class="COMPUTEROUTPUT">File: 1.data 2.data

100 Shoes $40.00
200 Laces $1.00
300 Socks $2.00</tt>
             
</pre>
                  <br>
                  <br>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>На выходе ключевое поле встречается только
                          один раз.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">head</strong></dt>

                <dd>
                  <p>Выводит начальные строки из файла на <tt
                   class="FILENAME">stdout</tt> (по-умолчанию -- <tt
                   class="LITERAL">10</tt> строк, но это число можно
                  задать иным). Эта команда имеет ряд интересных
                  ключей.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="SCRIPTDETECTOR"></a>

                    <p><strong>Пример 12-9. Какие из файлов являются
                    сценариями?</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# script-detector.sh: Отыскивает файлы сценариев в каталоге.

TESTCHARS=2    # Проверяются первые два символа.
SHABANG=&#39;#!&#39;   # Сценарии как правило начинаются с &quot;sha-bang.&quot;

for file in *  # Обход всех файлов в каталоге.
do
  if [[ `head -c$TESTCHARS &quot;$file&quot;` = &quot;$SHABANG&quot; ]]
  #      head -c2                      #!
  #  Ключ &#39;-c&#39; в команде &quot;head&quot; выводит заданное
  #+ количество символов, а не строк.
  then
    echo &quot;Файл \&quot;$file\&quot; -- сценарий.&quot;
  else
    echo &quot;Файл \&quot;$file\&quot; не является сценарием.&quot;
  fi
done
  
exit 0
</pre>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="RND"></a>

                    <p><strong>Пример 12-10. Генератор 10-значных
                    случайных чисел</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# rnd.sh: Генератор 10-значных случайных чисел

# Автор: Stephane Chazelas.

head -c4 /dev/urandom | od -N4 -tu4 | sed -ne &#39;1s/.* //p&#39;


# =================================================================== #

# Описание
# --------

# head:
# -c4 -- первые 4 байта.

# od:
# -N4 ограничивает вывод 4-мя байтами.
# -tu4 беззнаковый десятичный формат вывода.

# sed:
# -n, в комбинации с флагом &quot;p&quot;, в команде &quot;s&quot;,
# выводит только совпадающие с шаблоном строки.



# Автор сценария описывает действия &#39;sed&#39; таким образом:

# head -c4 /dev/urandom | od -N4 -tu4 | sed -ne &#39;1s/.* //p&#39;
# ----------------------------------&gt; |

# Передает вывод в &quot;sed&quot;    --------&gt; |
# пусть это будет 0000000 1198195154\n

# sed начинает читать символы: 0000000 1198195154\n.
# Здесь он находит символ перевода строки,
# таким образом он получает строку (0000000 1198195154).
# Затем он просматривает &lt;диапазон&gt;&lt;действие&gt;. Первый и единственный -- это

#   диапазон  действие
#   1         s/.* //p

# Номер строки попадает в заданный лиапазон, так что теперь он приступает к выполнению действия:
# пытается заменить наибольшую подстроку, заканчивающуюся пробелом
# (&quot;0000000 &quot;) &quot;ничем&quot; (//), и если замена произведена -- выводит результат
# (&quot;p&quot; -- это флаг команды &quot;s&quot;, а не команда &quot;p&quot;, которая имеет иное значение).

# теперь sed готов продолжить чтение входного потока. (Обратите внимание:
# если опустить ключ -n, то sed выведет строку еще раз)

# Теперь sed дочитывает остаток строки.
# Он готов приступить к анализу 2-й строки (которая отмечена &#39;$&#39;
# как последняя).
# Поскольку строка не попадает в заданный &lt;диапазон&gt;, на этом обработка прекращается.

# Проще говоря, команда sed означает:
# &quot;В первой строке удалить любые символы, вплоть до последнего встреченного пробела,
# и затем вывести остаток.&quot;

# Сделать это можно более простым способом:
#           sed -e &#39;s/.* //;q&#39;

# Где, заданы два &lt;диапазона&gt;&lt;действия&gt; (можно записать и по другому
#           sed -e &#39;s/.* //&#39; -e q):

#   диапазон                          действие
#   ничего (для совпадающих строк)    s/.* //
#   ничего (для совпадающих строк)    q (quit)

# Здесь sed считывает только первую строку.
# Выполняет оба действия, и выводит строку перед завершением
# (действие &quot;q&quot;), поскольку ключ &quot;-n&quot; опущен.

# =================================================================== #

# Простая альтернатива:
#           head -c4 /dev/urandom| od -An -tu4

exit 0
</pre>
                  </div>
                  См. также <a
                   href="#EX52">Пример 12-30</a>.<br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">tail</strong></dt>

                <dd>
                  <p>Выводит последние строки из файла на <tt
                   class="FILENAME">stdout</tt> (по-умолчанию -- 10
                  строк). Обычно используется для мониторинга системных
                  журналов. Ключ <tt
                   class="OPTION">-f</tt>, позволяет вести непрерывное
                  наблюдение за добавляемыми строками в файл.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX12"></a>

                    <p><strong>Пример 12-11. Мониторинг системного
                    журнала с помощью tail</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

filename=sys.log

cat /dev/null &gt; $filename; echo &quot;Создание / очистка временного файла.&quot;
#  Если файл отсутствует, то он создается,
#+ и очищается, если существует.
#  : &gt; filename   и   &gt; filename дают тот же эффект.

tail /var/log/messages &gt; $filename
# Файл /var/log/messages должен быть доступен для чтения.

echo &quot;В файл $filename записаны последние строки из /var/log/messages.&quot;

exit 0
</pre>
                  </div>

                  <p>См. также <a
                   href="#EX41">Пример 12-4</a>, <a
                   href="#EX52">Пример 12-30</a> и <a
                   href="#ONLINE">Пример 29-6</a>.</p>
                </dd>

                <dt><a
                 name="GREPREF"></a><strong
                 class="COMMAND">grep</strong></dt>

                <dd>
                  <p>Многоцелевая поисковая утилита, использующая <a
                   href="#REGEXREF">регулярные выражения</a>.
                  Изначально это была команда в древнем строчном
                  редакторе <strong
                   class="COMMAND">ed</strong>, <tt
                   class="USERINPUT"><strong>g/re/p</strong></tt>, что
                  означает -- <span
                   class="emphasis"><em
                   class="EMPHASIS">global - regular expression -
                  print</em></span>.</p>

                  <p><strong
                   class="COMMAND">grep</strong> <tt
                   class="REPLACEABLE"><em>pattern</em></tt> [<tt
                   class="REPLACEABLE"><em>file</em></tt>...]</p>
                  Поиск участков текста в файле(ах), соответствующих
                  шаблону <tt
                   class="REPLACEABLE"><em>pattern</em></tt>, где <tt
                   class="REPLACEABLE"><em>pattern</em></tt> может быть
                  как обычной строкой, так и регулярным выражением.<br>
                  <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep &#39;[rst]ystem.$&#39; osinfo.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">The GPL governs the distribution of the Linux operating system.</tt>
             
</pre>
                  <br>
                  <br>

                  <p>Если файл(ы) для поиска не задан, то команда
                  <strong
                   class="COMMAND">grep</strong> работает как фильтр
                  для устройства <tt
                   class="FILENAME">stdout</tt>, например в <a
                   href="#PIPEREF">конвейере</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ps ax | grep clock</strong></tt>
<tt
 class="COMPUTEROUTPUT">765 tty1     S      0:00 xclock
 901 pts/1    S      0:00 grep clock</tt>
             
</pre>
                  <br>
                  <br>

                  <p><tt
                   class="OPTION">-i</tt> -- выполняется поиск без
                  учета регистра символов.</p>

                  <p><tt
                   class="OPTION">-w</tt> -- поиск совпадений целого
                  слова.</p>

                  <p><tt
                   class="OPTION">-l</tt> -- вывод только имен файлов,
                  в которых найдены участки, совпадающие с заданным
                  образцом/шаблоном, без вывода совпадающих строк.</p>

                  <p><tt
                   class="OPTION">-r</tt> -- (рекурсивный поиск) поиск
                  выполняется в текущем каталоге и всех вложенных
                  подкаталогах.</p>

                  <p>The <tt
                   class="OPTION">-n</tt> option lists the matching
                  lines, together with line numbers.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep -n Linux osinfo.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">2:This is a file containing information about Linux.
 6:The GPL governs the distribution of the Linux operating system.</tt>
             
</pre>
                  <br>
                  <br>

                  <p><tt
                   class="OPTION">-v</tt> (или <tt
                   class="OPTION">--invert-match</tt>) -- выводит
                  только строки, не содержащие совпадений.</p>
<pre
 class="PROGRAMLISTING">
grep pattern1 *.txt | grep -v pattern2

# Выводятся строки из &quot;*.txt&quot;, совпадающие с &quot;pattern1&quot;,
# но ***не*** совпадающие с &quot;pattern2&quot;.
</pre>
                  <br>
                  <br>

                  <p><tt
                   class="OPTION">-c</tt> (<tt
                   class="OPTION">--count</tt>) -- выводит количество
                  совпадений без вывода самих совпадений.</p>
<pre
 class="PROGRAMLISTING">
grep -c txt *.sgml   # (количество совпадений с &quot;txt&quot; в &quot;*.sgml&quot; файлах)


#   grep -cz .
#            ^ точка
# означает подсчет (-c) непустых (&quot;.&quot; -- содержащих хотя бы один символ) элементов,
# разделенных нулевыми байтами (-z)
#
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -cz .     # 4
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -cz &#39;$&#39;   # 5
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -cz &#39;^&#39;   # 5
#
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -c &#39;$&#39;    # 9
# По-умолчанию, в качестве разделителя, принимается символ перевода строки (\n).

# Обратите внимание: ключ -z характерен для GNU-версии &quot;grep&quot;.


# Спасибо S.C.
</pre>
                  <br>
                  <br>

                  <p>Если <strong
                   class="COMMAND">grep</strong> вызывается для поиска
                  по группе файлов, то вывод будет содержать указание
                  на имена файлов, в которых найдены совпадения.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep Linux osinfo.txt misc.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.
 misc.txt:The Linux operating system is steadily gaining in popularity.</tt>
             
</pre>
                  <br>
                  <br>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Для того, чтобы заставить <strong
                           class="COMMAND">grep</strong> выводить имя
                          файла, когда поиск производится по
                          одному-единственному файлу, достаточно
                          указать устройство <tt
                           class="FILENAME">/dev/null</tt> в качестве
                          второго файла.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep Linux osinfo.txt /dev/null</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.</tt>
             
</pre>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <p>Если совпадение было найдено, то <strong
                   class="COMMAND">grep</strong> возвращает <a
                   href="#EXITSTATUSREF">код завершения</a> -- 0, это
                  может оказаться полезным при выполнении поиска в
                  условных операторах ( в таких случаях особый интерес
                  может представлять ключ <tt
                   class="OPTION">-q</tt>, который подавляет
                  вывод).</p>
<pre
 class="PROGRAMLISTING">
SUCCESS=0                      # если найдено совпадение
word=Linux
filename=data.file

grep -q &quot;$word&quot; &quot;$filename&quot;    # &quot;-q&quot; -- подавляет вывод на stdout.

if [ $? -eq $SUCCESS ]
then
  echo &quot;Образец $word найден в $filename&quot;
else
  echo &quot;Образец $word в файле $filename не найден&quot;
fi
</pre>
                  <br>
                  <br>

                  <p><a
                   href="#ONLINE">Пример 29-6</a> -- пример поиска
                  заданного образца в системном журнале, с помощью
                  <strong
                   class="COMMAND">grep</strong>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="GRP"></a>

                    <p><strong>Пример 12-12. Сценарий-эмулятор <span
                     class="QUOTE">&quot;grep&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# grp.sh: Очень &quot;грубая&quot; реализация &#39;grep&#39;.

E_BADARGS=65

if [ -z &quot;$1&quot; ]    # Проверка наличия аргументов.
then
  echo &quot;Порядок использования: `basename $0` pattern&quot;
  exit $E_BADARGS
fi

echo

for file in *     # Обход всех файлов в $PWD.
do
  output=$(sed -n /&quot;$1&quot;/p $file)  # Подстановка команд.

  if [ ! -z &quot;$output&quot; ]           # Что произойдет, если кавычки вокруг &quot;$output&quot; убрать?
  then
    echo -n &quot;$file: &quot;
    echo $output
  fi              #  эквивалент: sed -ne &quot;/$1/s|^|${file}: |p&quot;

  echo
done

echo

exit 0

# Упражнения:
# ---------
# 1) Добавьте вывод символов перевода строки, если найдено более одного совпадения в любом из файлов.
# 2) Добавьте обработку различных ключей.
</pre>
                  </div>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p><a
                           name="EGREPREF"></a><strong
                           class="COMMAND">egrep</strong> -- то же
                          самое, что и <strong
                           class="COMMAND">grep -E</strong>. Эта
                          команда использует несколько отличающийся,
                          расширенный набор <a
                           href="#REGEXREF">регулярных выражений</a>,
                          что позволяет выполнять поиск более
                          гибко.</p>

                          <p><strong
                           class="COMMAND">fgrep</strong> -- то же
                          самое, что и <strong
                           class="COMMAND">grep -F</strong>. Эта
                          команда выполняет поиск строк символов (не
                          регулярных выражений), что несколько
                          увеличивает скорость поиска.</p>

                          <p>Утилита <strong
                           class="COMMAND">agrep</strong> имеет более
                          широкие возможности поиска приблизительных
                          совпадений. Образец поиска может отличаться
                          от найденной строки на указанное число
                          символов.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Для поиска по сжатым файлам следует
                          использовать утилиты <strong
                           class="COMMAND">zgrep</strong>, <strong
                           class="COMMAND">zegrep</strong> или <strong
                           class="COMMAND">zfgrep</strong>. Они с
                          успехом могут использоваться и для не сжатых
                          файлов, но в этом случае они уступают в
                          скорости обычным <strong
                           class="COMMAND">grep</strong>, <strong
                           class="COMMAND">egrep</strong> и <strong
                           class="COMMAND">fgrep</strong>. Они очень
                          удобны при выполнении поиска по смешенному
                          набору файлов -- когда одни файлы сжаты, а
                          другие нет.</p>

                          <p>Для поиска по <a
                           href="#BZIPREF">bzip</a>-файлам используйте
                          <strong
                           class="COMMAND">bzgrep</strong>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">look</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">look</strong> очень похожа на
                  <strong
                   class="COMMAND">grep</strong>, и предназначена для
                  поиска по <span
                   class="QUOTE">&quot;словарям&quot;</span> --
                  отсортированным файлам. По-умолчанию, поиск
                  выполняется в файле <tt
                   class="FILENAME">/usr/dict/words</tt>, но может быть
                  указан и другой словарь.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="LOOKUP"></a>

                    <p><strong>Пример 12-13. Поиск слов в
                    словаре</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# lookup: Выполняется поиск каждого слова из файла в словаре.

file=words.data  # Файл с искомыми словами.

echo

while [ &quot;$word&quot; != end ]  # Последнее слово в файле.
do
  read word      # Из файла, потому, что выполнено перенаправление в конце цикла.
  look $word &gt; /dev/null  # Подавление вывода строк из словаря.
  lookup=$?      # Код возврата команды &#39;look&#39;.

  if [ &quot;$lookup&quot; -eq 0 ]
  then
    echo &quot;Слово \&quot;$word\&quot; найдено.&quot;
  else
    echo &quot;Слово \&quot;$word\&quot; не найдено.&quot;
  fi

done &lt;&quot;$file&quot;    # Перенаправление ввода из файла $file, так что &quot;чтение&quot; производится оттуда.

echo

exit 0

# ----------------------------------------------------------------
# Строки, расположенные ниже не будут исполнены, поскольку выше стоит команда &quot;exit&quot;.


# Stephane Chazelas предложил более короткий вариант:

while read word &amp;&amp; [[ $word != end ]]
do if look &quot;$word&quot; &gt; /dev/null
   then echo &quot;Слово \&quot;$word\&quot; найдено.&quot;
   else echo &quot;Слово \&quot;$word\&quot; не найдено.&quot;
   fi
done &lt;&quot;$file&quot;

exit 0
</pre>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">sed</strong>, <strong
                 class="COMMAND">awk</strong></dt>

                <dd>
                  <p>Скриптовые языки, специально разработанные для
                  анализа текстовых данных.</p>
                </dd>

                <dt><strong
                 class="COMMAND"><a
                 href="#SEDREF">sed</a></strong></dt>

                <dd>
                  <p>Неинтерактивный <span
                   class="QUOTE">&quot;потоковый редактор&quot;</span>.
                  Широко используется в сценариях на языке командной
                  оболочки.</p>
                </dd>

                <dt><strong
                 class="COMMAND"><a
                 href="#AWKREF">awk</a></strong></dt>

                <dd>
                  <p>Утилита контекстного поиска и преобразования
                  текста, замечательный инструмент для извлечения и/или
                  обработки полей (колонок) в структурированных
                  текстовых файлах. Синтаксис awk напоминает язык
                  C.</p>
                </dd>

                <dt><strong
                 class="COMMAND">wc</strong></dt>

                <dd>
                  <p><span
                   class="emphasis"><em
                   class="EMPHASIS">wc</em></span> -- <span
                   class="QUOTE">&quot;word count&quot;</span>, счетчик
                  слов в файле или в потоке:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash $</tt> <tt
 class="USERINPUT"><strong>wc /usr/doc/sed-3.02/README</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">20     127     838 /usr/doc/sed-3.02/README</tt>
[20 строк  127 слов  838 символов]
</pre>
                  <br>
                  <br>

                  <p><tt
                   class="USERINPUT"><strong>wc -w</strong></tt>
                  подсчитывает только слова.</p>

                  <p><tt
                   class="USERINPUT"><strong>wc -l</strong></tt>
                  подсчитывает только строки.</p>

                  <p><tt
                   class="USERINPUT"><strong>wc -c</strong></tt>
                  подсчитывает только символы.</p>

                  <p><tt
                   class="USERINPUT"><strong>wc -L</strong></tt>
                  возвращает длину наибольшей строки.</p>

                  <p>Подсчет количества <span
                   class="emphasis"><em
                   class="EMPHASIS">.txt</em></span>-файлов в текущем
                  каталоге с помощью <strong
                   class="COMMAND">wc</strong>:</p>
<pre
 class="PROGRAMLISTING">
$ ls *.txt | wc -l
# Эта команда будет работать, если ни в одном из имен файлов &quot;*.txt&quot; нет символа перевода строки.

# Альтернативный вариант:
#      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
#      (shopt -s nullglob; set -- *.txt; echo $#)

# Спасибо S.C.
</pre>
                  <br>
                  <br>

                  <p>Подсчет общего размера файлов, чьи имена
                  начинаются с символов, в диапазоне d - h</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>wc [d-h]* | grep total | awk &#39;{print $3}&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">71832</tt>
             
</pre>
                  <br>
                  <br>

                  <p>От переводчика: в случае, если у вас локаль
                  отлична от &quot;C&quot;, то вышеприведенная команда
                  может не дать результата, поскольку <strong
                   class="COMMAND">wc</strong> вернет не слово
                  &quot;total&quot;, в конце вывода, а
                  &quot;итого&quot;. Тогда можно попробовать несколько
                  измененный вариант:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>wc [d-h]* | grep итого | awk &#39;{print $3}&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">71832</tt>
             
</pre>
                  <br>
                  <br>

                  <p>Использование <strong
                   class="COMMAND">wc</strong> для подсчета количества
                  вхождений слова <span
                   class="QUOTE">&quot;Linux&quot;</span> в основной
                  исходный файл с текстом этого руководства.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep Linux abs-book.sgml | wc -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">50</tt>
             
</pre>
                  <br>
                  <br>

                  <p>См. также <a
                   href="#EX52">Пример 12-30</a> и <a
                   href="#REDIR4">Пример 16-7</a>.</p>

                  <p>Отдельные команды располагают функциональностью
                  <strong
                   class="COMMAND">wc</strong> в виде своих ключей.</p>
<pre
 class="PROGRAMLISTING">
... | grep foo | wc -l
# Часто встречающаяся конструкция, которая может быть сокращена.

... | grep -c foo
# Ключ &quot;-c&quot; (&quot;--count&quot;) команды grep.

# Спасибо S.C.
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="TRREF"></a><strong
                 class="COMMAND">tr</strong></dt>

                <dd>
                  <p>Замена одних символов на другие.</p>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>В отдельных случаях <a
                           href="#UCREF">символы необходимо заключать в
                          кавычки и/или квадратные скобки</a>. Кавычки
                          предотвращают интерпретацию специальных
                          символов командной оболочкой. Квадратные
                          скобки должны заключаться в кавычки.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <p>Команда <tt
                   class="USERINPUT"><strong>tr &quot;A-Z&quot;
                  &quot;*&quot; &lt;filename</strong></tt> или <tt
                   class="USERINPUT"><strong>tr A-Z \*
                  &lt;filename</strong></tt> заменяет все символы
                  верхнего регистра в <tt
                   class="FILENAME">filename</tt> на звездочки (вывод
                  производится на <tt
                   class="FILENAME">stdout</tt>). В некоторых системах
                  этот вариант может оказаться неработоспособным, тогда
                  попробуйте <tt
                   class="USERINPUT"><strong>tr A-Z
                  &#39;[**]&#39;</strong></tt>.</p>

                  <p>Ключ <tt
                   class="OPTION">-d</tt> удаляет символы из заданного
                  диапазона.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;abcdef&quot;                 # abcdef
echo &quot;abcdef&quot; | tr -d b-d     # aef


tr -d 0-9 &lt;filename
# Удалит все цифровые символы из файла &quot;filename&quot;.
</pre>
                  <br>
                  <br>

                  <p>Ключ <tt
                   class="OPTION">--squeeze-repeats</tt> (<tt
                   class="OPTION">-s</tt>) удалит все повторяющиеся
                  последовательности символов. Может использоваться для
                  удаления лишних <a
                   href="#WHITESPACEREF">пробельных символов</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;XXXXX&quot; | tr --squeeze-repeats &#39;X&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">X</tt>
</pre>
                  <br>
                  <br>

                  <p>Ключ <tt
                   class="OPTION">-c</tt> <span
                   class="QUOTE">&quot;complement&quot;</span> <span
                   class="emphasis"><em
                   class="EMPHASIS">заменит</em></span> символы в
                  соответствии с шаблоном. Этот ключ воздействует
                  только на те символы, которые НЕ соответствуют
                  заданному шаблону.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;acfdeb123&quot; | tr -c b-d +</strong></tt>
<tt
 class="COMPUTEROUTPUT">+c+d+b++++</tt>
</pre>
                  <br>
                  <br>

                  <p>Обратите внимание: команда <strong
                   class="COMMAND">tr</strong> корректно распознает <a
                   href="#POSIXREF">символьные классы POSIX</a>. <a
                   name="AEN7520"
                   href="#FTN.AEN7520"><span
                   class="footnote">[29]</span></a></p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;abcd2ef1&quot; | tr &#39;[:alpha:]&#39; -</strong></tt>
<tt
 class="COMPUTEROUTPUT">----2--1</tt>
             
</pre>
                  <br>
                  <br>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX49"></a>

                    <p><strong>Пример 12-14. toupper: Преобразование
                    символов в верхний регистр.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Преобразование символов в верхний регистр.

E_BADARGS=65

if [ -z &quot;$1&quot; ]  # Стандартная проверка командной строки.
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

tr a-z A-Z &lt;&quot;$1&quot;

# Тот же эффект можно получить при использовании символьных классов POSIX:
#        tr &#39;[:lower:]&#39; &#39;[:upper:]&#39; &lt;&quot;$1&quot;
# Спасибо S.C.

exit 0
</pre>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="LOWERCASE"></a>

                    <p><strong>Пример 12-15. lowercase: Изменение имен
                    всех файлов в текущем каталоге в нижний
                    регистр.</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
#
# Изменит все имена файлов в текущем каталоге в нижнй регистр.
#


for filename in *                # Обход всех файлов в каталоге.
do
   fname=`basename $filename`
   n=`echo $fname | tr A-Z a-z`  # Перевести символы в нижний регистр.
   if [ &quot;$fname&quot; != &quot;$n&quot; ]       # Переименовать только те файлы, имена которых изменились.
   then
     mv $fname $n
   fi
done

exit 0


# Сироки приведенные ниже не будут исполняться, поскольку выше стоит команда &quot;exit&quot;.
#--------------------------------------------------------#
# Запустите эту часть сценария, удалив строки , стоящие выше.

# Сценарий, приведенный выше, не работает с именами файлов, содержащими пробелы или символы перевода строки.

# В связи с этим, Stephane Chazelas предложил следующий вариант:


for filename in *    # Нет необходимости использовать basename,
                     # поскольку &quot;*&quot; возвращает имена, не содержащие &quot;/&quot;.
do n=`echo &quot;$filename/&quot; | tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;`
#                             символьные классы POSIX.
#                    Завершающий слэш добавлен для того, чтобы символ перевода строки
#                    не был удален при подстановке команды.
   # Подстановка переменной:
   n=${n%/}          # Удаление завершающего слэша, добавленного выше.
   [[ $filename == $n ]] || mv &quot;$filename&quot; &quot;$n&quot;
                     # Проверка -- действительно ли изменилось имя файла.
done

exit 0
</pre>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="DU"></a>

                    <p><strong>Пример 12-16. du: Преобразование
                    текстового файла из формата DOS в формат
                    UNIX.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# du.sh: Преобразование текстового файла из формата DOS в формат UNIX.

E_WRONGARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` filename-to-convert&quot;
  exit $E_WRONGARGS
fi

NEWFILENAME=$1.unx

CR=&#39;\015&#39;  # Возврат каретки.
# Строки в текстовых файлах DOS завершаются комбинацией символов CR-LF.

tr -d $CR &lt; $1 &gt; $NEWFILENAME
# Удалить символы CR и записать в новый файл.

echo &quot;Исходный текстовый файл: \&quot;$1\&quot;.&quot;
echo &quot;Преобразованный файл: \&quot;$NEWFILENAME\&quot;.&quot;

exit 0
</pre>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="ROT13"></a>

                    <p><strong>Пример 12-17. rot13: Сверхслабое
                    шифрование по алгоритму rot13.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# rot13.sh: Классический алгоритм шифрования rot13,
#           который способен &quot;расколоть&quot; даже 3-х летний ребенок.

# Порядок использования: ./rot13.sh filename
# или                    ./rot13.sh &lt;filename
# или                    ./rot13.sh и ввести текст с клавиатуры (stdin)

cat &quot;$@&quot; | tr &#39;a-zA-Z&#39; &#39;n-za-mN-ZA-M&#39;   # &quot;a&quot; заменяется на &quot;n&quot;, &quot;b&quot; на &quot;o&quot;, и т.д.
#  Конструкция &#39;cat &quot;$@&quot;&#39;
#+ позволяет вводить данные как со stdin, так и из файла.

exit 0
</pre>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="CRYPTOQUOTE"></a>

                    <p><strong>Пример 12-18. Более <span
                     class="QUOTE">&quot;сложный&quot;</span>
                    шифр</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# crypto-quote.sh: Ограниченное шифрование

# Шифрование ограничивается простой заменой одних алфавитных символов другими.
#  Результат очень похож на шифры-загадки


key=ETAOINSHRDLUBCFGJMQPVWZYXK
# Здесь, &quot;key&quot; -- ни что иное, как &quot;перемешанный&quot; алфавит.
# Изменение ключа &quot;key&quot; приведет к изменению шифра.

# Конструкция &#39;cat &quot;$@&quot;&#39; позволяет вводить данные как со stdin, так и из файла.
# Если используется stdin, то ввод должен завершаться комбинацией Control-D.
# Иначе,  в командной строке, сценарию должно быть передано имя файла.

cat &quot;$@&quot; |  tr &quot;a-z&quot; &quot;A-Z&quot;   | tr &quot;A-Z&quot; &quot;$key&quot;
#        | в верхний регистр |    шифрование
# Такой прием позволяет шифровать как символы в верхнем регистре, так и в нижнем.
# Неалфавитные символы остаются без изменений.


# Попробуйте зашифровать какой либо текст, например
# &quot;Nothing so needs reforming as other people&#39;s habits.&quot;
# --Mark Twain
#
# Результат будет:
# &quot;CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI&#39;Q HETRPQ.&quot;
# --BEML PZERC

# Для дешифрации можно использовать следующую комбинацию:
# cat &quot;$@&quot; | tr &quot;$key&quot; &quot;A-Z&quot;


#  Этот нехитрый шифр может быть &quot;взломан&quot; 12-ти летним ребенком
#+ с помощью карандаша и бумаги.

exit 0
</pre>
                  </div>

                  <table
                   class="SIDEBAR"
                   border="1"
                   cellpadding="5">
                    <tr>
                      <td>
                        <div
                         class="SIDEBAR">
                          <a
                           name="AEN7548"></a>

                          <p><strong>Различные версии tr</strong></p>

                          <p>Утилита <strong
                           class="COMMAND">tr</strong> имеет две,
                          исторически сложившиеся, версии. BSD-версия
                          не использует квадратные скобки (<tt
                           class="USERINPUT"><strong>tr a-z
                          A-Z</strong></tt>), в то время как
                          SysV-версия использует их (<tt
                           class="USERINPUT"><strong>tr &#39;[a-z]&#39;
                          &#39;[A-Z]&#39;</strong></tt>). GNU-версия
                          утилиты <strong
                           class="COMMAND">tr</strong> напоминает
                          версию BSD, но диапазоны символов обязательно
                          должны заключаться в квадратные скобки.</p>
                        </div>
                      </td>
                    </tr>
                  </table>
                </dd>

                <dt><a
                 name="FOLDREF"></a><strong
                 class="COMMAND">fold</strong></dt>

                <dd>
                  <p>Выравнивает текст по ширине, разрывая, если это
                  необходимо, слова. Особый интерес представляет ключ
                  <tt
                   class="OPTION">-s</tt>, который производит перенос
                  строк по пробелам, стараясь не разрывать слова. (см.
                  <a
                   href="#EX50">Пример 12-19</a> и <a
                   href="#MAILFORMAT">Пример A-2</a>).</p>
                </dd>

                <dt><strong
                 class="COMMAND">fmt</strong></dt>

                <dd>
                  <p>Очень простая утилита форматирования текста, чаще
                  всего используемая как фильтр в конвейерах для того,
                  чтобы выполнить <span
                   class="QUOTE">&quot;перенос&quot;</span> длинных
                  строк текста.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX50"></a>

                    <p><strong>Пример 12-19. Отформатированный список
                    файлов.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

WIDTH=40                    # 40 символов в строке.

b=`ls /usr/local/bin`       # Получить список файлов...

echo $b | fmt -w $WIDTH

# То же самое можно выполнить командой
#  echo $b | fold - -s -w $WIDTH
 
exit 0
</pre>
                  </div>

                  <p>См. также <a
                   href="#EX41">Пример 12-4</a>.</p>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Очень мощной альтернативой утилите <strong
                           class="COMMAND">fmt</strong>, является
                          утилита <strong
                           class="COMMAND">par</strong> (автор Kamil
                          Toman), которую вы сможете найти на <a
                           href="http://www.cs.berkeley.edu/~amc/Par/"
                           target=
                          "_top">http://www.cs.berkeley.edu/~amc/Par/</a>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">col</strong></dt>

                <dd>
                  <p>Эта утилита с обманчивым названием удаляет из
                  входного потока символы обратной подачи бумаги (код
                  ESC 7). Она так же пытается заменить пробелы на
                  табуляции. Основная область применения утилиты
                  <strong
                   class="COMMAND">col</strong> -- фильтрация вывода
                  отдельных утилит обработки текста, таких как <strong
                   class="COMMAND">groff</strong> и <strong
                   class="COMMAND">tbl</strong>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">column</strong></dt>

                <dd>
                  <p>Форматирование по столбцам. Эта утилита
                  преобразует текст, например какой либо список, в
                  табличное, более <span
                   class="QUOTE">&quot;удобочитаемое&quot;</span>,
                  представление, вставляя символы табуляции по мере
                  необходимости.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="COL"></a>

                    <p><strong>Пример 12-20. Пример форматирования
                    списка файлов в каталоге</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# За основу сценария взят пример &quot;man column&quot;.


(printf &quot;PERMISSIONS LINKS OWNER GROUP SIZE DATE TIME PROG-NAME\n&quot; \
; ls -l | sed 1d) | column -t

#  Команда &quot;sed 1d&quot; удаляет первую строку, выводимую командой ls,
#+ (для локали &quot;С&quot; это строка:  &quot;total        N&quot;,
#+ где &quot;N&quot; -- общее количество файлов.

# Ключ -t, команды &quot;column&quot;, означает &quot;табличное&quot; представление.

exit 0
</pre>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">colrm</strong></dt>

                <dd>
                  <p>Утилита удаления колонок. Удаляет колонки
                  (столбцы) сиволов из файла и выводит результат на <tt
                   class="FILENAME">stdout</tt>. <tt
                   class="USERINPUT"><strong>colrm 2 4
                  &lt;filename</strong></tt> -- удалит символы со 2-го
                  по 4-й включительно, в каждой строке в файле <tt
                   class="FILENAME">filename</tt>.</p>

                  <div
                   class="WARNING">
                    <table
                     class="WARNING"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/warning.gif"
                         hspace="5"
                         alt="Warning"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Если файл содержит символы табуляции или
                          непечатаемые символы, то результат может
                          получиться самым неожиданным. В таких
                          случаях, как правило, утилиту <strong
                           class="COMMAND">colrm</strong>, в конвейере,
                          окружают командами <a
                           href="#EXPANDREF">expand</a> и <strong
                           class="COMMAND">unexpand</strong>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">nl</strong></dt>

                <dd>
                  <p>Нумерует строки в файле. <tt
                   class="USERINPUT"><strong>nl filename</strong></tt>
                  -- выведет файл <tt
                   class="FILENAME">filename</tt> на <tt
                   class="FILENAME">stdout</tt>, и в начале каждой
                  строки вставит ее порядковый номер, счет начинается с
                  первой непустой строки. Если файл не указывается, то
                  принимается ввод со <tt
                   class="FILENAME">stdin.</tt></p>

                  <p>Вывод команды <strong
                   class="COMMAND">nl</strong> очень напоминает <tt
                   class="USERINPUT"><strong>cat -n</strong></tt>,
                  однако, по-умолчанию <strong
                   class="COMMAND">nl</strong> не нумерует пустые
                  строки.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="LNUM"></a>

                    <p><strong>Пример 12-21. nl: Самонумерующийся
                    сценарий.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Сценарий выводит себя сам на stdout дважды, нумеруя строки сценария.

# &#39;nl&#39; вставит для этой строки номер 3, поскольку она не нумерует пустые строки.
# &#39;cat -n&#39; вставит для этой строки номер 5.

nl `basename $0`

echo; echo  # А теперь попробуем вывести текст сценария с помощью &#39;cat -n&#39;

cat -n `basename $0`
# Различия состоят в том, что &#39;cat -n&#39; нумерует все строки.
# Обратите внимание: &#39;nl -ba&#39; -- сделает то же самое.

exit 0
</pre>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">pr</strong></dt>

                <dd>
                  <p>Подготовка файла к печати. Утилита производит
                  разбивку файла на страницы, приводя его в вид
                  пригодный для печати или для вывода на экран.
                  Разнообразные ключи позволяют выполнять различные
                  манипуляции над строками и колонками, соединять
                  строки, устанавливать поля, нумеровать строки,
                  добавлять колонтитулы и многое, многое другое.
                  Утилита <strong
                   class="COMMAND">pr</strong> соединяет в себе
                  функциональность таких команд, как <strong
                   class="COMMAND">nl</strong>, <strong
                   class="COMMAND">paste</strong>, <strong
                   class="COMMAND">fold</strong>, <strong
                   class="COMMAND">column</strong> и <strong
                   class="COMMAND">expand</strong>.</p>

                  <p><tt
                   class="USERINPUT"><strong>pr -o 5 --width=65 fileZZZ
                  | more</strong></tt> -- выдаст хорошо оформленное и
                  разбитое на страницы содержимое файла <tt
                   class="FILENAME">fileZZZ</tt>.</p>

                  <p>Хочу особо отметить ключ <tt
                   class="OPTION">-d</tt>, который выводит строки с
                  двойным интервалом (тот же эффект, что и <strong
                   class="COMMAND">sed -G</strong>).</p>
                </dd>

                <dt><a
                 name="GETTEXTREF"></a><strong
                 class="COMMAND">gettext</strong></dt>

                <dd>
                  <p>GNU утилита, предназначена для нужд <a
                   href="#LOCALIZATION">локализации</a> и перевода
                  сообщений программ, выводимых на экран, на язык
                  пользователя. Не смотря на то, что это актуально,
                  прежде всего, для программ на языке C, тем не менее
                  <strong
                   class="COMMAND">gettext</strong> с успехом может
                  использоваться в сценариях командной оболочки для тех
                  же целей. См. <tt
                   class="REPLACEABLE"><em>info page</em></tt>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">iconv</strong></dt>

                <dd>
                  <p>Утилита преобразования текста из одной кодировки в
                  другую. В основном используется для нужд
                  локализации.</p>
                </dd>

                <dt><strong
                 class="COMMAND">recode</strong></dt>

                <dd>
                  <p>Может рассматриваться как разновилность утилиты
                  <strong
                   class="COMMAND">iconv</strong>, описанной выше.
                  Универсальная утилита для преобразования текстовой
                  информации в различные кодировки.</p>
                </dd>

                <dt><strong
                 class="COMMAND">TeX</strong>, <strong
                 class="COMMAND">gs</strong></dt>

                <dd>
                  <p><strong
                   class="COMMAND">TeX</strong> и <strong
                   class="COMMAND">Postscript</strong> -- языки
                  разметки текста, используемые для подготовки текста к
                  печати или выводу на экран.</p>

                  <p><strong
                   class="COMMAND">TeX</strong> -- это сложная система
                  подготовки к печати, разработанная Дональдом Кнутом
                  (Donald Knuth). Эту утилиту удобнее использовать
                  внутри сценария, чем в командной строке, поскольку в
                  сценарии проще один раз записать все необходимые
                  параметры, передаваемые утилите, для получения
                  необходимого результата.</p>

                  <p><span
                   class="emphasis"><em
                   class="EMPHASIS">Ghostscript</em></span> (<strong
                   class="COMMAND">gs</strong>) -- это GPL-версия
                  интерпретатора Postscript.</p>
                </dd>

                <dt><strong
                 class="COMMAND">groff</strong>, <strong
                 class="COMMAND">tbl</strong>, <strong
                 class="COMMAND">eqn</strong></dt>

                <dd>
                  <p><strong
                   class="COMMAND">groff</strong> -- это еще один язык
                  разметки текста и форматированного вывода. Является
                  расширенной GNU-версией пакета <strong
                   class="COMMAND">roff/troff</strong> в
                  UNIX-системах.</p>

                  <p><strong
                   class="COMMAND">tbl</strong> -- утилита обработки
                  таблиц, должна рассматриваться как составная часть
                  <strong
                   class="COMMAND">groff</strong>, так как ее задачей
                  является преобразование таблиц в команды <strong
                   class="COMMAND">groff</strong>.</p>

                  <p><strong
                   class="COMMAND">eqn</strong> -- утилита
                  преобразования математических выражений в команды
                  <strong
                   class="COMMAND">groff</strong>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">lex</strong>, <strong
                 class="COMMAND">yacc</strong></dt>

                <dd>
                  <p><strong
                   class="COMMAND">lex</strong> -- утилита лексического
                  разбора текста. В Linux-системах заменена на свободно
                  распространяемую утилиту <strong
                   class="COMMAND">flex</strong>.</p>

                  <p><strong
                   class="COMMAND">yacc</strong> -- утилита для
                  создания синтаксических анализаторов, на основе
                  набора грамматик, задаваемых разработчиком. В
                  Linux-системах, эта утилита заменена на свободно
                  распространяемую утилиту <strong
                   class="COMMAND">bison</strong>.</p>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="FILEARCHIV"></a>12.5. Команды для работы с файлами и
            архивами</h2>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="FAARCHIVING1"></a>Архивация</strong></p>

              <dl>
                <dt><a
                 name="TARREF"></a><strong
                 class="COMMAND">tar</strong></dt>

                <dd>
                  <p>Стандартная, для UNIX, утилита архивирования.
                  Первоначально -- это была программа <em
                   class="WORDASWORD">Tape ARchiving</em>, которая
                  впоследствии переросла в универсальный пакет, который
                  может работать с любыми типами устройств (см. <a
                   href="#EX58">Пример 3-4</a>). В GNU-версию tar была
                  добавлена возможность одновременно производить сжатие
                  tar-архива, например команда <strong
                   class="COMMAND">tar czvf archive_name.tar.gz
                  *</strong> создает tar-архив дерева подкаталогов и
                  вызывает <a
                   href="#GZIPREF">gzip</a> для выполнения сжатия,
                  исключение составляют <a
                   href="#DOTFILESREF">скрытые файлы</a> в текущем
                  каталоге (<strong
                   class="COMMAND">$PWD</strong>). <a
                   name="AEN7816"
                   href="#FTN.AEN7816"><span
                   class="footnote">[30]</span></a></p>

                  <p>Некоторые, часто используемые, ключи команды
                  <strong
                   class="COMMAND">tar</strong>:</p>

                  <ol
                   type="1">
                    <li>
                      <p><tt
                       class="OPTION">-c</tt> -- создать (create) новый
                      архив</p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-x</tt> -- извлечь (extract)
                      файлы из архива</p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">--delete</tt> -- удалить (delete)
                      файлы из архива</p>

                      <div
                       class="CAUTION">
                        <table
                         class="CAUTION"
                         width="90%"
                         border="0">
                          <tr>
                            <td
                             width="25"
                             align="center"
                             valign="top"><img
                             src="misc/abs-book/images/caution.gif"
                             hspace="5"
                             alt="Caution"></td>

                            <td
                             align="left"
                             valign="top">
                              <p>Этот ключ игнорируется для накопителей
                              на магнитной ленте.</p>
                            </td>
                          </tr>
                        </table>
                      </div>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-r</tt> -- добавить (append)
                      файлы в существующий архив</p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-A</tt> -- добавить (append)
                      <span
                       class="emphasis"><em
                       class="EMPHASIS">tar</em></span>-файлы в
                      существующий архив</p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-t</tt> -- список файлов в архиве
                      (содержимое архива)</p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-u</tt> -- обновить (update)
                      архив</p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-d</tt> -- операция сравнения
                      архива с заданной файловой системой</p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-z</tt> -- обработка архива с
                      помощью <a
                       href="#GZIPREF">gzip</a></p>

                      <p>(Сжатие или разжатие, в зависимости от
                      комбинации сопутствующих ключей <tt
                       class="OPTION">-c</tt> или <tt
                       class="OPTION">-x</tt>)</p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-j</tt> -- обработка архива с
                      помошью <a
                       href="#BZIPREF">bzip2</a></p>
                    </li>
                  </ol>
                  <br>
                  <br>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>При восстановлении &quot;битых&quot; <span
                           class="emphasis"><em
                           class="EMPHASIS">tar.gz</em></span> архивов
                          могут возникнуть определенные сложности,
                          поэтому делайте несколько резервных
                          копий.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">shar</strong></dt>

                <dd>
                  <p>Утилита создания shell-архива. Архивируемые файлы
                  объединяются в единый файл без выполнения сжатия, в
                  результате получается архив -- по сути полноценный
                  сценарий на языке командной оболочки, начинающийся со
                  строки <span
                   class="TOKEN">#!/bin/sh</span>, который содержит
                  полный набор команд, необходимый для
                  разархивирования. Такого рода архивы до сих пор можно
                  найти в некоторых телеконференциях в Internet, но в
                  последнее время они активно вытесняются связкой
                  <strong
                   class="COMMAND">tar</strong>/<strong
                   class="COMMAND">gzip</strong>. Для распаковки
                  shar-архивов предназначена команда <strong
                   class="COMMAND">unshar</strong>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">ar</strong></dt>

                <dd>
                  <p>Утилита создания и обслуживания архивов, главным
                  образом применяется к двоичным файлам библиотек.</p>
                </dd>

                <dt><a
                 name="RPMREF"></a><strong
                 class="COMMAND">rpm</strong></dt>

                <dd>
                  <p><span
                   class="emphasis"><em
                   class="EMPHASIS">Red Hat Package
                  Manager</em></span>, или <strong
                   class="COMMAND">rpm</strong> -- набор утилит,
                  предназначенных для построения и обслуживания пакетов
                  программного обеспечения как в исходном коде, так и в
                  собранном (откомпилированном) виде. Среди всего
                  прочего, включает в себя утилиты, производящие
                  установку ПО, проверку зависимостей пакетов и
                  проверку их целостности.</p>

                  <p>Самый простой вариант установки ПО из rpm --
                  выполнить команду <strong
                   class="COMMAND">rpm -i
                  package_name.rpm</strong>.</p>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Команда <tt
                           class="USERINPUT"><strong>rpm
                          -qa</strong></tt> выдаст полный список всех
                          установленных <span
                           class="emphasis"><em
                           class="EMPHASIS">rpm</em></span>-пакетов в
                          данной системе. Команда <tt
                           class="USERINPUT"><strong>rpm -qa
                          package_name</strong></tt> выведет только
                          пакет(ы) с именем, содержащим комбинацию
                          символов <tt
                           class="FILENAME">package_name</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>rpm -qa</strong></tt>
<tt
 class="COMPUTEROUTPUT">redhat-logos-1.1.3-1
 glibc-2.2.4-13
 cracklib-2.7-12
 dosfstools-2.7-1
 gdbm-1.8.0-10
 ksymoops-2.4.1-1
 mktemp-1.5-11
 perl-5.6.0-17
 reiserfs-utils-3.x.0j-2
 ...</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>rpm -qa docbook-utils</strong></tt>
<tt
 class="COMPUTEROUTPUT">docbook-utils-0.6.9-2</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>rpm -qa docbook | grep docbook</strong></tt>
<tt
 class="COMPUTEROUTPUT">docbook-dtd31-sgml-1.0-10
 docbook-style-dsssl-1.64-3
 docbook-dtd30-sgml-1.0-10
 docbook-dtd40-sgml-1.0-11
 docbook-utils-pdf-0.6.9-2
 docbook-dtd41-sgml-1.0-10
 docbook-utils-0.6.9-2</tt>
             
</pre>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">cpio</strong></dt>

                <dd>
                  <p>Специализированная утилита архивации и копирования
                  (<strong
                   class="COMMAND">c</strong>o<strong
                   class="COMMAND">p</strong>y <strong
                   class="COMMAND">i</strong>nput and <strong
                   class="COMMAND">o</strong>utput). Используется все
                  реже и реже, поскольку вытесняется более мощным
                  архиватором <strong
                   class="COMMAND">tar</strong>/<strong
                   class="COMMAND">gzip</strong>. Наиболее
                  употребительна для таких операций, как перемещение
                  дерева каталогов.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX48"></a>

                    <p><strong>Пример 12-22. Пример перемещения дерева
                    каталогов с помощью cpio</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Копирование дерева каталогов с помощью cpio.

ARGS=2
E_BADARGS=65

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` source destination&quot;
  exit $E_BADARGS
fi

source=$1
destination=$2

find &quot;$source&quot; -depth | cpio -admvp &quot;$destination&quot;
# Информацию по ключам утилиты cpio вы найдете в страницах руководства &quot;man cpio&quot;.

exit 0
</pre>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">rpm2cpio</strong></dt>

                <dd>
                  <p>Эта утилита конвертирует <a
                   href="#RPMREF">rpm</a>-пакет в архив <strong
                   class="COMMAND">cpio</strong>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="DERPM"></a>

                    <p><strong>Пример 12-23. Распаковка архива <span
                     class="emphasis"><em
                     class="EMPHASIS">rpm</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# de-rpm.sh: Распаковка архива &#39;rpm&#39;

: ${1?&quot;Порядок использования: `basename $0` target-file&quot;}
# Сценарию должно быть передано имя архива &#39;rpm&#39;.


TEMPFILE=$$.cpio                         # Временный файл с &quot;уникальным&quot; именем.
                                         # $$ -- PID процесса сценария.

rpm2cpio &lt; $1 &gt; $TEMPFILE                # Конверсия из rpm в cpio.
cpio --make-directories -F $TEMPFILE -i  # Рапсковка cpio-архива.
rm -f $TEMPFILE                          # Удаление cpio-архива.

exit 0

#  Упражнение:
#  Добавьте проверку на: 1) Существование &quot;target-file&quot;
#+                       2) Действительно ли &quot;target-file&quot; является rpm-архивом.
#  Подсказка:               используйте комсанду &#39;file&#39;.
</pre>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="FACOMPRESSION1"></a>Сжатие</strong></p>

              <dl>
                <dt><a
                 name="GZIPREF"></a><strong
                 class="COMMAND">gzip</strong></dt>

                <dd>
                  <p>Стандартная GNU/UNIX утилита сжатия, заменившая
                  более слабую, и к тому же проприетарную, утилиту
                  <strong
                   class="COMMAND">compress</strong>. Соответствующая
                  утилита декомпрессии (разжатия) -- <strong
                   class="COMMAND">gunzip</strong>, которая является
                  эквивалентом команды <strong
                   class="COMMAND">gzip -d</strong>.</p>

                  <p>Для работы со сжатыми файлами в конвейере
                  используется фильтр <strong
                   class="COMMAND">zcat</strong>, который выводит
                  результат своей работы на <tt
                   class="FILENAME">stdout</tt>, допускает
                  перенаправление вывода. Фактически это та же команда
                  <strong
                   class="COMMAND">cat</strong>, только приспособленная
                  для работы со сжатыми файлами (включая файлы, сжатые
                  утилитой <strong
                   class="COMMAND">compress</strong>). Эквивалент
                  команды <strong
                   class="COMMAND">zcat</strong> -- <strong
                   class="COMMAND">gzip -dc</strong>.</p>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>В некоторых коммерческих версиях UNIX,
                          команда <strong
                           class="COMMAND">zcat</strong> является
                          синонимом команды <strong
                           class="COMMAND">uncompress -c</strong>, и не
                          может работать с файлами, сжатыми с помощью
                          <span
                           class="emphasis"><em
                           class="EMPHASIS">gzip</em></span>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <p>См. также <a
                   href="#EX14">Пример 7-7</a>.</p>
                </dd>

                <dt><a
                 name="BZIPREF"></a><strong
                 class="COMMAND">bzip2</strong></dt>

                <dd>
                  <p>Альтернативная утилита сжатия, обычно дает более
                  высокую степень сжатия (но при этом работает
                  медленнее), чем <strong
                   class="COMMAND">gzip</strong>, особенно это
                  проявляется на больших файлах. Соответствующая
                  утилита декомпрессии -- <strong
                   class="COMMAND">bunzip2</strong>.</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>В современные версии <a
                           href="#TARREF">tar</a> добавлена поддержка
                          <strong
                           class="COMMAND">bzip2</strong>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">compress</strong>, <strong
                 class="COMMAND">uncompress</strong></dt>

                <dd>
                  <p>Устаревшие проприетарные утилиты для работы с
                  архивами, входящие в состав некоторых коммерческих
                  дистрибутивов UNIX. В последнее время вытесняются
                  более мощной утилитой <strong
                   class="COMMAND">gzip</strong>. Linux-дистрибутивы,
                  как правило, включают в свой состав эти утилиты для
                  обратной совместимости, однако <strong
                   class="COMMAND">gunzip</strong> корректно
                  разархивирует файлы, обработанные с помощью <strong
                   class="COMMAND">compress</strong>.</p>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Утилита <strong
                           class="COMMAND">znew</strong> предназначена
                          для преобразования <span
                           class="emphasis"><em
                           class=
                          "EMPHASIS">compress</em></span>-архивов в
                          <span
                           class="emphasis"><em
                           class=
                          "EMPHASIS">gzip</em></span>-архивы.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">sq</strong></dt>

                <dd>
                  <p>Еще одна утилита-фильтр сжатия, которая
                  обслуживает только отсортированные списки слов.
                  Использует стандартный, для фильтров, синтаксис
                  вызова -- <strong
                   class="COMMAND">sq &lt; input-file &gt;
                  output-file</strong>. Быстрая, но не такая
                  эффективная как <a
                   href="#GZIPREF">gzip</a>. Соответствующая ей утилита
                  декомпрессии называется <strong
                   class="COMMAND">unsq</strong>, синтаксис вызова
                  аналогичен утилите <strong
                   class="COMMAND">sq</strong>.</p>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Вывод от <strong
                           class="COMMAND">sq</strong> может быть
                          передан по конвейеру утилите <strong
                           class="COMMAND">gzip</strong>, для
                          дальнейшего сжатия.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">zip</strong>, <strong
                 class="COMMAND">unzip</strong></dt>

                <dd>
                  <p>Кроссплатформенная утилита архивирования и сжатия,
                  совместимая, по формату архивного файла, с утилитой
                  DOS -- <span
                   class="emphasis"><em
                   class="EMPHASIS">pkzip.exe</em></span>. <span
                   class="QUOTE">&quot;Zip&quot;</span>-архивы,
                  по-моему, более приемлемый вариант для обмена данными
                  через Internet, чем <span
                   class="QUOTE">&quot;tarballs&quot;</span> (тарболлы,
                  или tar-архивы).</p>
                </dd>

                <dt><strong
                 class="COMMAND">unarc</strong>, <strong
                 class="COMMAND">unarj</strong>, <strong
                 class="COMMAND">unrar</strong></dt>

                <dd>
                  <p>Этот набор утилит предназначен для распаковки
                  архивов, созданных с помощью DOS архиваторов -- <span
                   class="emphasis"><em
                   class="EMPHASIS">arc.exe</em></span>, <span
                   class="emphasis"><em
                   class="EMPHASIS">arj.exe</em></span> и <span
                   class="emphasis"><em
                   class="EMPHASIS">rar.exe</em></span>.</p>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="FAINFORMATION1"></a>Получение сведений о
              файлах</strong></p>

              <dl>
                <dt><a
                 name="FILEREF"></a><strong
                 class="COMMAND">file</strong></dt>

                <dd>
                  <p>Утилита идентификации файлов. Команда <tt
                   class="USERINPUT"><strong>file
                  file-name</strong></tt> верне тип файла <tt
                   class="FILENAME">file-name</tt>, например, <tt
                   class="COMPUTEROUTPUT">ascii text</tt> или <tt
                   class="COMPUTEROUTPUT">data</tt>. Для этого она
                  анализирует сигнатуру, или <a
                   href="#MAGNUMREF">магическое число</a> и
                  сопоставляет ее со списком известных сигнатур из <tt
                   class="FILENAME">/usr/share/magic</tt>, <tt
                   class="FILENAME">/etc/magic</tt> или <tt
                   class="FILENAME">/usr/lib/magic</tt> (в зависимости
                  от дистрибутива Linux/UNIX).</p>

                  <p><tt
                   class="OPTION">-f</tt> -- ключ пакетного режима
                  работы утилиты <strong
                   class="COMMAND">file</strong>, в этом случае утилита
                  принимает список анализируемых имен файлов из
                  заданного файла. Ключ <tt
                   class="OPTION">-z</tt> используется для анализа
                  файлов в архиве.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>file test.tar.gz</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">test.tar.gz: gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix</tt>

<tt
 class="PROMPT">bash</tt> <tt
 class="USERINPUT"><strong>file -z test.tar.gz</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">test.tar.gz: GNU tar archive (gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix)</tt>
             
</pre>
                  <br>
                  <br>

                  <div
                   class="EXAMPLE">
                    <a
                     name="STRIPC"></a>

                    <p><strong>Пример 12-24. Удаление комментариев из
                    файла с текстом программы на языке C</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# strip-comment.sh: Удаление комментариев (/* COMMENT */) из исходных текстов программ на языке C.

E_NOARGS=65
E_ARGERROR=66
E_WRONG_FILE_TYPE=67

if [ $# -eq &quot;$E_NOARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` C-program-file&quot; &gt;&amp;2 # Вывод сообщения на stderr.
  exit $E_ARGERROR
fi

# Проверка типа файла.
type=`eval file $1 | awk &#39;{ print $2, $3, $4, $5 }&#39;`
# &quot;file $1&quot; -- выводит тип файла...
# затем awk удаляет первое поле -- имя файла...
# после этого результат записывается в переменную &quot;type&quot;.
correct_type=&quot;ASCII C program text&quot;

if [ &quot;$type&quot; != &quot;$correct_type&quot; ]
then
  echo
  echo &quot;Этот сценарий работает только с исходными текстами программ на языке C.&quot;
  echo
  exit $E_WRONG_FILE_TYPE
fi


# Довольно замысловатый сценарий sed :
#--------
sed &#39;
/^\/\*/d
/.*\/\*/d
&#39; $1
#--------
# Если вы потратите несколько часов на изучение основ sed, то он станет немного понятнее.


#  Следовало бы добавить еще обработку
#+ комментариев, расположенных в одной строке с кодом.
#  Оставляю это вам, в качестве упражнения.

# Кроме того, этот сценарий удалит все строки, которые содержат комбинации символов &quot;*/&quot; или &quot;/*&quot;,
# не всегда желаемый результат.

exit 0


# ----------------------------------------------------------------
# Строки, расположенные ниже не будут исполнены из-за стоящей выше команды &#39;exit 0&#39;.

# Stephane Chazelas предложил другой, альтернативный вариант:

usage() {
  echo &quot;Порядок использования: `basename $0` C-program-file&quot; &gt;&amp;2
  exit 1
}

WEIRD=`echo -n -e &#39;\377&#39;`   # или WEIRD=$&#39;\377&#39;
[[ $# -eq 1 ]] || usage
case `file &quot;$1&quot;` in
  *&quot;C program text&quot;*) sed -e &quot;s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g&quot; &quot;$1&quot; \
     | tr &#39;\377\n&#39; &#39;\n\377&#39; \
     | sed -ne &#39;p;n&#39; \
     | tr -d &#39;\n&#39; | tr &#39;\377&#39; &#39;\n&#39;;;
  *) usage;;
esac

# Этот вариант, все еще некорректно обрабатывает такие строки как:
# printf(&quot;/*&quot;);
# или
# /*  /* ошибочный вложенный комментарий */
#
# Для обработки специальных случаев (\&quot;, \\&quot; ...) придется написать синтаксический анализатор
# (может быть с помощью lex или yacc?).

exit 0
</pre>
                  </div>
                </dd>

                <dt><a
                 name="WHICHREF"></a><strong
                 class="COMMAND">which</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">which command-xxx</strong> вернет
                  полный путь к <span
                   class="QUOTE">&quot;command-xxx&quot;</span>. Очень
                  полезна для того, чтобы узнать -- установлена ли та
                  или иная утилита в системе.</p>

                  <p><tt
                   class="USERINPUT"><strong>$bash which
                  rm</strong></tt></p>
<pre
 class="SCREEN">
<tt
 class="COMPUTEROUTPUT">/usr/bin/rm</tt>
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">whereis</strong></dt>

                <dd>
                  <p>Очень похожа на <strong
                   class="COMMAND">which</strong>, упоминавшуюся выше.
                  Команда <strong
                   class="COMMAND">whereis command-xxx</strong> вернет
                  полный путь к <span
                   class="QUOTE">&quot;command-xxx&quot;</span>, но
                  кроме того, еще и путь к <span
                   class="emphasis"><em
                   class="EMPHASIS">manpage</em></span> -- файлу,
                  странице справочника по заданной утилите.</p>

                  <p><tt
                   class="USERINPUT"><strong>$bash whereis
                  rm</strong></tt></p>
<pre
 class="SCREEN">
<tt
 class="COMPUTEROUTPUT">rm: /bin/rm /usr/share/man/man1/rm.1.bz2</tt>
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="WHATISREF"></a><strong
                 class="COMMAND">whatis</strong></dt>

                <dd>
                  <p>Утилита <strong
                   class="COMMAND">whatis filexxx</strong> отыщет <span
                   class="QUOTE">&quot;filexxx&quot;</span> в своей
                  базе данных. Может рассматриваться как упрощенный
                  вариант команды <strong
                   class="COMMAND">man</strong>.</p>

                  <p><tt
                   class="USERINPUT"><strong>$bash whatis
                  whatis</strong></tt></p>
<pre
 class="SCREEN">
<tt
 class=
"COMPUTEROUTPUT">whatis               (1)  - search the whatis database for complete words</tt>
</pre>
                  <br>
                  <br>

                  <div
                   class="EXAMPLE">
                    <a
                     name="WHAT"></a>

                    <p><strong>Пример 12-25. Исследование каталога <tt
                     class="FILENAME">/usr/X11R6/bin</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Что находится в каталоге /usr/X11R6/bin?

DIRECTORY=&quot;/usr/X11R6/bin&quot;
# Попробуйте также &quot;/bin&quot;, &quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;, и т.д.

for file in $DIRECTORY/*
do
  whatis `basename $file`   # Вывод информации о файле.
done

exit 0
# Вывод этого сценария можно перенаправить в файл:
# ./what.sh &gt;&gt;whatis.db
# или включить постраничный просмотр на экране,
# ./what.sh | less
</pre>
                  </div>

                  <p>См. также <a
                   href="#FILEINFO">Пример 10-3</a>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">vdir</strong></dt>

                <dd>
                  <p>Вывод списка файлов в каталоге. Тот же эффект
                  имеет команда <a
                   href="#LSREF">ls -l</a>.</p>

                  <p>Это одна из утилит GNU <span
                   class="emphasis"><em
                   class="EMPHASIS">fileutils</em></span>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>vdir</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</tt>

<tt
 class="PROMPT">bash</tt> <tt
 class="USERINPUT"><strong>ls -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">locate</strong>, <strong
                 class="COMMAND">slocate</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">locate</strong> определяет
                  местонахождение файла, используя свою базу данных,
                  создаваемую специально для этих целей. Команда
                  <strong
                   class="COMMAND">slocate</strong> -- это защищенная
                  версия <strong
                   class="COMMAND">locate</strong> (которая может
                  оказаться простым псевдонимом команды <strong
                   class="COMMAND">slocate</strong>).</p>

                  <p><tt
                   class="USERINPUT"><strong>$bash locate
                  hickson</strong></tt></p>
<pre
 class="SCREEN">
<tt
 class="COMPUTEROUTPUT">/usr/lib/xephem/catalogs/hickson.edb</tt>
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">readlink</strong></dt>

                <dd>
                  <p>Возвращает имя файла, на который указывает
                  символическая ссылка.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>readlink /usr/bin/awk</strong></tt>
<tt
 class="COMPUTEROUTPUT">../../bin/gawk</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">strings</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">strings</strong> используется для
                  поиска печатаемых строк в двоичных файлах. Она
                  выводит последовательности печатаемых символов,
                  обнаруженных в заданном файле. Может использоваться
                  для прикидочного анализа дамп-файлов (core dump) или
                  для отыскания информации о типе файла, например для
                  графических файлов неизвестного формата (например,
                  <tt
                   class="USERINPUT"><strong>strings image-file |
                  more</strong></tt> может вывести такую строчку: <tt
                   class="COMPUTEROUTPUT">JFIF</tt>, что говорит о том,
                  что мы имеем дело с графическим файлом в формате
                  <span
                   class="emphasis"><em
                   class="EMPHASIS">jpeg</em></span>). В сценариях,
                  вероятнее всего, вам придется использовать эту
                  команду в связке с <a
                   href="#GREPREF">grep</a> или <a
                   href="#SEDREF">sed</a>. См. <a
                   href="#BINGREP">Пример 10-7</a> и <a
                   href="#FINDSTRING">Пример 10-9</a>.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="WSTRINGS"></a>

                    <p><strong>Пример 12-26. <span
                     class="QUOTE">&quot;Расширенная&quot;</span>
                    команда <span
                     class="emphasis"><em
                     class="EMPHASIS">strings</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# wstrings.sh: &quot;word-strings&quot; (расширенная команда &quot;strings&quot;)
#
#  Этот сценарий фильтрует вывод команды &quot;strings&quot; путем проверки на соответствие
#+ выводимых слов по файлу словаря.
#  Таким способом эффективно &quot;отсекается&quot; весь &quot;мусор&quot;,
#+ и выводятся только распознанные слова.

# =================================================================
#                 Стандартная проверка входных аргументов
ARGS=1
E_BADARGS=65
E_NOFILE=66

if [ $# -ne $ARGS ]
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

if [ ! -f &quot;$1&quot; ]                      # Проверка наличия файла.
then
    echo &quot;Файл \&quot;$1\&quot; не найден.&quot;
    exit $E_NOFILE
fi
# =================================================================


MINSTRLEN=3                           #  Минимальная длина строки.
WORDFILE=/usr/share/dict/linux.words  #  Файл словаря.
                                      #  Можно указать иной
                                      #+ файл словаря
                                      #+ в формате -- &quot;одно слово на строке&quot;.


wlist=`strings &quot;$1&quot; | tr A-Z a-z | tr &#39;[:space:]&#39; Z | \
tr -cs &#39;[:alpha:]&#39; Z | tr -s &#39;\173-\377&#39; Z | tr Z &#39; &#39;`

# Трансляция вывода от &#39;strings&#39; с помощью нескольких &#39;tr&#39;.
#  &quot;tr A-Z a-z&quot;  -- перевод в нижний регистр.
#  &quot;tr &#39;[:space:]&#39;&quot;  -- конвертирует пробелы в символы Z.
#  &quot;tr -cs &#39;[:alpha:]&#39; Z&quot;  -- конвертирует неалфавитные символы в символы Z,
#+ и удаляет повторяющиеся символы Z.
#  &quot;tr -s &#39;\173-\377&#39; Z&quot;  -- Конвертирует все символы, с кодами выше &#39;z&#39; в Z
#+ и удаляет повторяющиеся символы Z,
#+ эта команда удалит все символы, которые не были распознаны предыдущими
#+ командами трансляции (tr).
#  Наконец, &quot;tr Z &#39; &#39;&quot; -- преобразует все символы Z в пробелы,
#+ которые будут рассматриваться в качестве разделителя слов в цикле, приведенном ниже.

#  Обратите внимание на технику многоуровневой обработки с помощью &#39;tr&#39;,
#+ каждый раз эта команда вызывается с различным набором аргументов.


for word in $wlist                    # Важно:
                                      # переменная $wlist не должна заключаться в кавычки.
                                      # &quot;$wlist&quot; -- не сработает.
                                      # Почему?
do

  strlen=${#word}                     # Дина строки.
  if [ &quot;$strlen&quot; -lt &quot;$MINSTRLEN&quot; ]   # Не рассматривать короткие строки.
  then
    continue
  fi

  grep -Fw $word &quot;$WORDFILE&quot;          # Проверка слова по словарю.

done


exit 0
</pre>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="COMPARISONN1"></a>Сравнение</strong></p>

              <dl>
                <dt><a
                 name="DIFFREF"></a><strong
                 class="COMMAND">diff</strong>, <strong
                 class="COMMAND">patch</strong></dt>

                <dd>
                  <p><strong
                   class="COMMAND">diff</strong>: очень гибкая утилита
                  сравнения файлов. Она выполняет построчное сравнение
                  файлов. В отдельных случаях, таких как поиск по
                  словарю, может оказаться полезной фильтрация файлов с
                  помощью <a
                   href="#SORTREF">sort</a> и <strong
                   class="COMMAND">uniq</strong> перед тем как отдать
                  поток данных через конвейер утилите <strong
                   class="COMMAND">diff</strong>. <tt
                   class="USERINPUT"><strong>diff file-1
                  file-2</strong></tt> -- выведет строки, имеющие
                  отличия, указывая -- какому файлу, какая строка
                  принадлежит.</p>

                  <p>С ключом <tt
                   class="OPTION">--side-by-side</tt>, команда <strong
                   class="COMMAND">diff</strong> выведет сравниваемые
                  файлы в две колонки, с указанием несовпадающих строк.
                  Ключи <tt
                   class="OPTION">-c</tt> и <tt
                   class="OPTION">-u</tt> так же служат для облегчения
                  интерпретации результатов работы <strong
                   class="COMMAND">diff</strong>.</p>

                  <p>Существует ряд интерфейсных оболочек для утилиты
                  <strong
                   class="COMMAND">diff</strong>, среди них можно
                  назвать: <strong
                   class="COMMAND">spiff</strong>, <strong
                   class="COMMAND">wdiff</strong>, <strong
                   class="COMMAND">xdiff</strong> и <strong
                   class="COMMAND">mgdiff</strong>.</p>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Команда <strong
                           class="COMMAND">diff</strong> возвращает код
                          завершения 0, если сравниваемые файлы
                          идентичны и 1, если они отличаются. Это
                          позволяет использовать <strong
                           class="COMMAND">diff</strong> в условных
                          операторах внутри сценариев на языке
                          командной оболочки (см. ниже).</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <p>В общем случае, <strong
                   class="COMMAND">diff</strong> используется для
                  генерации файла различий, который используется как
                  аргумент команды <strong
                   class="COMMAND">patch</strong>. Ключ <tt
                   class="OPTION">-e</tt> отвечает за вывод файла
                  различий в формате, пригодном для использования с
                  <strong
                   class="COMMAND">ed</strong> или <strong
                   class="COMMAND">ex</strong>.</p>

                  <p><strong
                   class="COMMAND">patch</strong>: гибкая утилита для
                  &quot;наложения заплат&quot;. С помощью файла
                  различий, сгенерированного утилитой <strong
                   class="COMMAND">diff</strong>, утилита <strong
                   class="COMMAND">patch</strong> может использоваться
                  для обновления устаревших версий файлов. Это
                  позволяет распространять относительно небольшие <span
                   class="QUOTE">&quot;diff&quot;</span>-файлы вместо
                  целых пакетов. Распространение <span
                   class="QUOTE">&quot;заплат&quot;</span> к ядру стало
                  наиболее предпочтительным методом распространения
                  более новых версий ядра Linux.</p>
<pre
 class="PROGRAMLISTING">
patch -p1 &lt;patch-file
# Применит все изменения из &#39;patch-file&#39;
# к файлам, описанным там же.
# Так выполняется обновление пакетов до более высоких версий.
</pre>
                  <br>
                  <br>

                  <p>Наложение &quot;заплат&quot; на ядро:</p>
<pre
 class="PROGRAMLISTING">
cd /usr/src
gzip -cd patchXX.gz | patch -p0
# Обновление исходных текстов ядра с помощью &#39;patch&#39;.
# Пример взят из файла &quot;README&quot;,
# автор не известен (Alan Cox?).
</pre>
                  <br>
                  <br>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Кроме того, утилита <strong
                           class="COMMAND">diff</strong> в состоянии
                          выполнять рекурсивный обход каталогов.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>diff -r ~/notes1 ~/notes2</strong></tt>
<tt
 class="COMPUTEROUTPUT">Only in /home/bozo/notes1: file02
 Only in /home/bozo/notes1: file03
 Only in /home/bozo/notes2: file04</tt>
             
</pre>
                          <br>
                          <br>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Утилита <strong
                           class="COMMAND">zdiff</strong> сравнивает
                          сжатые, с помощью <span
                           class="emphasis"><em
                           class="EMPHASIS">gzip</em></span>,
                          файлы.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">diff3</strong></dt>

                <dd>
                  <p>Расширенная версия <strong
                   class="COMMAND">diff</strong>, которая сравнивает
                  сразу 3 файла. В случае успеха возвращает 0, но, к
                  сожалению, не дает никакой информации о результатах
                  сравнения.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>diff3 file-1 file-2 file-3</strong></tt>
<tt
 class="COMPUTEROUTPUT">====
 1:1c
   This is line 1 of &quot;file-1&quot;.
 2:1c
   This is line 1 of &quot;file-2&quot;.
 3:1c
   This is line 1 of &quot;file-3&quot;</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">sdiff</strong></dt>

                <dd>
                  <p>Сравнение и/или редактирование двух файлов перед
                  объединением их в один файл. Это интерактивная
                  утилита, по своей природе, и из-за этого она довольно
                  редко используется в сценариях.</p>
                </dd>

                <dt><strong
                 class="COMMAND">cmp</strong></dt>

                <dd>
                  <p>Утилита <strong
                   class="COMMAND">cmp</strong> -- это упрощенная
                  версия <strong
                   class="COMMAND">diff</strong>. В то время, как
                  <strong
                   class="COMMAND">diff</strong> выводит подробную
                  информацию об имеющихся различиях, утилита <strong
                   class="COMMAND">cmp</strong> лишь показывет номер
                  строки и позицию в строке, где было встречено
                  различие.</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Подобно команде <strong
                           class="COMMAND">diff</strong>, команда
                          <strong
                           class="COMMAND">cmp</strong> возвращает код
                          завершения 0, если файлы идентичны и 1, если
                          они различны. Это позволяет использовать
                          команду <strong
                           class="COMMAND">cmp</strong> в условных
                          операторах.</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="FILECOMP"></a>

                    <p><strong>Пример 12-27. Пример сравнения двух
                    файлов с помощью cmp.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

ARGS=2  # Ожидаются два аргумента командной строки.
E_BADARGS=65
E_UNREADABLE=66

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` file1 file2&quot;
  exit $E_BADARGS
fi

if [[ ! -r &quot;$1&quot; || ! -r &quot;$2&quot; ]]
then
  echo &quot;Оба файла должны существовать и должны быть доступны для чтения.&quot;
  exit $E_UNREADABLE
fi

cmp $1 $2 &amp;&gt; /dev/null  # /dev/null -- &quot;похоронит&quot; вывод от команды &quot;cmp&quot;.
#   cmp -s $1 $2  даст тот же результат (&quot;-s&quot; -- флаг &quot;тишины&quot; для &quot;cmp&quot;)
#   Спасибо Anders Gustavsson за замечание.
#
# Также применимо к &#39;diff&#39;, т.е.,   diff $1 $2 &amp;&gt; /dev/null

if [ $? -eq 0 ]         # Проверка кода возврата команды &quot;cmp&quot;.
then
  echo &quot;Файл \&quot;$1\&quot; идентичен файлу \&quot;$2\&quot;.&quot;
else
  echo &quot;Файл \&quot;$1\&quot; отличается от файла \&quot;$2\&quot;.&quot;
fi

exit 0
</pre>
                  </div>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Для работы с <span
                           class="emphasis"><em
                           class="EMPHASIS">gzip</em></span> файлами
                          используется утилита <strong
                           class="COMMAND">zcmp</strong>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">comm</strong></dt>

                <dd>
                  <p>Универсальная утилита сравнения. Работает с
                  отсортированными файлами.</p>

                  <p><strong
                   class="COMMAND">comm <tt
                   class="REPLACEABLE"><em>-options</em></tt> <tt
                   class="REPLACEABLE"><em>first-file</em></tt> <tt
                   class=
                  "REPLACEABLE"><em>second-file</em></tt></strong></p>

                  <p><tt
                   class="USERINPUT"><strong>comm file-1
                  file-2</strong></tt> -- вывод в три колонки:</p>

                  <ul>
                    <li>
                      <p>колонка 1 = уникальные строки для <tt
                       class="FILENAME">file-1</tt></p>
                    </li>

                    <li>
                      <p>колонка 2 = уникальные строки для <tt
                       class="FILENAME">file-2</tt></p>
                    </li>

                    <li>
                      <p>колонка 3 = одинаковые строки.</p>
                    </li>
                  </ul>
                  <br>
                  <br>

                  <p>Ключи, подавляющие вывод в одной или более
                  колонках.</p>

                  <ul>
                    <li>
                      <p><tt
                       class="OPTION">-1</tt> -- подавление вывода в
                      колонку <tt
                       class="LITERAL">1</tt></p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-2</tt> -- подавление вывода в
                      колонку <tt
                       class="LITERAL">2</tt></p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-3</tt> -- подавление вывода в
                      колонку <tt
                       class="LITERAL">3</tt></p>
                    </li>

                    <li>
                      <p><tt
                       class="OPTION">-12</tt> -- подавление вывода в
                      колонки <tt
                       class="LITERAL">1</tt> и <tt
                       class="LITERAL">2</tt>, и т.д.</p>
                    </li>
                  </ul>
                  <br>
                  <br>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="FAUTILS1"></a>Утилиты</strong></p>

              <dl>
                <dt><strong
                 class="COMMAND">basename</strong></dt>

                <dd>
                  <p>Выводит только название файла, без каталога
                  размещения. Конструкция <tt
                   class="USERINPUT"><strong>basename $0</strong></tt>
                  -- позволяет сценарию узнать свое имя, то есть имя
                  файла, который был запущен. Это имя может быть
                  использовано для вывода сообщений, напрмиер:</p>
<pre
 class="PROGRAMLISTING">
echo &quot;Порядок использования: `basename $0` arg1 arg2 ... argn&quot;
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">dirname</strong></dt>

                <dd>
                  <p>Отсекает <strong
                   class="COMMAND">basename</strong> от полного имени
                  файла и выводит только путь к файлу.</p>

                  <div
                   class="NOTE">
                    <table
                     class="NOTE"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/note.gif"
                         hspace="5"
                         alt="Note"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Утилитам <strong
                           class="COMMAND">basename</strong> и <strong
                           class="COMMAND">dirname</strong> может быть
                          передана любая строка, в качестве аргумента.
                          Этот аргумент необязательно должен быть
                          именем существующего файла (см. <a
                           href="#DAYSBETWEEN">Пример A-8</a>).</p>
                        </td>
                      </tr>
                    </table>
                  </div>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX35"></a>

                    <p><strong>Пример 12-28. Утилиты basename и
                    dirname</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

a=/home/bozo/daily-journal.txt

echo &quot;Basename для /home/bozo/daily-journal.txt = `basename $a`&quot;
echo &quot;Dirname для /home/bozo/daily-journal.txt = `dirname $a`&quot;
echo
echo &quot;Мой домашний каталог `basename ~/`.&quot;             # Можно указать просто ~.
echo &quot;Каталог моего домашнего каталога `dirname ~/`.&quot;  # Можно указать просто ~.

exit 0
</pre>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">split</strong></dt>

                <dd>
                  <p>Утилита разбивает файл на несколько частей. Обычно
                  используется для разбиения больших файлов, чтобы их
                  можно было записать на дискеты или передать по
                  электронной почте по частям.</p>
                </dd>

                <dt><strong
                 class="COMMAND">sum</strong>, <strong
                 class="COMMAND">cksum</strong>, <a
                 name="MD5SUMREF"></a><strong
                 class="COMMAND">md5sum</strong></dt>

                <dd>
                  <p>Эти утилиты предназначены для вычисления
                  контрольных сумм. Контрольная сумма -- это некоторое
                  число, вычисляемое исходя из содержимого файла, и
                  служит для контроля целостности информации в файле.
                  Сценарий может выполнять проверку контрольных сумм
                  для того, чтобы убедиться, что файл не был изменен
                  или поврежден. Для большей безопасности,
                  рекомендуется использовать 128-битную сумму,
                  генерируемую утилитой <strong
                   class="COMMAND">md5sum</strong> (<strong
                   class="COMMAND">m</strong>essage <strong
                   class="COMMAND">d</strong>igest check<strong
                   class="COMMAND">sum</strong>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cksum /boot/vmlinuz</strong></tt>
<tt
 class="COMPUTEROUTPUT">1670054224 804083 /boot/vmlinuz</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>md5sum /boot/vmlinuz</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz</tt>
             
</pre>
                  <br>
                  <br>

                  <p>Обратите внимание: утилита <strong
                   class="COMMAND">cksum</strong> выводит контрольную
                  сумму и размер файла в байтах.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="FILEINTEGRITY"></a>

                    <p><strong>Пример 12-29. Проверка целостности
                    файла</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# file-integrity.sh: Проверка целостности файлов в заданном каталоге

E_DIR_NOMATCH=70
E_BAD_DBFILE=71

dbfile=File_record.md5
# Файл для хранения контрольных сумм.


set_up_database ()
{
  echo &quot;&quot;$directory&quot;&quot; &gt; &quot;$dbfile&quot;
  # Записать название каталога в первую строку файла.
  md5sum &quot;$directory&quot;/* &gt;&gt; &quot;$dbfile&quot;
  # Записать контрольные суммы md5 и имена файлов.
}

check_database ()
{
  local n=0
  local filename
  local checksum

  # ------------------------------------------- #
  #  Возможно эта проверка и не нужна,
  #+ но лучше перестраховаться сейчас, чем жалеть об этом потом.

  if [ ! -r &quot;$dbfile&quot; ]
  then
    echo &quot;Не могу прочитать файл с контрольными суммами!&quot;
    exit $E_BAD_DBFILE
  fi
  # ------------------------------------------- #

  while read record[n]
  do

    directory_checked=&quot;${record[0]}&quot;
    if [ &quot;$directory_checked&quot; != &quot;$directory&quot; ]
    then
      echo &quot;Имя каталога не совпадает с записаным в файле!&quot;
      # Попытка использовать файл контрольных сумм для другого каталога.
      exit $E_DIR_NOMATCH
    fi

    if [ &quot;$n&quot; -gt 0 ]   # Не имя каталога.
    then
      filename[n]=$( echo ${record[$n]} | awk &#39;{ print $2 }&#39; )
      #  md5sum записывает в обратном порядке,
      #+ сначала контрольную сумму, затем имя файла.
      checksum[n]=$( md5sum &quot;${filename[n]}&quot; )

      if [ &quot;${record[n]}&quot; = &quot;${checksum[n]}&quot; ]
      then
        echo &quot;Файл ${filename[n]} не был изменен.&quot;
      else
        echo &quot;ОШИБКА КОНТРОЛЬНОЙ СУММЫ для файла ${filename[n]}!&quot;
        # Файл был изменен со времени последней проверки.
      fi

    fi


    let &quot;n+=1&quot;
  done &lt;&quot;$dbfile&quot;       # Чтение контрольных сумм из файла.

}

# =================================================== #
# main ()

if [ -z  &quot;$1&quot; ]
then
  directory=&quot;$PWD&quot;      #  Если каталог не задан,
else                    #+ то используется текущий каталог.
  directory=&quot;$1&quot;
fi

clear                   # Очистка экрана.

# ------------------------------------------------------------------ #
  if [ ! -r &quot;$dbfile&quot; ] # Необходимо создать файл с контрольными суммами?
  then
    echo &quot;Создание файла с контрольными суммами, \&quot;&quot;$directory&quot;/&quot;$dbfile&quot;\&quot;.&quot;; echo
    set_up_database
  fi
# ------------------------------------------------------------------ #

check_database          # Выполнить проверку.

echo

#  Вывод этого сценария можно перенаправить в файл,
#+ это особенно полезно при проверке большого количества файлов.

#  Более строгая проверка целостности файлов,
#+ может быть выполнена с помощью пакета &quot;Tripwire&quot;,
#+ http://sourceforge.net/projects/tripwire/.

exit 0
</pre>
                  </div>

                  <p>Более творческий подход к использованию <strong
                   class="COMMAND">md5sum</strong> вы нйдете в <a
                   href="#DIRECTORYINFO">Пример A-21</a>.</p>
                </dd>

                <dt><a
                 name="SHREDREF"></a><strong
                 class="COMMAND">shred</strong></dt>

                <dd>
                  <p>Надежное, с точки зрения безопасности, стирание
                  файла, посредством предварительной, многократной
                  записи в файл случайной информации, перед тем как
                  удалить его. Эта команда имеет тот же эффект, что и
                  <a
                   href="#BLOTOUT">Пример 12-42</a>, но делает это
                  более изящным и безопасным способом.</p>

                  <p>Является составной частью пакета GNU <span
                   class="emphasis"><em
                   class="EMPHASIS">fileutils</em></span>.</p>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Имеется ряд технологий, с помощью которых
                          все-таки возможно восстановить файлы,
                          удаленные утилитой <strong
                           class="COMMAND">shred</strong>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="FAENCENCR1"></a>Кодирование и
              шифрование</strong></p>

              <dl>
                <dt><strong
                 class="COMMAND">uuencode</strong></dt>

                <dd>
                  <p>Эта утилита используется для кодирования двоичных
                  файлов в символы ASCII, после такого кодирования
                  файлы могут, с достаточной степенью безопасности,
                  передаваться по сети, вкладываться в электронные
                  письма и т.п..</p>
                </dd>

                <dt><strong
                 class="COMMAND">uudecode</strong></dt>

                <dd>
                  <p>Утилита декодирования файлов, прошедших обработку
                  утилитой uuencode.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="EX52"></a>

                    <p><strong>Пример 12-30. Декодирование
                    файлов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

lines=35        # 35 строк для заголовка (более чем достаточно).

for File in *   # Обход всех файлов в текущем каталоге...
do
  search1=`head -$lines $File | grep begin | wc -w`
  search2=`tail -$lines $File | grep end | wc -w`
  #  Закодированные файлы начинаются со слова &quot;begin&quot;,
  #+ и заканчиваются словом &quot;end&quot;.
  if [ &quot;$search1&quot; -gt 0 ]
  then
    if [ &quot;$search2&quot; -gt 0 ]
    then
      echo &quot;декодируется файл - $File -&quot;
      uudecode $File
    fi
  fi
done

#  Обратите внимание: если передать сценарию самого себя, для декодирования,
#+ то это введет его в заблуждение
#+ поскольку в тексте сценария встречаются слова &quot;begin&quot; и &quot;end&quot;.

exit 0
</pre>
                  </div>

                  <div
                   class="TIP">
                    <table
                     class="TIP"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/tip.gif"
                         hspace="5"
                         alt="Tip"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>При декодировании и выводе длинных
                          текстовых сообщений из новостных групп
                          Usenet, очень нелишним будет передать текст,
                          по конвейеру, команде <a
                           href="#FOLDREF">fold -s</a>.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">mimencode</strong>, <strong
                 class="COMMAND">mmencode</strong></dt>

                <dd>
                  <p>Утилиты <strong
                   class="COMMAND">mimencode</strong> и <strong
                   class="COMMAND">mmencode</strong> предназначены для
                  обработки закодированных мультимедийных вложений в
                  электронные письма. Хотя <span
                   class="emphasis"><em
                   class="EMPHASIS">почтовые программы</em></span>
                  (такие как <strong
                   class="COMMAND">pine</strong> или <strong
                   class="COMMAND">kmail</strong>) имеют возможность
                  автоматической обработки таких вложений, тем не менее
                  эти утилиты позволяют обрабатывать вложения вручную,
                  из командной строки или в пакетном режиме, из
                  сценария на языке командной оболочки.</p>
                </dd>

                <dt><strong
                 class="COMMAND">crypt</strong></dt>

                <dd>
                  <p>Одно время, это была стандартная, для UNIX,
                  утилита шифрования файлов. <a
                   name="AEN8616"
                   href="#FTN.AEN8616"><span
                   class="footnote">[31]</span></a> Политически
                  мотивированные, правительственные постановления ряда
                  стран, напрямую запрещают экспорт программного
                  обеспечения для шифрования, что, в результате,
                  привело практически к полному исчезновению <strong
                   class="COMMAND">crypt</strong> из большинства
                  UNIX-систем (в том числе и Linux). К счастью,
                  программистами было разработано множество вполне
                  приличных альтернатив, и среди них <a
                   href=
                  "ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz"
                   target="_top">cruft</a> (см. <a
                   href="#ENCRYPTEDPW">Пример A-5</a>).</p>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="FAMISC1"></a>Прочее</strong></p>

              <dl>
                <dt><a
                 name="MKTEMPREF"></a><strong
                 class="COMMAND">mktemp</strong></dt>

                <dd>
                  <p>Создает временный файл с <span
                   class="QUOTE">&quot;уникальным&quot;</span>
                  именем.</p>
<pre
 class="PROGRAMLISTING">
PREFIX=filename
tempfile=`mktemp $PREFIX.XXXXXX`
#                        ^^^^^^ Необходимо по меньшей мере 6 заполнителей
echo &quot;имя временного файла = $tempfile&quot;
# имя временного файла = filename.QA2ZpY
#                 или нечто подобное...
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">make</strong></dt>

                <dd>
                  <p>Утилита для компиляции и сборки программ. Но может
                  использоваться для выполнения любых других операций,
                  основанных на анализе наличия изменений в исходных
                  файлах.</p>

                  <p><a
                   name="MAKEFILEREF"></a></p>

                  <p>Команда <strong
                   class="COMMAND">make</strong> использует в своей
                  работе <tt
                   class="FILENAME">Makefile</tt>, который содержит
                  перечень зависимостей и операций, которые необходимо
                  выполнить для удовлетворения этих зависимостей.</p>
                </dd>

                <dt><strong
                 class="COMMAND">install</strong></dt>

                <dd>
                  <p>Своего рода -- утилита копирования файлов, похожа
                  на <strong
                   class="COMMAND">cp</strong>, но дополнительно
                  позволяет изменять права доступа и атрибуты
                  копируемых файлов. Напрямую эта команда практически
                  не используется, чаще всего она встречается в <tt
                   class="FILENAME">Makefile</tt> (в разделе <tt
                   class="REPLACEABLE"><em>make install :</em></tt>).
                  Она может использоваться в сценариях установки
                  ПО.</p>
                </dd>

                <dt><strong
                 class="COMMAND">dos2unix</strong></dt>

                <dd>
                  <p>Автор утилиты -- Benjamin Lin со-товарищи.
                  Предназначена для преобразования текстовых файлов из
                  формата DOS (в котором строки завершаются комбинацией
                  символов CR-LF) в формат UNIX (в котором строки
                  завершаются одним символом LF) и обратно.</p>
                </dd>

                <dt><strong
                 class="COMMAND">ptx</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">ptx [targetfile]</strong> выводит a
                  упорядоченный предметный указатель для targetfile,
                  который можно обработать, по мере необходимости,
                  какой либо утилитой форматирования, в конвейере.</p>
                </dd>

                <dt><strong
                 class="COMMAND">more</strong>, <strong
                 class="COMMAND">less</strong></dt>

                <dd>
                  <p>Команды постраничного просмотра текстовых файлов
                  или потоков на <tt
                   class="FILENAME">stdout</tt>. Могут использоваться в
                  сценариях в качестве фильтров.</p>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="COMMUNICATIONS"></a>12.6. Команды для работы с
            сетью</h2>

            <p>Команды, описываемые в этом разделе, могут найти
            применение при исследовании и анализе процессов передачи
            данных по сети, а также могут использоваться в <a
             href="#CSPAMMERS">борьбе со спамерами</a>.</p>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="COMMUNINFO1"></a>Информация и
              статистика</strong></p>

              <dl>
                <dt><strong
                 class="COMMAND">host</strong></dt>

                <dd>
                  <p>Возвращает информацию об узле Интернета, по
                  заданному имени или IP адресу, выполняя поиск с
                  помощью службы DNS.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>host surfacemail.com</strong></tt>
<tt
 class="COMPUTEROUTPUT">surfacemail.com. has address 202.92.42.236</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">ipcalc</strong></dt>

                <dd>
                  <p>Производит поиск IP адреса. С ключом <tt
                   class="OPTION">-h</tt>, <strong
                   class="COMMAND">ipcalc</strong> выполняет поиск
                  имени хоста в DNS, по заданному IP адресу.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ipcalc -h 202.92.42.236</strong></tt>
<tt
 class="COMPUTEROUTPUT">HOSTNAME=surfacemail.com</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">nslookup</strong></dt>

                <dd>
                  <p>Выполняет <span
                   class="QUOTE">&quot;поиск имени узла&quot;</span>
                  Интернета по заданному IP адресу. По сути,
                  эквивалентна командам <strong
                   class="COMMAND">ipcalc -h</strong> и <strong
                   class="COMMAND">dig -x</strong>. Команда может
                  исполняться как в интерактивном, так и в
                  неинтерактивном режиме, т.е. в пределах сценария.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>nslookup -sil 66.97.104.180</strong></tt>
<tt
 class="COMPUTEROUTPUT">nslookup kuhleersparnis.ch
 Server:         135.116.137.2
 Address:        135.116.137.2#53

 Non-authoritative answer:
 Name:   kuhleersparnis.ch</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">dig</strong></dt>

                <dd>
                  <p>Подобно команде <strong
                   class="COMMAND">nslookup</strong>, выполняет <span
                   class="QUOTE">&quot;поиск имени узла&quot;</span> в
                  Интернете.</p>

                  <p>Сравните вывод команды <strong
                   class="COMMAND">dig -x</strong> с выводом команд
                  <strong
                   class="COMMAND">ipcalc -h</strong> и <strong
                   class="COMMAND">nslookup</strong>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>dig -x 81.9.6.2</strong></tt>
<tt
 class="COMPUTEROUTPUT">;; Got answer:
 ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 11649
 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0

 ;; QUESTION SECTION:
 ;2.6.9.81.in-addr.arpa.         IN      PTR

 ;; AUTHORITY SECTION:
 6.9.81.in-addr.arpa.    3600    IN      SOA     ns.eltel.net. noc.eltel.net.
 2002031705 900 600 86400 3600

 ;; Query time: 537 msec
 ;; SERVER: 135.116.137.2#53(135.116.137.2)
 ;; WHEN: Wed Jun 26 08:35:24 2002
 ;; MSG SIZE  rcvd: 91</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">traceroute</strong></dt>

                <dd>
                  <p>Утилита предназначена для исследования топологии
                  сети посредством передачи ICMP пакетов удаленному
                  узлу. Эта программа может работать в LAN, WAN и в
                  Интернет. Удаленный узел может быть указан как по
                  имени, так и по IP адресу. Вывод команды traceroute
                  может быть передан по конвейеру утилитам <a
                   href="#GREPREF">grep</a> или <a
                   href="#SEDREF">sed</a>, для дальнейшего анализа.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>traceroute 81.9.6.2</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">traceroute to 81.9.6.2 (81.9.6.2), 30 hops max, 38 byte packets
 1  tc43.xjbnnbrb.com (136.30.178.8)  191.303 ms  179.400 ms  179.767 ms
 2  or0.xjbnnbrb.com (136.30.178.1)  179.536 ms  179.534 ms  169.685 ms
 3  192.168.11.101 (192.168.11.101)  189.471 ms  189.556 ms *
 ...</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">ping</strong></dt>

                <dd>
                  <p>Выполняет передачу пакета <span
                   class="QUOTE">&quot;ICMP ECHO_REQUEST&quot;</span>
                  другой системе в сети. Чаще всего служит в качестве
                  инструмента диагностики соединений, должна
                  использоваться с большой осторожностью.</p>

                  <p>В случае успеха, <strong
                   class="COMMAND">ping</strong> возвращает <a
                   href="#EXITSTATUSREF">код завершения</a> <span
                   class="ERRORCODE">0</span>, поэтому команда ping
                  может использоваться в условных операторах.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ping localhost</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.
 Warning: time of day goes back, taking countermeasures.
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709 usec
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286 usec

 --- localhost.localdomain ping statistics ---
 2 packets transmitted, 2 packets received, 0% packet loss
 round-trip min/avg/max/mdev = 0.286/0.497/0.709/0.212 ms</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="WHOISREF"></a><strong
                 class="COMMAND">whois</strong></dt>

                <dd>
                  <p>Выполняет поиск в DNS (Domain Name System). Ключом
                  <tt
                   class="OPTION">-h</tt> можно указать какой из <span
                   class="emphasis"><em
                   class="EMPHASIS">whois</em></span> серверов будет
                  запрошен. См. <a
                   href="#EX18">Пример 4-6</a>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">finger</strong></dt>

                <dd>
                  <p>Возвращает информацию о пользователях в сети. По
                  желанию, эта команда может выводить содержимое файлов
                  <tt
                   class="FILENAME">~/.plan</tt>, <tt
                   class="FILENAME">~/.project</tt> и <tt
                   class="FILENAME">~/.forward</tt>, указанного
                  пользователя.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>finger</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Login  Name           Tty      Idle  Login Time   Office     Office Phone
 bozo   Bozo Bozeman   tty1        8  Jun 25 16:59
 bozo   Bozo Bozeman   ttyp0          Jun 25 16:59
 bozo   Bozo Bozeman   ttyp1          Jun 25 17:07</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>finger bozo</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Login: bozo                             Name: Bozo Bozeman
 Directory: /home/bozo                   Shell: /bin/bash
 On since Fri Aug 31 20:13 (MST) on tty1    1 hour 38 minutes idle
 On since Fri Aug 31 20:13 (MST) on pts/0   12 seconds idle
 On since Fri Aug 31 20:13 (MST) on pts/1
 On since Fri Aug 31 20:31 (MST) on pts/2   1 hour 16 minutes idle
 No mail.
 No Plan.</tt>
             
</pre>
                  <br>
                  <br>

                  <p>По соображениям безопасности, в большинстве сетей
                  служба <strong
                   class="COMMAND">finger</strong>, и соответствующий
                  демон, отключена. <a
                   name="AEN8859"
                   href="#FTN.AEN8859"><span
                   class="footnote">[32]</span></a></p>
                </dd>

                <dt><strong
                 class="COMMAND">vrfy</strong></dt>

                <dd>
                  <p>Проверка адреса электронной почты.</p>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="COMMREMOTE1"></a>Доступ к удаленным
              системам</strong></p>

              <dl>
                <dt><strong
                 class="COMMAND">sx</strong>, <strong
                 class="COMMAND">rx</strong></dt>

                <dd>
                  <p>Команды <strong
                   class="COMMAND">sx</strong> и <strong
                   class="COMMAND">rx</strong> служат для
                  приема/передачи файлов на/из удаленный узел в сети,
                  по протоколу <span
                   class="emphasis"><em
                   class="EMPHASIS">xmodem</em></span>. Входят в состав
                  пакета <strong
                   class="COMMAND">minicom</strong>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">sz</strong>, <strong
                 class="COMMAND">rz</strong></dt>

                <dd>
                  <p>Команды <strong
                   class="COMMAND">sz</strong> и <strong
                   class="COMMAND">rz</strong> служат для
                  приема/передачи файлов на/из удаленный узел в сети,
                  по протоколу <span
                   class="emphasis"><em
                   class="EMPHASIS">zmodem</em></span>. Протокол <span
                   class="emphasis"><em
                   class="EMPHASIS">zmodem</em></span> имеет некоторые
                  преимущества перед протоколом <span
                   class="emphasis"><em
                   class="EMPHASIS">xmodem</em></span>, в качестве
                  такого преимущества можно назвать более высокую
                  скорость передачи и возможность возобновления
                  передачи, в случае ее разрыва. Входят в состав пакета
                  <strong
                   class="COMMAND">minicom</strong>.</p>
                </dd>

                <dt><a
                 name="FTPREF"></a><strong
                 class="COMMAND">ftp</strong></dt>

                <dd>
                  <p>Под этим именем подразумевается утилита и протокол
                  передачи файлов. Сеансы ftp могут устанавливаться из
                  сценариев (см. <a
                   href="#EX72">Пример 17-7</a>, <a
                   href="#ENCRYPTEDPW">Пример A-5</a> и <a
                   href="#FTPGET">Пример A-14</a>).</p>
                </dd>

                <dt><strong
                 class="COMMAND">uucp</strong></dt>

                <dd>
                  <p><span
                   class="emphasis"><em
                   class="EMPHASIS">UNIX to UNIX copy</em></span>. Это
                  коммуникационный пакет для передачи файлов между UNIX
                  серверами. Сценарий на языке командной оболочки --
                  один из самых эффективных способов автоматизации
                  такого обмена.</p>

                  <p>Похоже, что с появлением Интернет и электронной
                  почты, <strong
                   class="COMMAND">uucp</strong> постепенно уходит в
                  небытие, однако, она с успехом может использоваться в
                  изолированных, не имеющих выхода в Интернет,
                  сетях.</p>
                </dd>

                <dt><strong
                 class="COMMAND">cu</strong></dt>

                <dd>
                  <p><span
                   class="emphasis"><em
                   class="EMPHASIS">C</em></span>all <span
                   class="emphasis"><em
                   class="EMPHASIS">U</em></span>p -- выполняет
                  соединение с удаленной системой, как простой
                  терминал. Эта команда является частью пакета <strong
                   class="COMMAND">uucp</strong> и, своего рода,
                  упрощенным вариантом команды <a
                   href="#TELNETREF">telnet</a>.</p>
                </dd>

                <dt><a
                 name="TELNETREF"></a><strong
                 class="COMMAND">telnet</strong></dt>

                <dd>
                  <p>Утилита и протокол для подключения к удаленной
                  системе.</p>

                  <div
                   class="CAUTION">
                    <table
                     class="CAUTION"
                     width="90%"
                     border="0">
                      <tr>
                        <td
                         width="25"
                         align="center"
                         valign="top"><img
                         src="misc/abs-book/images/caution.gif"
                         hspace="5"
                         alt="Caution"></td>

                        <td
                         align="left"
                         valign="top">
                          <p>Протокол telnet небезопасен по своей
                          природе, поэтому следует воздерживаться от
                          его использования.</p>
                        </td>
                      </tr>
                    </table>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">wget</strong></dt>

                <dd>
                  <p><strong
                   class="COMMAND">wget</strong> -- <span
                   class="emphasis"><em
                   class="EMPHASIS">неинтерактивная</em></span> утилита
                  для скачивания файлов с Web или ftp сайтов.</p>
<pre
 class="PROGRAMLISTING">
wget -p http://www.xyz23.com/file01.html
wget -r ftp://ftp.xyz24.net/~bozo/project_files/ -o $SAVEFILE
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">lynx</strong></dt>

                <dd>
                  <p><strong
                   class="COMMAND">lynx</strong> -- Web браузер, внутри
                  сценариев (с ключом <tt
                   class="OPTION">-dump</tt>) может использоваться для
                  скачивания файлов с Web или ftp сайтов, в
                  неинтерактивном режиме.</p>
<pre
 class="PROGRAMLISTING">
lynx -dump http://www.xyz23.com/file01.html &gt;$SAVEFILE
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">rlogin</strong></dt>

                <dd>
                  <p><tt
                   class="REPLACEABLE"><em>Remote login</em></tt> --
                  инициирует сессию с удаленной системой. Эта команда
                  небезопасна, вместо нее лучше использовать <a
                   href="#SSHREF">ssh</a>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">rsh</strong></dt>

                <dd>
                  <p><tt
                   class="REPLACEABLE"><em>Remote shell</em></tt> --
                  исполняет команду на удаленной системе. Эта команда
                  небезопасна, вместо нее лучше использовать <a
                   href="#SSHREF">ssh</a>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">rcp</strong></dt>

                <dd>
                  <p><tt
                   class="REPLACEABLE"><em>Remote copy</em></tt> --
                  копирование файлов между двумя машинами через сеть.
                  Подобно прочим r* утилитам, команда <strong
                   class="COMMAND">rcp</strong> небезопасна и потому,
                  использовать ее в сценариях нежелательно. В качестве
                  замены можно порекомендовать <strong
                   class="COMMAND">ssh</strong> или <strong
                   class="COMMAND">expect</strong>.</p>
                </dd>

                <dt><a
                 name="SSHREF"></a><strong
                 class="COMMAND">ssh</strong></dt>

                <dd>
                  <p><tt
                   class="REPLACEABLE"><em>Secure shell</em></tt> --
                  устанавливает сеанс связи и выполняет команды на
                  удаленной системе. Выступает в качестве защищенной
                  замены для <strong
                   class="COMMAND">telnet</strong>, <strong
                   class="COMMAND">rlogin</strong>, <strong
                   class="COMMAND">rcp</strong> и <strong
                   class="COMMAND">rsh</strong>. Использует
                  идентификацию, аутентификацию и шифрование
                  информации, передаваемой через сеть. Подробности вы
                  найдете в <span
                   class="emphasis"><em
                   class="EMPHASIS">man ssh</em></span>.</p>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="COMMLOCAL1"></a>Локальная сеть</strong></p>

              <dl>
                <dt><a
                 name="WRITEREF"></a><strong
                 class="COMMAND">write</strong></dt>

                <dd>
                  <p>Эта утилита позволяет передать текст сообщения на
                  другой терминал (console или xterm). Разрешить или
                  запретить доступ к терминалу можно с помощью команды
                  <a
                   href="#MESGREF">mesg</a>.</p>

                  <p>Поскольку команда <strong
                   class="COMMAND">write</strong> работает в
                  интерактивном режиме, то, как правило, она не
                  употребляется в сценариях.</p>
                </dd>
              </dl>
            </div>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="COMMMAIL1"></a>Mail</strong></p>

              <dl>
                <dt><strong
                 class="COMMAND">mail</strong></dt>

                <dd>
                  <p>Чтение или передача электронной почты.</p>

                  <p>Этот почтовый клиент командной строки с успехом
                  может использоваться в сценариях.</p>

                  <div
                   class="EXAMPLE">
                    <a
                     name="SELFMAILER"></a>

                    <p><strong>Пример 12-31. Сценарий, отправляющий
                    себя самого по электронной почте</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/sh
# self-mailer.sh: Сценарий отправляет себя самого по электронной почте

adr=${1:-`whoami`}     # Если пользователь не указан, то -- себе самому.
#  Вызов &#39;self-mailer.sh wiseguy@superdupergenius.com&#39;
#+ приведет к передаче электронного письма по указанному адресу.
#  Вызов &#39;self-mailer.sh&#39; (без аргументов) -- отправит письмо
#+ пользователю, запустившему сценарий, например, bozo@localhost.localdomain.
#
#  Дополнительно о конструкции ${parameter:-default},
#+ см. раздел &quot;Подстановка параметров&quot;
#+ в главе &quot;К вопросу о переменных&quot;.

# ============================================================================
  cat $0 | mail -s &quot;Сценарий \&quot;`basename $0`\&quot; отправил себя сам.&quot; &quot;$adr&quot;
# ============================================================================

# --------------------------------------------
#  Поздравляю!
#  Этот сценарий запустила какая-то &quot;редиска&quot;,
#+ и заставила отправить этот текст к Вам.
#  Очевидно кто-то не знает
#+ куда девать свое время.
# --------------------------------------------

echo &quot;`date`, сценарий \&quot;`basename $0`\&quot; отправлен &quot;$adr&quot;.&quot;

exit 0
</pre>
                  </div>
                </dd>

                <dt><strong
                 class="COMMAND">mailto</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">mailto</strong>, похожа на <strong
                   class="COMMAND">mail</strong>, она также отправляет
                  сообщения по электронной почте. Однако, кроме этого,
                  <strong
                   class="COMMAND">mailto</strong> позволяет отправлять
                  MIME (multimedia) сообщения.</p>
                </dd>

                <dt><strong
                 class="COMMAND">vacation</strong></dt>

                <dd>
                  <p>Эта утилита предназначена для автоматической
                  передачи ответов на электронные письма, например для
                  того, чтобы уведомить отправителя о том, что
                  получатель временно отсутствует. Работает совместно с
                  <strong
                   class="COMMAND">sendmail</strong> и не может
                  использоваться для передачи сообщений через
                  коммутируемые линии (по модему).</p>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="TERMINALCCMDS"></a>12.7. Команды управления
            терминалом</h2>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="TERMCOMMANDLISTING1"></a>Команды, имеющие
              отношение к консоли или терминалу</strong></p>

              <dl>
                <dt><strong
                 class="COMMAND">tput</strong></dt>

                <dd>
                  <p>инициализация терминала или выполнение запроса к
                  базе данных терминалов <tt
                   class="FILENAME">terminfo</tt>. С помощью <strong
                   class="COMMAND">tput</strong> можно выполнять
                  различные операции. <strong
                   class="COMMAND">tput clear</strong> -- эквивалентно
                  команде <strong
                   class="COMMAND">clear</strong>. <strong
                   class="COMMAND">tput reset</strong> -- эквивалентно
                  команде <strong
                   class="COMMAND">reset</strong>. <strong
                   class="COMMAND">tput sgr0</strong> -- так же
                  сбрасывет настройки терминал, но без очистки
                  экрана.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>tput longname</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">xterm terminal emulator (XFree86 4.0 Window System)</tt>
             
</pre>
                  <br>
                  <br>

                  <p>Команда <strong
                   class="COMMAND">tput cup X Y</strong> перемещает
                  курсор в координаты (X,Y). Обычно этой команде
                  предшествует <strong
                   class="COMMAND">clear</strong>, очищающая экран.</p>

                  <p>Обратите внимание: <a
                   href="#STTYREF">stty</a> предлагает более широкий
                  диапазон возможностей.</p>
                </dd>

                <dt><strong
                 class="COMMAND">infocmp</strong></dt>

                <dd>
                  <p>Cравнение или печать информации о характеристиках
                  терминалов, хранящейся в базе данных <span
                   class="emphasis"><em
                   class="EMPHASIS">terminfo</em></span>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>infocmp</strong></tt>
<tt
 class="COMPUTEROUTPUT">#       Reconstructed via infocmp from file:
 /usr/share/terminfo/r/rxvt
 rxvt|rxvt terminal emulator (X Window System),
         am, bce, eo, km, mir, msgr, xenl, xon,
         colors#8, cols#80, it#8, lines#24, pairs#64,
         acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
         bel=^G, blink=\E[5m, bold=\E[1m,
         civis=\E[?25l,
         clear=\E[H\E[2J, cnorm=\E[?25h, cr=^M,
         ...</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><strong
                 class="COMMAND">reset</strong></dt>

                <dd>
                  <p>Сбрасывает настройки терминала и очищает экран.
                  Как и в случае команды <strong
                   class="COMMAND">clear</strong>, курсор и приглашение
                  к вводу (prompt) выводятся в верхнем левом углу
                  терминала.</p>
                </dd>

                <dt><a
                 name="CLEARREF"></a><strong
                 class="COMMAND">clear</strong></dt>

                <dd>
                  <p>Команда <strong
                   class="COMMAND">clear</strong> просто очищает экран
                  терминала или окно xterm. Курсор и приглашение к
                  вводу (prompt) выводятся в верхнем левом углу
                  терминала. Эта команда может запускаться как из
                  командной строки, так и из сценария. См. <a
                   href="#EX30">Пример 10-25</a>.</p>
                </dd>

                <dt><strong
                 class="COMMAND">script</strong></dt>

                <dd>
                  <p>Эта утилита позволяет сохранять в файле все
                  символы, введенные пользователем c клавиатуры (вывод
                  тоже). Получая, фактически, подробнейший синхронный
                  протокол сессии.</p>
                </dd>
              </dl>
            </div>
          </div>

          <div
           class="SECT1">
            <hr>

            <h2
             class="SECT1"><a
             name="MATHC"></a>12.8. Команды выполнения математических
            операций</h2>

            <div
             class="VARIABLELIST">
              <p><strong><a
               name="MATHCOMMANDLISTING1"></a></strong></p>

              <dl>
                <dt><strong
                 class="COMMAND">factor</strong></dt>

                <dd>
                  <p>Разложение целого числа на простые множители.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>factor 27417</strong></tt>
<tt
 class="COMPUTEROUTPUT">27417: 3 13 19 37</tt>
             
</pre>
                  <br>
                  <br>
                </dd>

                <dt><a
                 name="BCREF"></a><strong
                 class="COMMAND">bc</strong></dt>

                <dd>
                  <p>Bash не в состоянии выполнять действия над числами
                  с плавающей запятой и не содержит многих важных
                  математических функций. К счастью существует <strong
                   class="COMMAND">bc</strong>.</p>

                  <p>Универсальная, выполняющая вычисления с
                  произвольной точностью, утилита <strong
                   class="COMMAND">bc</strong> обладает некоторыми
                  возможностями, характерными для языков
                  программирования.</p>

                  <p>Синтаксис <strong
                   class="COMMAND">bc</strong> немного напоминает язык
                  C.</p>

                  <p>Поскольку это утилита UNIX, то она может
                  достаточно широко использоваться в сценариях на языке
                  командной оболочки, в том числе и в <a
                   href="#PIPEREF">конвейерной</a> обработке
                  данных.</p>

                  <p>Ниже приводится простой шаблон работы с утилитой
                  <strong
                   class="COMMAND">bc</strong> в сценарии. Здесь
                  используется прием <a
                   href="#COMMANDSUBREF">подстановки команд</a>.</p>
<pre
 class="SCREEN">
             <tt
 class=
"USERINPUT"><strong>variable=$(echo &quot;OPTIONS; OPERATIONS&quot; | bc)</strong></tt>
             
</pre>
                  <br>
                  <br>

                  <div
                   class="EXAMPLE">
                    <a
                     name="MONTHLYPMT"></a>

                    <p><strong>Пример 12-32. Ежемесячные выплаты по
                    займу</strong></p>
					<a href="abs5.html">Advanced Bash-Scripting Guide - Часть 5</a>

  </body>
</html>

